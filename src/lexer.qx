token
{
    TERMINATION;
    FAIL;

    HASH_LP;
    HASH_SEMICOLON;
    LP;
    RP;
    DOT;
    ELLIPSIS;
    COMMA_AT;
    COMMA;
    QUOTE;
    BACKTICK;
    IDENTIFIER;
    BOOLEAN;
    STRING;
    CHARACTER;
    NUMBER;
}

define
{
    /* Skipper and delimiter */
    whitespace                  [ \n\t]
    comment                     ;.*
    atomsphere                  {whitespace}|{comment}
    intertoken_space            {atomsphere}+
    delimiter                   {whitespace}|[()";]

    /* Identifier (symbol) */
    letter                      [a-z]
    special_initial             [!$%&*/:<=>?^_~]
    digit                       [0-9]
    initial                     {letter}
                                |{special_initial}
    digit                       [0-9]
    special_subsequent          [+\-.@]
    subsequent                  {initial}|{digit}|{special_subsequent}
    peculiar_identifier         "+"|"-"|"..."
    identifier                  {initial}{subsequent}*|{peculiar_identifier}


    /* Number */
    number                      [0-9]+

    /* Character */
    character_name              "space"|"newline"
    character                   #\\{character_name}|#\\.

    /* Boolean */
    boolean                     #[tf]
}

start = MAIN;

mode FAILURE : <inheritable: only>
{
    <<FAIL>> => TKN_FAIL (Lexeme);
}

mode EOF : <inheritable: only>
{
    <<EOF>> => TKN_TERMINATION (Lexeme);
}

mode MAIN : FAILURE, EOF
{
    /* Skippers */
    {intertoken_space}          {}

    /* Punctuations */
    "#;"                        => TKN_HASH_SEMICOLON (Lexeme);
    "#("                        => TKN_HASH_LP (Lexeme);
    "("                         => TKN_LP (Lexeme);
    ")"                         => TKN_RP (Lexeme);
    "."                         => TKN_DOT (Lexeme);
    "..."                       => TKN_ELLIPSIS (Lexeme);

    /* Abbreviations */
    ,@                          => TKN_COMMA_AT (Lexeme);
    ,                           => TKN_COMMA (Lexeme);
    "'"                         => TKN_QUOTE (Lexeme);
    `                           => TKN_BACKTICK (Lexeme);

    /* Symbols */
    {identifier}/{delimiter}    => TKN_IDENTIFIER (Lexeme);

    /* Number */
    {number}/{delimiter}        => TKN_NUMBER (Lexeme);

    /* Booleans */
    {boolean}/{delimiter}       => TKN_BOOLEAN (LexemeBegin + 1, LexemeEnd);

    /* Characters */
    #\\null/{delimiter}         => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\alarm/{delimiter}        => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\backspace/{delimiter}    => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\tab/{delimiter}          => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\newline/{delimiter}      => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\return/{delimiter}       => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\space/{delimiter}        => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\escape/{delimiter}       => TKN_CHARACTER (Lexeme + 2, LexemeEnd);
    #\\delete/{delimiter}       => TKN_CHARACTER (Lexeme + 2, LexemeEnd);

    #\\./{delimiter}            => TKN_CHARACTER (Lexeme + 2, LexemeEnd);

    /* Strings */
    "\""                        => GOSUB (STRING);
}

mode STRING : EOF, FAILURE
{
    on_entry                    { self_accumulator_clear (); }
    on_exit                     {
                                  self_accumulator_add_character ('\0');
                                  self_accumulator_flush (TKN_STRING);
                                }

    \\a                         { self_accumulator_add_character ('\a'); }
    \\t                         { self_accumulator_add_character ('\t'); }
    \\n                         { self_accumulator_add_character ('\n'); }
    \\r                         { self_accumulator_add_character ('\r'); }
    \\\"                        { self_accumulator_add_character ('\"'); }
    \\\\                        { self_accumulator_add_character ('\\'); }
    \n                          { self_accumulator_add_character ('\n'); }

    \"                          => GOUP ();

    .                           { self_accumulator_add (Lexeme, LexemeEnd); }
}
