       

namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;




}







extern "C" {



typedef unsigned int size_t;



typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;




__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;







__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;


__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct { int __val[2]; } __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;

__extension__ typedef int __daddr_t;
__extension__ typedef long int __swblk_t;
__extension__ typedef int __key_t;


__extension__ typedef int __clockid_t;


__extension__ typedef void * __timer_t;


__extension__ typedef long int __blksize_t;




__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;


__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;


__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;

__extension__ typedef int __ssize_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


__extension__ typedef int __intptr_t;


__extension__ typedef unsigned int __socklen_t;
struct _IO_FILE;



typedef struct _IO_FILE FILE;





typedef struct _IO_FILE __FILE;




typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;

typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));
typedef __builtin_va_list __gnuc_va_list;
struct _IO_jump_t; struct _IO_FILE;
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
  __off64_t _offset;
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
}




typedef __gnuc_va_list va_list;
typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __ssize_t ssize_t;







typedef _G_fpos_t fpos_t;





typedef _G_fpos64_t fpos64_t;



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (__const char *__filename) throw ();

extern int rename (__const char *__old, __const char *__new) throw ();




extern int renameat (int __oldfd, __const char *__old, int __newfd,
       __const char *__new) throw ();








extern FILE *tmpfile (void) ;
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

extern int fflush_unlocked (FILE *__stream);
extern int fcloseall (void);









extern FILE *fopen (__const char *__restrict __filename,
      __const char *__restrict __modes) ;




extern FILE *freopen (__const char *__restrict __filename,
        __const char *__restrict __modes,
        FILE *__restrict __stream) ;


extern FILE *fopen64 (__const char *__restrict __filename,
        __const char *__restrict __modes) ;
extern FILE *freopen64 (__const char *__restrict __filename,
   __const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, __const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     __const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, __const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      __const char *__restrict __format, ...);




extern int printf (__const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      __const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (__const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, __const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       __const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int vdprintf (int __fd, __const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, __const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     __const char *__restrict __format, ...) ;




extern int scanf (__const char *__restrict __format, ...) ;

extern int sscanf (__const char *__restrict __s,
     __const char *__restrict __format, ...) throw ();








extern int vfscanf (FILE *__restrict __s, __const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (__const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (__const char *__restrict __s,
      __const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;






extern char *gets (char *__s) ;

extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (__const char *__restrict __s, FILE *__restrict __stream);





extern int puts (__const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

extern int fputs_unlocked (__const char *__restrict __s,
      FILE *__restrict __stream);
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, __const fpos_t *__pos);



extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, __const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (__const char *__s);






extern int sys_nerr;
extern __const char *__const sys_errlist[];


extern int _sys_nerr;
extern __const char *__const _sys_errlist[];




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
extern FILE *popen (__const char *__command, __const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      __const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       __const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
}
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
  using ::gets;
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
  using ::tmpnam;
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
namespace __gnu_cxx
{
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}








       

extern "C" {


extern void __assert_fail (__const char *__assertion, __const char *__file,
      unsigned int __line, __const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, __const char *__file,
      unsigned int __line,
      __const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
extern "C" {









typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;



__extension__
typedef long long int int64_t;




typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;





__extension__
typedef unsigned long long int uint64_t;






typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;



__extension__
typedef long long int int_least64_t;



typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;



__extension__
typedef unsigned long long int uint_least64_t;






typedef signed char int_fast8_t;





typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__
typedef long long int int_fast64_t;



typedef unsigned char uint_fast8_t;





typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__
typedef unsigned long long int uint_fast64_t;
typedef int intptr_t;


typedef unsigned int uintptr_t;
__extension__
typedef long long int intmax_t;
__extension__
typedef unsigned long long int uintmax_t;



}
       


typedef int ptrdiff_t;
       


extern "C" {













extern void *memcpy (void *__restrict __dest,
       __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const void *memchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *rawmemchr (__const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const void *memrchr (__const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));






typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;


extern int strcoll_l (__const char *__s1, __const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, __const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (__const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (__const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strchr (__const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *strrchr (__const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *strchrnul (__const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (__const char *__s, __const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (__const char *__s, __const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strpbrk (__const char *__s, __const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
}






extern "C++"
{
extern char *strstr (char *__haystack, __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern __const char *strstr (__const char *__haystack,
        __const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
}







extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    __const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" __const char *strcasestr (__const char *__haystack,
           __const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *memmem (__const void *__haystack, size_t __haystacklen,
       __const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        __const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (__const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (__const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *index (__const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern __const char *rindex (__const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (__const char *__s1, __const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (__const char *__s1, __const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       __const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        __const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (__const char *__s1, __const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" __const char *basename (__const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
}
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;

}
       
       

extern "C" {







union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (__const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (__const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern float strtof (__const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1))) ;

extern long double strtold (__const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern long int strtol (__const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern unsigned long int strtoul (__const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;




__extension__
extern long long int strtoq (__const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtouq (__const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;





__extension__
extern long long int strtoll (__const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

__extension__
extern unsigned long long int strtoull (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1))) ;

extern long int strtol_l (__const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern unsigned long int strtoul_l (__const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern long long int strtoll_l (__const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

__extension__
extern unsigned long long int strtoull_l (__const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4))) ;

extern double strtod_l (__const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern float strtof_l (__const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;

extern long double strtold_l (__const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3))) ;
extern char *l64a (long int __n) throw () ;


extern long int a64l (__const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
typedef __pid_t pid_t;





typedef __id_t id_t;
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;


typedef __clock_t clock_t;





typedef __time_t time_t;



typedef __clockid_t clockid_t;
typedef __timer_t timer_t;



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;








typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));


typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;



typedef __sigset_t sigset_t;





struct timespec
  {
    __time_t tv_sec;
    long int tv_nsec;
  };

struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
typedef long int __fd_mask;
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
extern "C" {
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);


}


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw ();
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw ();





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





typedef unsigned long int pthread_t;


typedef union
{
  char __size[36];
  long int __align;
} pthread_attr_t;


typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;




typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;


    int __kind;
    unsigned int __nusers;
    __extension__ union
    {
      int __spins;
      __pthread_slist_t __list;
    };
  } __data;
  char __size[24];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  long int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{
  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;


    unsigned char __flags;
    unsigned char __shared;
    unsigned char __pad1;
    unsigned char __pad2;
    int __writer;
  } __data;
  char __size[32];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[20];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;


}






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();




extern "C" {





extern void *alloca (size_t __size) throw ();





}





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));






extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));







extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;




extern char *__secure_getenv (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (__const char *__name, __const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (__const char *__command) ;






extern char *canonicalize_file_name (__const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern char *realpath (__const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (__const void *, __const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (__const void *, __const void *, void *);





extern void *bsearch (__const void *__key, __const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (__const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     __const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   __const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   __const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (__const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
extern int getsubopt (char **__restrict __optionp,
        char *__const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (__const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));
}
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;
  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;
  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;


  inline long
  abs(long __i) { return labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }


}
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;


  inline long long
  abs(long long __x) { return __x >= 0 ? __x : -__x; }


  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;
  using ::__gnu_cxx::abs;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
       

       




extern "C++" {

namespace std
{
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

  void __verbose_terminate_handler();


}

}

       


       



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    class allocator;







  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;

  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;

  typedef basic_string<wchar_t> wstring;

}
       


namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
       
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

}
       




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };

  template<typename _Tp>
    struct __promote<_Tp, false>
    { typedef _Tp __type; };

  template<typename _Tp, typename _Up>
    struct __promote_2
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;

    public:
      typedef __typeof__(__type1() + __type2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp>
    struct __promote_3
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;

    public:
      typedef __typeof__(__type1() + __type2() + __type3()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    struct __promote_4
    {
    private:
      typedef typename __promote<_Tp>::__type __type1;
      typedef typename __promote<_Up>::__type __type2;
      typedef typename __promote<_Vp>::__type __type3;
      typedef typename __promote<_Wp>::__type __type4;

    public:
      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;
    };


}
       




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
       

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }



  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }


}





namespace std __attribute__ ((__visibility__ ("default")))
{

  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }



}
       







namespace std __attribute__ ((__visibility__ ("default")))
{

  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


}
       



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }

}
namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }






      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }






      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }






      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}


namespace std __attribute__ ((__visibility__ ("default")))
{





  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {
      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;


     

     

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);
    }
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = (__is_integer<_ValueType1>::__value
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  template<typename _Size>
    inline _Size
    __lg(_Size __n)
    {
      _Size __k;
      for (__k = 0; __n != 0; __n >>= 1)
 ++__k;
      return __k - 1;
    }

  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {

      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
       

       




typedef unsigned int wint_t;


typedef __mbstate_t mbstate_t;



extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (__const wchar_t *__s1, __const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (__const wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (__const wchar_t *__s1, __const wchar_t *__s2) throw ();


extern int wcsncasecmp (__const wchar_t *__s1, __const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (__const wchar_t *__s1, __const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (__const wchar_t *__s1, __const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         __const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (__const wchar_t *__s1, __const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, __const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (__const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcschr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsrchr (__const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (__const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (__const wchar_t *__wcs, __const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (__const wchar_t *__wcs, __const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcspbrk (__const wchar_t *__wcs,
           __const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcsstr (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   __const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (__const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wcswcs (__const wchar_t *__haystack,
          __const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern size_t wcsnlen (__const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" __const wchar_t *wmemchr (__const wchar_t *__s, wchar_t __c,
           size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (__const wchar_t *__restrict __s1,
      __const wchar_t *__restrict __s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    __const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, __const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     __const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (__const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         __const char *__restrict __s, size_t __n,
         mbstate_t *__p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (__const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (__const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();




extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    __const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    __const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     __const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     __const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (__const wchar_t *__s, size_t __n) throw ();






extern double wcstod (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (__const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (__const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
extern long int wcstol_l (__const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (__const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (__const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (__const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (__const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (__const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();




extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   __const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    __const wchar_t *__restrict __src, size_t __n)
     throw ();
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       __const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (__const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       __const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (__const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        __const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      __const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (__const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (__const wchar_t *__restrict __s,
      __const wchar_t *__restrict __format, ...)
     throw () ;









extern int vfwscanf (__FILE *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (__const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (__const wchar_t *__restrict __s,
       __const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (__const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (__const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   __const wchar_t *__restrict __format,
   __const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     __const wchar_t *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
}
namespace std
{
  using ::mbstate_t;
}
namespace std __attribute__ ((__visibility__ ("default")))
{
  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;



}







namespace __gnu_cxx
{





  using ::wcstold;
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
namespace std __attribute__ ((__visibility__ ("default")))
{

  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;

}
       





namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
       





extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
void* operator new(std::size_t) throw (std::bad_alloc);
void* operator new[](std::size_t) throw (std::bad_alloc);
void operator delete(void*) throw();
void operator delete[](void*) throw();
void* operator new(std::size_t, const std::nothrow_t&) throw();
void* operator new[](std::size_t, const std::nothrow_t&) throw();
void operator delete(void*, const std::nothrow_t&) throw();
void operator delete[](void*, const std::nothrow_t&) throw();


inline void* operator new(std::size_t, void* __p) throw() { return __p; }
inline void* operator new[](std::size_t, void* __p) throw() { return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };

      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }



      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }
      void
      destroy(pointer __p) { __p->~_Tp(); }
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}





namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Tp>
    class allocator;


  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };
    };
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };

      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }




  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };

}

       


       

       


enum
{
  __LC_CTYPE = 0,
  __LC_NUMERIC = 1,
  __LC_TIME = 2,
  __LC_COLLATE = 3,
  __LC_MONETARY = 4,
  __LC_MESSAGES = 5,
  __LC_ALL = 6,
  __LC_PAPER = 7,
  __LC_NAME = 8,
  __LC_ADDRESS = 9,
  __LC_TELEPHONE = 10,
  __LC_MEASUREMENT = 11,
  __LC_IDENTIFICATION = 12
};

extern "C" {



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
};



extern char *setlocale (int __category, __const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


extern __locale_t newlocale (int __category_mask, __const char *__locale,
        __locale_t __base) throw ();
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
       





namespace std __attribute__ ((__visibility__ ("default")))
{

  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
       


extern "C" {
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
extern __const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const));
extern __const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const));






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
}
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}

namespace std __attribute__ ((__visibility__ ("default")))
{

  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
       


       



namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}



namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st : public unary_function<_Pair,
           typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
    };

  template<typename _Pair>
    struct _Select2nd : public unary_function<_Pair,
           typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}


       
       




struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


}







struct __sched_param
  {
    int __sched_priority;
  };
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}




extern "C" {


extern int sched_setparam (__pid_t __pid, __const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          __const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         __const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
extern "C" {












struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  __const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   __const char *__restrict __format,
   __const struct tm *__restrict __tp) throw ();





extern char *strptime (__const char *__restrict __s,
         __const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     __const char *__restrict __format,
     __const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (__const char *__restrict __s,
    __const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (__const time_t *__timer) throw ();



extern struct tm *localtime (__const time_t *__timer) throw ();





extern struct tm *gmtime_r (__const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (__const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (__const struct tm *__tp) throw ();


extern char *ctime (__const time_t *__timer) throw ();







extern char *asctime_r (__const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (__const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (__const time_t *__when) throw ();
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
extern int nanosleep (__const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       __const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     __const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();
extern int getdate_err;
extern struct tm *getdate (__const char *__string);
extern int getdate_r (__const char *__restrict __string,
        struct tm *__restrict __resbufp);


}


typedef int __jmp_buf[6];



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      __const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     __const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ();







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (__const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (__const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (__const pthread_attr_t *__restrict
           __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           __const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (__const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (__const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (__const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (__const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (__const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (__const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (__const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      __const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, __const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       __const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          __const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        __const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (__const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (__const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (__const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (__const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (__const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (__const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (__const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    __const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           __const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (__const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         __const pthread_condattr_t *__restrict
         __cond_attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __const struct timespec *__restrict
       __abstime) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (__const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (__const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     __const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (__const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    __const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();
}
extern "C" {



typedef __socklen_t socklen_t;
extern int access (__const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (__const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, __const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
extern __off_t lseek (int __fd, __off_t __offset, int __whence) throw ();
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, __const void *__buf, size_t __n) ;
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, __const void *__buf, size_t __n,
         __off_t __offset) ;
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, __const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
extern unsigned int alarm (unsigned int __seconds) throw ();
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
extern int pause (void);



extern int chown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (__const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, __const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (__const char *__path, char *__const __argv[],
     char *__const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *__const __argv[], char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (__const char *__path, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (__const char *__path, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (__const char *__file, char *__const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (__const char *__file, __const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (__const char *__file, char *__const __argv[],
      char *__const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };


extern long int pathconf (__const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
extern int setpgrp (void) throw ();
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw ();




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw ();




extern int seteuid (__uid_t __uid) throw ();






extern int setgid (__gid_t __gid) throw ();




extern int setregid (__gid_t __rgid, __gid_t __egid) throw ();




extern int setegid (__gid_t __gid) throw ();





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw ();



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw ();






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, __const char *__from, int __tofd,
     __const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (__const char *__from, __const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (__const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (__const char *__from, int __tofd,
        __const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, __const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, __const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (__const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (__const char *__name) throw () __attribute__ ((__nonnull__ (1)));
extern "C" {
extern char *optarg;
extern int optind;




extern int opterr;



extern int optopt;
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
}







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (__const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (__const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (__const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (__const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (__const char *__prompt) __attribute__ ((__nonnull__ (1)));
extern int fsync (int __fd);






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
extern int truncate (__const char *__file, __off_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int truncate64 (__const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int ftruncate (int __fd, __off_t __length) throw () ;
extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
extern long int syscall (long int __sysno, ...) throw ();
extern int lockf (int __fd, int __cmd, __off_t __len) ;
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
extern int fdatasync (int __fildes);







extern char *crypt (__const char *__key, __const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__libc_block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (__const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));







extern char *ctermid (char *__s) throw ();
}

typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));


static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));


static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));


static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &







 __gthrw_pthread_cancel;
  return __gthread_active_ptr != 0;
}
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}



static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}



static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}



static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}



static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait_recursive (__gthread_cond_t *__cond,
        __gthread_recursive_mutex_t *__mutex,
        const __gthread_time_t *__abs_timeout)
{
  return __gthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}







typedef int _Atomic_word;

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __sync_fetch_and_add(__mem, __val); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __sync_fetch_and_add(__mem, __val); }
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}

       

namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
      void
      resize(size_type __n, _CharT __c);
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }







      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
      basic_string&
      append(const basic_string& __str);
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
      basic_string&
      append(size_type __n, _CharT __c);
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
      basic_string&
      assign(const _CharT* __s, size_type __n);
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
      iterator
      erase(iterator __first, iterator __last);
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
      void
      swap(basic_string& __s);
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      { return this->find(__str.data(), __pos, __str.size()); }
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
      size_type
      find(_CharT __c, size_type __pos = 0) const;
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      { return this->rfind(__str.data(), __pos, __str.size()); }
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
      size_type
      rfind(_CharT __c, size_type __pos = npos) const;
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const;
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const;
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
      int
      compare(const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
       



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}

namespace std __attribute__ ((__visibility__ ("default")))
{

  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual ~logic_error() throw();



    virtual const char*
    what() const throw();
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
    virtual ~domain_error() throw();
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
    virtual ~invalid_argument() throw();
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
    virtual ~length_error() throw();
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
    virtual ~out_of_range() throw();
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual ~runtime_error() throw();



    virtual const char*
    what() const throw();
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
    virtual ~range_error() throw();
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
    virtual ~overflow_error() throw();
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
    virtual ~underflow_error() throw();
  };




}
    typedef int32_t QUEX_TYPE_GOTO_LABEL;

namespace moritz {
    struct Lexer_Engine_tag;
    struct Lexer_Memento_tag;

    class Lexer;
    typedef uint32_t (*Lexer_AnalyzerFunctionP)(::moritz::Lexer*);
}



namespace moritz {
    class Token;
}

namespace moritz {




inline void
unicode_to_utf8_character(const uint16_t** input_pp,
                                           uint8_t** output_pp);
inline void
unicode_to_utf16_character(const uint16_t** input_pp,
                                            uint16_t** output_pp);
inline void
unicode_to_utf32_character(const uint16_t** input_pp,
                                            uint32_t** output_pp);
inline void
unicode_to_char_character(const uint16_t** input_pp,
                                           char** output_pp);

inline void
unicode_to_wchar_character(const uint16_t** input_pp,
                                            wchar_t** output_pp);



inline void
unicode_to_utf8(const uint16_t** source_pp,
                                             const uint16_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
unicode_to_utf16(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
unicode_to_utf32(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
unicode_to_char(const uint16_t** source_pp,
                                             const uint16_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
unicode_to_wchar(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    unicode_to_utf8(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<uint16_t>
    unicode_to_utf16(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<uint32_t>
    unicode_to_utf32(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<char>
    unicode_to_char(const std::basic_string<uint16_t>& Source);

    inline std::basic_string<wchar_t>
    unicode_to_wchar(const std::basic_string<uint16_t>& Source);

}







namespace moritz {

inline size_t
Lexer_strlen(const uint16_t* Str);


inline size_t
Lexer_strcmp(const uint16_t* it0,
                  const uint16_t* it1);

}














namespace moritz {
    struct Lexer_MemoryPositionMimiker {

        typedef size_t character_index;







        Lexer_MemoryPositionMimiker(uint16_t* Adr=0x0, character_index Pos=0)
            : address(Adr), buffer_start_position(Pos) {}

        uint16_t* address;
        character_index buffer_start_position;

        bool operator==(const Lexer_MemoryPositionMimiker& That)
        {
          ((this->buffer_start_position == That.buffer_start_position) ? static_cast<void> (0) : __assert_fail ("this->buffer_start_position == That.buffer_start_position", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/MemoryPositionMimiker", 63, __PRETTY_FUNCTION__));
          return this->address == That.address;
        }
        bool operator!=(const Lexer_MemoryPositionMimiker& That)
        { return ! (this->operator==(That)); }

        bool operator==(const uint16_t* ThatAdr) { return this->address == ThatAdr; }
        bool operator!=(const uint16_t* ThatAdr) { return this->address != ThatAdr; }




        void operator+=(const ptrdiff_t Value) { address += Value; buffer_start_position -= (character_index)Value; }
        void operator-=(const ptrdiff_t Value) { address -= Value; buffer_start_position += (character_index)Value; }



        operator uint16_t*() { return address; }
    };

}



namespace moritz {

    typedef struct {






        uint16_t* _front;
        uint16_t* _back;




        uint16_t* _end_of_file_p;


        bool _external_owner_f;
    } Lexer_BufferMemory;

    inline size_t Lexer_BufferMemory_size(Lexer_BufferMemory*);

    typedef struct {
        Lexer_BufferMemory _memory;


        uint16_t* _input_p;
        uint16_t* _lexeme_start_p;
        uint16_t _character_at_lexeme_start;






        ptrdiff_t _content_character_index_begin;





        ptrdiff_t _content_character_index_end;



        bool _byte_order_reversion_active_f;

        struct Lexer_BufferFiller_tag* filler;

        void (*on_buffer_content_change)(uint16_t* BeginOfContent,
                                              uint16_t* EndOfContent);
    } Lexer_Buffer;

    template <class InputHandleT> inline void Lexer_Buffer_construct(Lexer_Buffer* me,
                                                                  InputHandleT* input_handle,
                                                                  uint16_t* InputMemory,
                                                                  const size_t BufferMemorySize,
                                                                  uint16_t* EndOfFileP,
                                                                  const char* CharacterEncodingName,
                                                                  const size_t TranslationBufferMemorySize,
                                                                  bool ByteOrderReversionF);

    template <class InputHandleT> inline void Lexer_Buffer_reset(Lexer_Buffer* me,
                                                              InputHandleT* input_handle,
                                                              const char* CharacterEncodingName,
                                                              const size_t TranslationBufferMemorySize);

    inline void Lexer_Buffer_destruct(Lexer_Buffer* me);

    inline uint16_t* Lexer_Buffer_content_front(Lexer_Buffer*);
    inline uint16_t* Lexer_Buffer_content_back(Lexer_Buffer*);
    inline uint16_t* Lexer_Buffer_text_end(Lexer_Buffer*);
    inline size_t Lexer_Buffer_content_size(Lexer_Buffer*);

    inline Lexer_MemoryPositionMimiker Lexer_Buffer_tell_memory_adr(Lexer_Buffer*);
    inline void Lexer_Buffer_seek_memory_adr(Lexer_Buffer*,
                                                                                Lexer_MemoryPositionMimiker);

    inline void Lexer_Buffer_move_forward(Lexer_Buffer*, const ptrdiff_t CharacterN);
    inline void Lexer_Buffer_move_backward(Lexer_Buffer*, const ptrdiff_t CharacterN);
    inline ptrdiff_t Lexer_Buffer_tell(Lexer_Buffer*);
    inline void Lexer_Buffer_seek(Lexer_Buffer*, const ptrdiff_t CharacterIndex);
    inline void Lexer_Buffer_move_away_passed_content(Lexer_Buffer* me);

    inline void Lexer_Buffer_end_of_file_set(Lexer_Buffer*, uint16_t* Position);
    inline void Lexer_Buffer_end_of_file_unset(Lexer_Buffer*);
    inline bool Lexer_Buffer_is_end_of_file(Lexer_Buffer*);
    inline bool Lexer_Buffer_is_begin_of_file(Lexer_Buffer*);

    inline void Lexer_Buffer_reverse_byte_order(uint16_t* Begin,
                                                             uint16_t* End);

    inline void Lexer_Buffer_print_this(Lexer_Buffer*);

    inline uint16_t* Lexer_BufferMemory_reset(Lexer_BufferMemory* me,
                                                                      uint16_t* Memory,
                                                                      const size_t Size,
                                                                      uint16_t* EndOfContentP);

}

namespace moritz {

    inline uint16_t* Lexer_access_Lexeme(const char* FileName, size_t LineN, Lexer_Buffer*);
    inline size_t Lexer_access_LexemeL(const char* FileName, size_t LineN, Lexer_Buffer*);
    inline uint16_t* Lexer_access_LexemeEnd(const char* FileName, size_t LineN, Lexer_Buffer*);

}








namespace moritz {

     typedef struct Lexer_BufferFiller_tag {
        ptrdiff_t (*tell_character_index)(struct Lexer_BufferFiller_tag*);





        void (*seek_character_index)(struct Lexer_BufferFiller_tag*,
                                            const ptrdiff_t Index);


        size_t (*read_characters)(struct Lexer_BufferFiller_tag*,
                                       uint16_t* memory, const size_t N);



        bool (*_on_overflow)(Lexer_Buffer*, bool ForwardF);



        void (*delete_self)(struct Lexer_BufferFiller_tag*);

    } Lexer_BufferFiller;

    inline void
    Lexer_BufferFiller_setup_functions(Lexer_BufferFiller* me,
                                            ptrdiff_t (*tell_character_index)(Lexer_BufferFiller*),
                                            void (*seek_character_index)(Lexer_BufferFiller*,
                                                                                 const ptrdiff_t),
                                            size_t (*read_characters)(Lexer_BufferFiller*,
                                                                            uint16_t*, const size_t),
                                            void (*delete_self)(Lexer_BufferFiller*));
    template <class InputHandleT> inline Lexer_BufferFiller*
    Lexer_BufferFiller_new(InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize);
    inline void Lexer_BufferFiller_delete_self(Lexer_BufferFiller*);

    inline void Lexer_BufferFiller_initial_load(Lexer_Buffer*);
    inline size_t Lexer_BufferFiller_load_forward(Lexer_Buffer*);
    inline size_t Lexer_BufferFiller_load_backward(Lexer_Buffer*);



    inline void Lexer_BufferFiller_step_forward_n_characters(Lexer_BufferFiller* me,
                                                                          const ptrdiff_t ForwardN);

}



       


       

       





       



       





namespace std __attribute__ ((__visibility__ ("default")))
{

  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
    locale() throw();
    locale(const locale& __other) throw();
    explicit
    locale(const char* __s);
    locale(const locale& __base, const char* __s, category __cat);
    locale(const locale& __base, const locale& __add, category __cat);
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
    const locale&
    operator=(const locale& __other) throw();
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    string
    name() const;
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
    static locale
    global(const locale&);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);
  };
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();

  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    facet(const facet&);

    facet&
    operator=(const facet&);
  };
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    void
    _M_install_cache(const facet*, size_t);
  };
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw();
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc);
  template<typename _CharT>
    class collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }

    protected:
      virtual
      ~collate_byname() { }
    };


}

       

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }


  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }

  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}

namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16
    };

  inline _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16
    };

  inline _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16
    };

  inline _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };
  class ios_base
  {
  public:







    class failure : public exception
    {
    public:


      explicit
      failure(const string& __str) throw();



      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();

    private:
      string _M_msg;
    };
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
    typedef void (*event_callback) (event, ios_base&, int);
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
    static bool
    sync_with_stdio(bool __sync = true);
    locale
    imbue(const locale& __loc) throw();
    locale
    getloc() const
    { return _M_ios_locale; }
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
    static int
    xalloc() throw();
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
    virtual ~ios_base();

  protected:
    ios_base() throw ();



  private:
    ios_base(const ios_base&);

    ios_base&
    operator=(const ios_base&);
  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }


}
       
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(__streambuf_type*, __streambuf_type*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:
      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
      locale
      pubimbue(const locale &__loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
      locale
      getloc() const
      { return _M_buf_locale; }
      __streambuf_type*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }

      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }

      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }

      int
      pubsync() { return this->sync(); }
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
      void
      gbump(int __n) { _M_in_cur += __n; }
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
      void
      pbump(int __n) { _M_out_cur += __n; }
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
      virtual void
      imbue(const locale&)
      { }
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
      virtual int
      sync() { return 0; }
      virtual streamsize
      showmanyc() { return 0; }
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
      virtual int_type
      underflow()
      { return traits_type::eof(); }
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
      virtual int_type
      pbackfail(int_type = traits_type::eof())
      { return traits_type::eof(); }
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
      virtual int_type
      overflow(int_type = traits_type::eof())
      { return traits_type::eof(); }



    public:
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }

    private:


      basic_streambuf(const __streambuf_type& __sb)
      : _M_in_beg(__sb._M_in_beg), _M_in_cur(__sb._M_in_cur),
      _M_in_end(__sb._M_in_end), _M_out_beg(__sb._M_out_beg),
      _M_out_cur(__sb._M_out_cur), _M_out_end(__sb._M_out_cur),
      _M_buf_locale(__sb._M_buf_locale)
      { }

      __streambuf_type&
      operator=(const __streambuf_type&) { return *this; };
    };


  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

       

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
       



       

       



typedef unsigned long int wctype_t;

enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {








extern int iswalnum (wint_t __wc) throw ();





extern int iswalpha (wint_t __wc) throw ();


extern int iswcntrl (wint_t __wc) throw ();



extern int iswdigit (wint_t __wc) throw ();



extern int iswgraph (wint_t __wc) throw ();




extern int iswlower (wint_t __wc) throw ();


extern int iswprint (wint_t __wc) throw ();




extern int iswpunct (wint_t __wc) throw ();




extern int iswspace (wint_t __wc) throw ();




extern int iswupper (wint_t __wc) throw ();




extern int iswxdigit (wint_t __wc) throw ();





extern int iswblank (wint_t __wc) throw ();
extern wctype_t wctype (__const char *__property) throw ();



extern int iswctype (wint_t __wc, wctype_t __desc) throw ();










typedef __const __int32_t *wctrans_t;







extern wint_t towlower (wint_t __wc) throw ();


extern wint_t towupper (wint_t __wc) throw ();


}
extern "C" {




extern wctrans_t wctrans (__const char *__property) throw ();


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) throw ();








extern int iswalnum_l (wint_t __wc, __locale_t __locale) throw ();





extern int iswalpha_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswcntrl_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswdigit_l (wint_t __wc, __locale_t __locale) throw ();



extern int iswgraph_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswlower_l (wint_t __wc, __locale_t __locale) throw ();


extern int iswprint_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswpunct_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswspace_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswupper_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswxdigit_l (wint_t __wc, __locale_t __locale) throw ();




extern int iswblank_l (wint_t __wc, __locale_t __locale) throw ();



extern wctype_t wctype_l (__const char *__property, __locale_t __locale)
     throw ();



extern int iswctype_l (wint_t __wc, wctype_t __desc, __locale_t __locale)
     throw ();







extern wint_t towlower_l (wint_t __wc, __locale_t __locale) throw ();


extern wint_t towupper_l (wint_t __wc, __locale_t __locale) throw ();



extern wctrans_t wctrans_l (__const char *__property, __locale_t __locale)
     throw ();


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      __locale_t __locale) throw ();



}
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
       
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;
  };


}






       




namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT&>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      istreambuf_iterator() throw()
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(istream_type& __s) throw()
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) throw()
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) throw ()
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) throw ()
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const throw()
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}

namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char *__to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
      virtual char_type
      do_toupper(char_type) const = 0;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
      virtual char_type
      do_tolower(char_type) const = 0;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
      virtual char_type
      do_widen(char) const = 0;
      virtual const char*
      do_widen(const char* __lo, const char* __hi,
        char_type* __dest) const = 0;
      virtual char
      do_narrow(char_type, char __dfault) const = 0;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const = 0;
    };
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
      inline bool
      is(mask __m, char __c) const;
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char *__to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
      virtual char_type
      do_toupper(char_type) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char __c) const
      { return __c; }
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }
      virtual char
      do_narrow(char_type __c, char) const
      { return __c; }
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char, char* __dest) const
      {
 __builtin_memcpy(__dest, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
      explicit
      ctype(size_t __refs = 0);
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
      virtual bool
      do_is(mask __m, char_type __c) const;
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
      virtual char_type
      do_toupper(char_type) const;
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_tolower(char_type) const;
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
      virtual char_type
      do_widen(char) const;
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;
      virtual char
      do_narrow(char_type, char __dfault) const;
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __dest) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);

    protected:
      virtual
      ~ctype_byname();
    };



}


namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
        _S_ominus,
        _S_oplus,
        _S_ox,
        _S_oX,
        _S_odigits,
        _S_odigits_end = _S_odigits + 16,
        _S_oudigits = _S_odigits_end,
        _S_oudigits_end = _S_oudigits + 16,
        _S_oe = _S_odigits + 14,
        _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
        { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
      string
      grouping() const
      { return this->do_grouping(); }
      string_type
      truename() const
      { return this->do_truename(); }
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }

    protected:
      virtual
      ~numpunct_byname() { }
    };


  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
        iter_type
        _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
        _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
        _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
        {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate& __err,
      void*&) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, bool __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __f, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill, double __v) const
      { return this->do_put(__s, __f, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __f, __fill, __v); }
      iter_type
      put(iter_type __s, ios_base& __f, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __f, __fill, __v); }

    protected:
      template<typename _ValueT>
        iter_type
        _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
        iter_type
        _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, double __v) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, long double __v) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type __fill, const void* __v) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }


  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

       

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      _M_allocated = true;

      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   _M_grouping_size = __np.grouping().size();
   __grouping = new char[_M_grouping_size];
   __np.grouping().copy(__grouping, _M_grouping_size);
   _M_grouping = __grouping;
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(_M_grouping[0]) > 0
        && (_M_grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   _M_truename_size = __np.truename().size();
   __truename = new _CharT[_M_truename_size];
   __np.truename().copy(__truename, _M_truename_size);
   _M_truename = __truename;

   _M_falsename_size = __np.falsename().size();
   __falsename = new _CharT[_M_falsename_size];
   __np.falsename().copy(__falsename, _M_falsename_size);
   _M_falsename = __falsename;

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);




 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
          __fbuf, __prec, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
       __fbuf, __prec, __v);
   }
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class numpunct<char>;
  extern template class numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class numpunct<wchar_t>;
  extern template class numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}


namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:







      operator void*() const
      { return this->fail() ? 0 : const_cast<basic_ios*>(this); }

      bool
      operator!() const
      { return this->fail(); }
      iostate
      rdstate() const
      { return _M_streambuf_state; }
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
      iostate
      exceptions() const
      { return _M_exception; }
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
      locale
      imbue(const locale& __loc);
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);

      void
      _M_cache_locale(const locale& __loc);
    };


}

       

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}


namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }


      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
      __ostream_type&
      operator<<(__streambuf_type* __sb);
      __ostream_type&
      put(char_type __c);


      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
      __ostream_type&
      write(const char_type* __s, streamsize __n);
      __ostream_type&
      flush();
      pos_type
      tellp();
      __ostream_type&
      seekp(pos_type);
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }

      template<typename _ValueT>
        __ostream_type&
        _M_insert(_ValueT __v);
    };
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
      operator bool() const
      { return _M_ok; }
    };
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }







  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }

}

       



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
       




namespace std __attribute__ ((__visibility__ ("default")))
{

  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:
      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
      __istream_type&
      operator>>(__streambuf_type* __sb);
      streamsize
      gcount() const
      { return _M_gcount; }
      int_type
      get();
      __istream_type&
      get(char_type& __c);
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
      __istream_type&
      ignore();

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore(streamsize __n, int_type __delim);
      int_type
      peek();
      __istream_type&
      read(char_type* __s, streamsize __n);
      streamsize
      readsome(char_type* __s, streamsize __n);
      __istream_type&
      putback(char_type __c);
      __istream_type&
      unget();
      int
      sync();
      pos_type
      tellg();
      __istream_type&
      seekg(pos_type);
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }

      template<typename _ValueT>
        __istream_type&
        _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
      operator bool() const
      { return _M_ok; }
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }
    };
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);

}

       



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}

namespace std __attribute__ ((__visibility__ ("default")))
{

  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
       

extern "C" {









extern int *__errno_location (void) throw () __attribute__ ((__const__));
extern char *program_invocation_name, *program_invocation_short_name;



}
typedef int error_t;

       












       



namespace moritz {
    template <class InputHandleT> struct InputPolicy;

    template <>
    struct InputPolicy<void*> {
        typedef long stream_position;
        typedef long stream_offset;



        static long tell(void* me) { (void)me; return -1L; }
        static void seek(void* me, long& Pos) { (void)me; (void)Pos; ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 30, __PRETTY_FUNCTION__)); }
        static size_t load_bytes(void*, void*, const size_t) { return (size_t)0; }
    };

    template <>
    struct InputPolicy<std::FILE*> {
        typedef long stream_position;
        typedef long stream_offset;

        static long tell(std::FILE* me) { return std::ftell(me); }
        static void seek(std::FILE* me, long& Pos) { std::fseek(me, Pos, 0); }

        static size_t load_bytes(std::FILE* ih, void* buffer_position, const size_t ByteNToRead)
        {
            return fread(buffer_position, 1, ByteNToRead, ih);
        }
    };

    template <class StdStreamType>
    struct InputPolicy<StdStreamType*> {
        typedef typename StdStreamType::pos_type stream_position;
        typedef typename StdStreamType::off_type stream_offset;

        typedef typename StdStreamType::char_type character_type;
        static const size_t CharacterSize = sizeof(typename StdStreamType::char_type);

        static stream_position tell(StdStreamType* me) {
            return me->tellg() * CharacterSize;
        }
        static void seek(StdStreamType* me, const stream_position& Pos) {
            ((Pos % CharacterSize == 0) ? static_cast<void> (0) : __assert_fail ("Pos % CharacterSize == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 74, __PRETTY_FUNCTION__));
            me->seekg(Pos / CharacterSize);
        }

        static size_t load_bytes(StdStreamType* me, void* buffer_position, const size_t ByteNToRead)
        {
            ((CharacterSize != 0) ? static_cast<void> (0) : __assert_fail ("CharacterSize != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 80, __PRETTY_FUNCTION__));
            const stream_position position_before = me->tellg();



            me->read((character_type*)buffer_position, ByteNToRead / CharacterSize);

            const size_t Result = (size_t)(me->gcount());

            if( me->eof() && ! me->bad() ) {
                me->clear();


                if( position_before != (stream_position)-1 ) {
                    me->seekg(position_before + (stream_offset)(Result));
                }
            } else if( me->fail() ) {
                throw std::runtime_error("Fatal error during stream reading.");
            }


            return Result * CharacterSize;
        }
    };







}






namespace moritz {

    typedef struct Lexer_Converter_tag {
        void (*open)(struct Lexer_Converter_tag*,
                        const char* FromCodingName, const char* ToCodingName);







        bool (*convert)(struct Lexer_Converter_tag*,
                           uint8_t** source, const uint8_t* SourceEnd,
                           uint16_t** drain, const uint16_t* DrainEnd);
        void (*on_conversion_discontinuity)(struct Lexer_Converter_tag*);
        void (*delete_self)(struct Lexer_Converter_tag*);



        bool dynamic_character_size_f;




    } Lexer_Converter;



    typedef void (*Lexer_ConverterFunctionP_open)(Lexer_Converter*,
                                                          const char* FromCodingName,
                                                          const char* ToCodingName);

    typedef bool (*Lexer_ConverterFunctionP_convert)(Lexer_Converter*,
                                                             uint8_t** source,
                                                             const uint8_t* SourceEnd,
                                                             uint16_t** drain,
                                                             const uint16_t* DrainEnd);

    typedef void (*Lexer_ConverterFunctionP_on_conversion_discontinuity)(Lexer_Converter*);

    typedef void (*Lexer_ConverterFunctionP_delete_self)(Lexer_Converter*);

}


namespace moritz {

    template <class InputHandleT> struct Lexer_RawBuffer {
        uint8_t* begin;
        uint8_t* end;
        uint8_t* memory_end;

        uint8_t* iterator;
        ptrdiff_t iterators_character_index;

        typename InputPolicy<InputHandleT*>::stream_position end_stream_position;

        bool _external_owner_f;
    } ;

    template <class InputHandleT> struct Lexer_BufferFiller_Converter {



        Lexer_BufferFiller base;

        InputHandleT* ih;

        Lexer_Converter* converter;

        Lexer_RawBuffer<InputHandleT> raw_buffer;



        ptrdiff_t hint_begin_character_index;


        typename InputPolicy<InputHandleT*>::stream_position start_position;

    } ;


    template <class InputHandleT> inline Lexer_BufferFiller_Converter<InputHandleT>*
    Lexer_BufferFiller_Converter_new(InputHandleT* input_handle,
                                          Lexer_Converter* converter,
                                          const char* FromCoding,
                                          const char* ToCoding,
                                          size_t RawBufferSize);

    template <class InputHandleT> inline void Lexer_BufferFiller_Converter_move_away_passed_content(Lexer_BufferFiller_Converter<InputHandleT>*);
    template <class InputHandleT> inline size_t Lexer___BufferFiller_Converter_fill_raw_buffer(Lexer_BufferFiller_Converter<InputHandleT>*);

    template <class InputHandleT> inline void Lexer_RawBuffer_init(Lexer_RawBuffer<InputHandleT>* me,
                                                                uint8_t* Begin, size_t SizeInBytes,
                                                                typename InputPolicy<InputHandleT*>::stream_position StartPosition);
}











    extern "C" {


extern "C" {


typedef void *iconv_t;







extern iconv_t iconv_open (__const char *__tocode, __const char *__fromcode);




extern size_t iconv (iconv_t __cd, char **__restrict __inbuf,
       size_t *__restrict __inbytesleft,
       char **__restrict __outbuf,
       size_t *__restrict __outbytesleft);





extern int iconv_close (iconv_t __cd);

}
    }


namespace moritz {

    typedef struct {
        Lexer_Converter base;

        iconv_t handle;

    } Lexer_Converter_IConv;

    inline Lexer_Converter* Lexer_Converter_IConv_new();

}


namespace moritz {

inline uint16_t*
Lexer_MemoryManager_BufferMemory_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferMemory_free(uint16_t* memory);

inline void*
Lexer_MemoryManager_BufferFiller_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferFiller_free(void* memory);

inline uint8_t*
Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory);


inline uint16_t*
Lexer_MemoryManager_Text_allocate(const size_t ByteN);
inline void
Lexer_MemoryManager_Text_free(uint16_t* memory);


inline void* Lexer_MemoryManager_Converter_allocate(const size_t ByteN);
inline void Lexer_MemoryManager_Converter_free(void* memory);






inline size_t
Lexer_MemoryManager_insert(uint8_t* drain_begin_p, uint8_t* drain_end_p,
                                uint8_t* source_begin_p, uint8_t* source_end_p);
inline struct Lexer_Memento_tag*
Lexer_MemoryManager_Memento_allocate();

inline void
Lexer_MemoryManager_Memento_free(struct Lexer_Memento_tag* memory);


}








namespace moritz {




    class Lexer;


    typedef struct Lexer_Mode_tag {
        int id;
        const char* name;
        ::moritz::Lexer* the_lexer;

        Lexer_AnalyzerFunctionP analyzer_function;






        void (*on_entry)(::moritz::Lexer*, const struct Lexer_Mode_tag* FromMode);
        void (*on_exit)(::moritz::Lexer*, const struct Lexer_Mode_tag* ToMode);

        bool (*has_base)(const struct Lexer_Mode_tag* Mode);
        bool (*has_entry_from)(const struct Lexer_Mode_tag* Mode);
        bool (*has_exit_to)(const struct Lexer_Mode_tag* Mode);

    } Lexer_Mode;

    inline uint32_t
    Lexer_Mode_uncallable_analyzer_function(::moritz::Lexer*);


    inline void
    Lexer_Mode_on_indentation_null_function(::moritz::Lexer*,
                                                 uint16_t* LexemeBegin,
                                                 uint16_t* LexemeEnd);


    inline void
    Lexer_Mode_on_entry_exit_null_function(::moritz::Lexer*, const Lexer_Mode*);

}









       







namespace moritz {
    typedef struct {

        size_t _line_number_at_begin;
        size_t _line_number_at_end;


        size_t _column_number_at_begin;
        size_t _column_number_at_end;





    } Lexer_Counter;


    inline void Lexer_Counter_construct(Lexer_Counter* me);
    inline void Lexer_Counter_init(Lexer_Counter* me);
    inline void Lexer_Counter_reset(Lexer_Counter* me);
    inline void Lexer_Counter_copy_construct(Lexer_Counter* me,
                                                       const Lexer_Counter* That);

    inline void Lexer_Counter_count(Lexer_Counter* me,
                                                         uint16_t* Lexeme,
                                                         uint16_t* LexemeEnd);
    inline uint16_t*
    Lexer_Counter_count_chars_to_newline_backwards(Lexer_Counter* me,
                                                        uint16_t* Begin,
                                                        uint16_t* End);

    inline void Lexer_Counter_print_this(Lexer_Counter* me);

}









namespace moritz {

    struct Lexer_Memento_tag;







    template <class InputHandleT> inline



    Lexer_Memento_tag*
    Lexer_memento_pack(::moritz::Lexer* me,
                            uint16_t* InputName,
                            InputHandleT** input_handle);


    inline

                            void
    Lexer_memento_unpack(::moritz::Lexer* me,
                              struct Lexer_Memento_tag* memento);

    template <class InputHandleT> inline void
    Lexer_include_push(::moritz::Lexer* me,
                            InputHandleT* Optional_InputHandle,
                            uint16_t* Optional_InputName,
                            const Lexer_Mode* Mode,
                            const char* CharacterCodecName );

    template <class InputHandleT> inline void
    Lexer_include_push_input_name(::moritz::Lexer* me,
                                       uint16_t* InputName ,
                                       const Lexer_Mode* mode ,
                                       const char* CharacterCodecName );

    template <class InputHandleT> inline void
    Lexer_include_push_input_handle(::moritz::Lexer* me,
                                         InputHandleT* sh ,
                                         const Lexer_Mode* mode ,
                                         const char* CharacterCodecName );

    inline bool Lexer_include_pop(::moritz::Lexer* me);

    inline void Lexer_include_stack_delete(::moritz::Lexer* me);


}


namespace moritz {




    class Lexer;



    typedef struct {

        size_t _begin_line;


        size_t _begin_column;


        struct {
            uint16_t* begin;
            uint16_t* end;
            uint16_t* memory_end;
        } text;
        ::moritz::Lexer* the_lexer;

    } Lexer_Accumulator;

    inline void
    Lexer_Accumulator_init_memory(Lexer_Accumulator* me);

    inline void
    Lexer_Accumulator_construct(Lexer_Accumulator*, ::moritz::Lexer*);

    inline void
    Lexer_Accumulator_destruct(Lexer_Accumulator* me);

    inline bool
    Lexer_Accumulator_extend(Lexer_Accumulator* me, size_t MinAddSize);

    inline void
    Lexer_Accumulator_clear(Lexer_Accumulator* me);

    inline void
    Lexer_Accumulator_add(Lexer_Accumulator* me,
                               const uint16_t* Begin, const uint16_t* End);

    inline void
    Lexer_Accumulator_add_character(Lexer_Accumulator* me,
                                         const uint16_t Character);

    inline void
    Lexer_Accumulator_print_this(Lexer_Accumulator* me);

}

namespace moritz {

    template <class InputHandleT> inline void
    Lexer_construct_basic(::moritz::Lexer* me,
                               InputHandleT* input_handle,
                               uint16_t* BufferMemory,
                               const size_t BufferMemorySize,
                               uint16_t* EndOfFileP,
                               const char* CharacterEncodingName,
                               const size_t TranslationBufferMemorySize,
                               bool ByteOrderReversionF);

    inline void
    Lexer_destruct_basic(::moritz::Lexer* me);

    template <class InputHandleT> inline void
    Lexer_reset_basic(::moritz::Lexer* me,
                           InputHandleT* input_handle,
                           const char* CharacterEncodingName,
                           const size_t TranslationBufferMemorySize);

    inline void Lexer_buffer_reload_backward(Lexer_Buffer* buffer);
    inline void Lexer_buffer_reload_forward(Lexer_Buffer* buffer,
                                                           Lexer_MemoryPositionMimiker* post_context_start_position,
                                                           const size_t PostContextN);

}



namespace moritz {




template <class InputHandleT> inline

void
Lexer_constructor_core(::moritz::Lexer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            bool ByteOrderReversionF,
                            uint16_t* BufferMemory,
                            size_t BufferMemorySize,
                            uint16_t* BufferEndOfFileP);

inline void
Lexer_construct_memory(::moritz::Lexer* me,
                            uint16_t* BufferMemoryBegin,
                            size_t BufferMemorySize,
                            uint16_t* BufferEndOfFileP,
                            const char* CharacterEncodingName ,
                            bool ByteOrderReversionF );

inline void
Lexer_construct_file_name(::moritz::Lexer* me,
                               const char* Filename,
                               const char* CharacterEncodingName ,
                               bool ByteOrderReversionF );

inline void
Lexer_construct_FILE(::moritz::Lexer* me,
                          std::FILE* fh,
                          const char* CharacterEncodingName ,
                          bool ByteOrderReversionF );


inline void
Lexer_construct_istream(::moritz::Lexer* me,
                             std::istream* p_input_stream,
                             const char* CharacterEncodingName ,
                             bool ByteOrderReversionF );




inline void
Lexer_construct_wistream(::moritz::Lexer* me,
                              std::wistream* p_input_stream,
                              const char* CharacterEncodingName ,
                              bool ByteOrderReversionF );


inline void
Lexer_destruct(::moritz::Lexer* me);

template <class InputHandleT> inline void
Lexer_reset(::moritz::Lexer* me,
                 InputHandleT* input_handle,
                 const char* CharacterEncodingName );

inline uint16_t*
Lexer_reset_buffer(::moritz::Lexer* me,
                        uint16_t* BufferMemoryBegin,
                        size_t BufferMemorySize,
                        uint16_t* BufferEndOfContentP,
                        const char* CharacterEncodingName );

inline void
Lexer_reset_plain(::moritz::Lexer* me,
                       const char* CharacterEncodingName );

}

namespace moritz {


inline void* Lexer_buffer_fill_region_append(::moritz::Lexer* me,
                                                                        void* ContentBegin,
                                                                        void* ContentEnd);
inline void Lexer_buffer_fill_region_prepare(::moritz::Lexer* me);
inline uint16_t* Lexer_buffer_fill_region_begin(::moritz::Lexer* me);
inline uint16_t* Lexer_buffer_fill_region_end(::moritz::Lexer* me);
inline size_t Lexer_buffer_fill_region_size(::moritz::Lexer* me);
inline void Lexer_buffer_fill_region_finish(::moritz::Lexer* me,
                                                                        const size_t LoadedN);

inline uint16_t* Lexer_buffer_lexeme_start_pointer_get(::moritz::Lexer* me);
inline void Lexer_buffer_input_pointer_set(::moritz::Lexer* me,
                                                                       uint16_t*);


inline void* Lexer_buffer_fill_region_append_conversion(::moritz::Lexer* me,
                                                                       void* ContentBegin,
                                                                       void* ContentEnd);
inline void* Lexer_buffer_fill_region_append_conversion_direct(::moritz::Lexer* me,
                                                                              void* ContentBegin,
                                                                              void* ContentEnd);
inline void Lexer_buffer_conversion_fill_region_prepare(::moritz::Lexer* me);
inline uint8_t* Lexer_buffer_conversion_fill_region_begin(::moritz::Lexer* me);
inline uint8_t* Lexer_buffer_conversion_fill_region_end(::moritz::Lexer* me);
inline size_t Lexer_buffer_conversion_fill_region_size(::moritz::Lexer* me);
inline void Lexer_buffer_conversion_fill_region_finish(::moritz::Lexer* me,
                                                                       const size_t ByteN);


}
namespace moritz {


inline void
Lexer_set_callback_on_buffer_content_change(::moritz::Lexer* me,
                                                 void (*callback)(uint16_t*,
                                                                                uint16_t*));


inline bool Lexer_byte_order_reversion(::moritz::Lexer* me);
inline void Lexer_byte_order_reversion_set(::moritz::Lexer* me,
                                                          bool Value);

inline const char* Lexer_version(::moritz::Lexer* me);


inline ::moritz::Token* Lexer_token_p(::moritz::Lexer* me);
inline void Lexer_print_this(::moritz::Lexer* me);

}
namespace moritz {


inline size_t Lexer_tell(::moritz::Lexer* me);
inline void Lexer_seek(::moritz::Lexer* me, const size_t);
inline void Lexer_seek_forward(::moritz::Lexer* me, const size_t);
inline void Lexer_seek_backward(::moritz::Lexer* me, const size_t);
inline void Lexer_undo(::moritz::Lexer* me);
inline void Lexer_undo_n(::moritz::Lexer* me, size_t DeltaN_Backward);

}
namespace moritz {


inline Lexer_Mode* Lexer_mode(::moritz::Lexer* me);
inline int Lexer_mode_id(::moritz::Lexer* me);
inline const char* Lexer_mode_name(::moritz::Lexer* me);


inline Lexer_Mode* Lexer_map_mode_id_to_mode(::moritz::Lexer* me,
                                                              const int ModeID);
inline int Lexer_map_mode_to_mode_id(const ::moritz::Lexer* me,
                                                              const Lexer_Mode* Mode);


inline void Lexer_set_mode_brutally_by_id(::moritz::Lexer* me,
                                                           const int LexerMode);
inline void Lexer_set_mode_brutally(::moritz::Lexer* me,
                                                     Lexer_Mode* Mode);
inline void Lexer_enter_mode(::moritz::Lexer* me,
                                                             Lexer_Mode* TargetMode);


inline void Lexer_pop_mode(::moritz::Lexer* me);
inline void Lexer_pop_drop_mode(::moritz::Lexer* me);
inline void Lexer_push_mode(::moritz::Lexer* me, Lexer_Mode* new_mode);

}
namespace moritz {
    inline uint32_t
    Lexer_receive(::moritz::Lexer* me);





}







namespace moritz {
}

       
namespace moritz {
extern uint16_t Lexer_LexemeNullObject;
}






namespace moritz {


class Token;



extern const char* Token_map_id_to_name(const uint32_t);

inline void Token_construct(Token* __this);
inline void Token_destruct(Token* __this);
inline void Token_copy(Token* me, const Token* That);
inline bool Token_take_text(Token* __this,
                                          ::moritz::Lexer* analyzer,
                                          const uint16_t* Begin,
                                          const uint16_t* End);






class Token {
public:
    Token();
    Token(const Token& That);


    Token& operator=(const Token& That)
    { Token_copy(this, &That); return *this; }
    virtual ~Token();
    std::basic_string<uint16_t> text;
    size_t number;


public:
    std::basic_string<uint16_t> get_text() const { return text; }
    void set_text(std::basic_string<uint16_t>& Value) { text = Value; }
    size_t get_number() const { return number; }
    void set_number(size_t Value) { number = Value; }

    void set(const uint32_t ID) { _id = ID; }
    void set(const uint32_t ID, const std::basic_string<uint16_t>& Value0)
    { _id = ID; text = Value0; }
    void set(const uint32_t ID, const size_t& Value0)
    { _id = ID; number = Value0; }
    void set(const uint32_t ID, const std::basic_string<uint16_t>& Value0, const size_t& Value1)
    { _id = ID; text = Value0; number = Value1; }


    public:




        uint32_t _id;
        uint32_t type_id() const { return _id; }
        const char* map_id_to_name(uint32_t ID) const { return Token_map_id_to_name(ID); }
        const std::string type_id_name() const { return map_id_to_name(_id); }



    public:
        size_t _line_n;
        size_t line_number() const { return _line_n; }
        void set_line_number(const size_t Value) { _line_n = Value; }


    public:
        size_t _column_n;
        size_t column_number() const { return _column_n; }
        void set_column_number(const size_t Value) { _column_n = Value; }


    public:

        typedef std::basic_string<uint16_t> __string;

        operator
        const std::string() const
        { return get_string(); }

        const std::string
        get_string() const
        {
            std::string tmp;

            tmp = map_id_to_name((*this)._id);

            tmp += " '" + pretty_char_text() + "' ";

            return tmp;
        }

        const std::string
        pretty_char_text() const
        {
            std::string tmp = ::moritz:: unicode_to_char((*this).text);
            std::string::size_type pos = 0;

            while( (pos = tmp.find("\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\n");
            while( (pos = tmp.find("\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\t");
            while( (pos = tmp.find("\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\r");

            return tmp;
        }


        const std::wstring
        pretty_wchar_text() const
        {
            std::wstring tmp = ::moritz:: unicode_to_wchar((*this).text);
            std::wstring::size_type pos = 0;

            while( (pos = tmp.find(L"\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\n");
            while( (pos = tmp.find(L"\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\t");
            while( (pos = tmp.find(L"\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\r");

            return tmp;
        }



    private:
        friend void Token_copy(Token* me, const Token* That);
        friend bool Token_take_text(Token* __this,
                                               ::moritz::Lexer* analyzer,
                                               const uint16_t* Begin,
                                               const uint16_t* End);
};

}

        namespace moritz {

        inline std::ostream&
        operator<<(std::ostream& ostr, const Token& Tok)
        { ostr << std::string(Tok); return ostr; }
        }





namespace moritz {




inline void
utf8_to_utf8_character(const uint8_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf8_to_utf16_character(const uint8_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf8_to_utf32_character(const uint8_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf8_to_char_character(const uint8_t** input_pp,
                                           char** output_pp);

inline void
utf8_to_wchar_character(const uint8_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf8_to_utf8(const uint8_t** source_pp,
                                             const uint8_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf8_to_utf16(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf8_to_utf32(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf8_to_char(const uint8_t** source_pp,
                                             const uint8_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf8_to_wchar(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf8_to_utf8(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<uint16_t>
    utf8_to_utf16(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<uint32_t>
    utf8_to_utf32(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<char>
    utf8_to_char(const std::basic_string<uint8_t>& Source);

    inline std::basic_string<wchar_t>
    utf8_to_wchar(const std::basic_string<uint8_t>& Source);

}




namespace moritz {



inline void

utf8_to_utf8_character(const uint8_t** input_pp, uint8_t** output_pp)
{

    if( (**input_pp & (uint8_t)0x80) == (uint8_t)0 ) {
        *((*output_pp)++) = *(*input_pp)++;
    }
    else if( **input_pp < (uint8_t)0xE0 ) {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
    else if( **input_pp < (uint8_t)0xF0 ) {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
    else {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
}

inline void

utf8_to_utf16_character(const uint8_t** input_pp, uint16_t** output_pp)
{
    const uint8_t* iterator = *input_pp;
    uint32_t tmp = 0;

    if( (*iterator & (uint8_t)0x80) == (uint8_t)0 ) {

        **output_pp = (uint16_t)*(iterator++);

        ++(*output_pp);
    }
    else if( *iterator < (uint8_t)0xE0 ) {


        **output_pp = (uint16_t)(( ((uint16_t)*(iterator++)) & (uint16_t)0x1F ) << 6);
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F )));

        ++(*output_pp);
    }
    else if( *iterator < (uint8_t)0xF0 ) {


        **output_pp = (uint16_t)(( ((uint16_t)*(iterator++)) & (uint16_t)0x0F ) << 12);
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F ) << 6));
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F )));

        ++(*output_pp);
    }
    else {
        tmp = (uint32_t)( (((uint32_t)*(iterator++)) & (uint32_t)0x07 ) << 18);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 12);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ));

        tmp = (uint32_t)(tmp - (uint32_t)0x10000);
        *((*output_pp)++) = (uint16_t)((tmp >> 10) | (uint32_t)0xD800);
        *((*output_pp)++) = (uint16_t)((tmp & (uint32_t)0x3FF) | (uint32_t)0xDC00);
    }
    *input_pp = iterator;
}

inline void

utf8_to_utf32_character(const uint8_t** input_pp, uint32_t** output_pp)
{
    const uint8_t* iterator = *input_pp;

    if( (*iterator & (uint8_t)0x80) == (uint8_t)0 ) {

        **output_pp = (uint32_t)*(iterator++);
    }
    else if( *iterator < (uint8_t)0xE0 ) {


        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x1F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    else if( *iterator < (uint8_t)0xF0 ) {


        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x0F ) << 12);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    else {






        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x07 ) << 18);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 12);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    ++(*output_pp);
    *input_pp = iterator;
}




inline void
utf8_to_char_character(const uint8_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::moritz:: utf8_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::moritz:: utf8_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::moritz:: utf8_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf8_to_wchar_character(const uint8_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::moritz:: utf8_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::moritz:: utf8_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::moritz:: utf8_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf8_to_utf8(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf8_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf8_to_utf8(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf8_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_utf16(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::moritz:: utf8_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf8_to_utf16(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf8_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_utf32(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::moritz:: utf8_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf8_to_utf32(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf8_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_char(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint8_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf8_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf8_to_char(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf8_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf8_to_wchar(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint8_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf8_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf8_to_wchar(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf8_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace moritz {




inline void
utf16_to_utf8_character(const uint16_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf16_to_utf16_character(const uint16_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf16_to_utf32_character(const uint16_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf16_to_char_character(const uint16_t** input_pp,
                                           char** output_pp);

inline void
utf16_to_wchar_character(const uint16_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf16_to_utf8(const uint16_t** source_pp,
                                             const uint16_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf16_to_utf16(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf16_to_utf32(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf16_to_char(const uint16_t** source_pp,
                                             const uint16_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf16_to_wchar(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf16_to_utf8(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<uint16_t>
    utf16_to_utf16(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<uint32_t>
    utf16_to_utf32(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<char>
    utf16_to_char(const std::basic_string<uint16_t>& Source);

    inline std::basic_string<wchar_t>
    utf16_to_wchar(const std::basic_string<uint16_t>& Source);

}






namespace moritz {

inline void
utf16_to_utf8_character(const uint16_t** input_pp, uint8_t** output_pp)
{
    uint32_t x0 = (uint16_t)0;
    uint32_t x1 = (uint16_t)0;
    uint32_t unicode = (uint32_t)0;

    if ( **input_pp <= (uint16_t)0x7f ) {
        *((*output_pp)++) = (uint8_t)*(*input_pp);
        ++(*input_pp);

    } else if ( **input_pp <= (uint16_t)0x7ff ) {
        *((*output_pp)++) = (uint8_t)(0xC0 | (*(*input_pp) >> 6));
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0x3F));
        ++(*input_pp);

    } else if ( **input_pp < (uint16_t)0xD800 ) {
        *((*output_pp)++) = (uint8_t)(0xE0 | *(*input_pp) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0x3F));
        ++(*input_pp);

    } else if ( **input_pp < (uint16_t)0xE000 ) {

        x0 = (uint32_t)(*(*input_pp)++ - (uint32_t)0xD800);
        x1 = (uint32_t)(*(*input_pp)++ - (uint32_t)0xDC00);
        unicode = (x0 << 10) + x1 + 0x10000;


        ((unicode <= (uint16_t)0x1FFFFF) ? static_cast<void> (0) : __assert_fail ("unicode <= (uint16_t)0x1FFFFF", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/from-utf16.i", 79, __PRETTY_FUNCTION__));

        *((*output_pp)++) = (uint8_t)(0xF0 | unicode >> 18);
        *((*output_pp)++) = (uint8_t)(0x80 | (unicode & (uint32_t)0x3FFFF) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (unicode & (uint32_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (unicode & (uint32_t)0x3F));

    } else {

        *((*output_pp)++) = (uint8_t)(0xE0 | *(*input_pp) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0x3F));
        ++(*input_pp);
    }
}

inline void
utf16_to_utf16_character(const uint16_t** input_pp,
                                      uint16_t** output_pp)
{
    if( **input_pp < (uint16_t)0xD800 || **input_pp >= (uint16_t)0xE000 ) {
        *((*output_pp)++) = *(*input_pp)++;
    } else {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
}

inline void
utf16_to_utf32_character(const uint16_t** input_pp,
                                      uint32_t** output_pp)
{
    uint32_t x0 = (uint32_t)0;
    uint32_t x1 = (uint32_t)0;

    if( **input_pp < (uint16_t)0xD800 || **input_pp >= (uint16_t)0xE000 ) {
        *((*output_pp)++) = *(*input_pp)++;
    } else {
        x0 = (uint32_t)(*(*input_pp)++) - (uint32_t)0xD800;
        x1 = (uint32_t)(*(*input_pp)++) - (uint32_t)0xDC00;
        *((*output_pp)++) = (x0 << 10) + x1 + (uint32_t)0x10000;
    }
}



inline void
utf16_to_char_character(const uint16_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::moritz:: utf16_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::moritz:: utf16_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::moritz:: utf16_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf16_to_wchar_character(const uint16_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::moritz:: utf16_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::moritz:: utf16_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::moritz:: utf16_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf16_to_utf8(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf16_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf16_to_utf8(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf16_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf16_to_utf16(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::moritz:: utf16_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf16_to_utf16(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf16_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf16_to_utf32(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::moritz:: utf16_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf16_to_utf32(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf16_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf16_to_char(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint16_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf16_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf16_to_char(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf16_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf16_to_wchar(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint16_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf16_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf16_to_wchar(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf16_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace moritz {




inline void
utf32_to_utf8_character(const uint32_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf32_to_utf16_character(const uint32_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf32_to_utf32_character(const uint32_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf32_to_char_character(const uint32_t** input_pp,
                                           char** output_pp);

inline void
utf32_to_wchar_character(const uint32_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf32_to_utf8(const uint32_t** source_pp,
                                             const uint32_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf32_to_utf16(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf32_to_utf32(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf32_to_char(const uint32_t** source_pp,
                                             const uint32_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf32_to_wchar(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf32_to_utf8(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<uint16_t>
    utf32_to_utf16(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<uint32_t>
    utf32_to_utf32(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<char>
    utf32_to_char(const std::basic_string<uint32_t>& Source);

    inline std::basic_string<wchar_t>
    utf32_to_wchar(const std::basic_string<uint32_t>& Source);

}




namespace moritz {



inline void
utf32_to_utf8_character(const uint32_t** input_pp,
                                     uint8_t** output_pp)
{
    uint32_t Unicode = **input_pp;


    if (Unicode <= 0x0000007f) {
        *((*output_pp)++) = (uint8_t)Unicode;
    } else if (Unicode <= 0x000007ff) {
        *((*output_pp)++) = (uint8_t)(0xC0 | (Unicode >> 6));
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3f));
    } else if (Unicode <= 0x0000ffff) {
        *((*output_pp)++) = (uint8_t)(0xE0 | Unicode >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3F));
    } else {

        ((Unicode <= (uint32_t)0x1FFFFF) ? static_cast<void> (0) : __assert_fail ("Unicode <= (uint32_t)0x1FFFFF", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/from-utf32.i", 78, __PRETTY_FUNCTION__));

        ((! (Unicode >= 0xd800 && Unicode <= 0xdfff)) ? static_cast<void> (0) : __assert_fail ("! (Unicode >= 0xd800 && Unicode <= 0xdfff)", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/from-utf32.i", 80, __PRETTY_FUNCTION__));

        *((*output_pp)++) = (uint8_t)(0xF0 | Unicode >> 18);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3FFFF) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3F));
    }


    ++(*input_pp);
}

inline void
utf32_to_utf16_character(const uint32_t** input_pp,
                                    uint16_t** output_pp)
{
    uint32_t tmp = 0;

    if( **input_pp < 0x10000 ) {
        *((*output_pp)++) = (uint16_t)**input_pp;
    } else {
        tmp = (uint32_t)(**input_pp - (uint32_t)0x10000);

        *(((*output_pp)++)) = (uint16_t)((tmp >> 10) | (uint16_t)0xD800);
        *(((*output_pp)++)) = (uint16_t)((tmp & (uint32_t)0x3FF) | (uint16_t)0xDC00);
    }
    ++(*input_pp);
}

inline void
utf32_to_utf32_character(const uint32_t** input_pp,
                                    uint32_t** output_pp)
{
    *((*output_pp)++) = (uint32_t)(*(*input_pp)++);
}



inline void
utf32_to_char_character(const uint32_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::moritz:: utf32_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::moritz:: utf32_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::moritz:: utf32_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf32_to_wchar_character(const uint32_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::moritz:: utf32_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::moritz:: utf32_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::moritz:: utf32_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf32_to_utf8(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf32_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf32_to_utf8(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf32_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf32_to_utf16(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::moritz:: utf32_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf32_to_utf16(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf32_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf32_to_utf32(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::moritz:: utf32_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf32_to_utf32(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf32_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf32_to_char(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint32_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf32_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf32_to_char(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf32_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf32_to_wchar(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint32_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: utf32_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf32_to_wchar(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: utf32_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}

namespace moritz {


inline void
unicode_to_utf8_character(const uint16_t** input_pp,
                                       uint8_t** output_pp)
{
    switch( sizeof(uint16_t) )
    {
    case 1: ::moritz:: utf8_to_utf8_character((const uint8_t**)input_pp, output_pp); break;
    case 2: ::moritz:: utf16_to_utf8_character((const uint16_t**)input_pp, output_pp); break;
    case 4: ::moritz:: utf32_to_utf8_character((const uint32_t**)input_pp, output_pp); break;
    default: do { throw std::runtime_error("Cannot derive converter for given element size."); } while(0);
    }
}

inline void
unicode_to_utf16_character(const uint16_t** input_pp,
                                        uint16_t** output_pp)
{
    switch( sizeof(uint16_t) )
    {
    case 1: ::moritz:: utf8_to_utf16_character((const uint8_t**)input_pp, output_pp); break;
    case 2: ::moritz:: utf16_to_utf16_character((const uint16_t**)input_pp, output_pp); break;
    case 4: ::moritz:: utf32_to_utf16_character((const uint32_t**)input_pp, output_pp); break;
    default: do { throw std::runtime_error("Cannot derive converter for given element size."); } while(0);
    }
}

inline void
unicode_to_utf32_character(const uint16_t** input_pp,
                                        uint32_t** output_pp)
{
    switch( sizeof(uint16_t) )
    {
    case 1: ::moritz:: utf8_to_utf32_character((const uint8_t**)input_pp, output_pp); break;
    case 2: ::moritz:: utf16_to_utf32_character((const uint16_t**)input_pp, output_pp); break;
    case 4: ::moritz:: utf32_to_utf32_character((const uint32_t**)input_pp, output_pp); break;
    default: do { throw std::runtime_error("Cannot derive converter for given element size."); } while(0);
    }
}






inline void
unicode_to_char_character(const uint16_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::moritz:: unicode_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::moritz:: unicode_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::moritz:: unicode_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    unicode_to_wchar_character(const uint16_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::moritz:: unicode_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::moritz:: unicode_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::moritz:: unicode_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
unicode_to_utf8(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: unicode_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
unicode_to_utf8(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: unicode_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
unicode_to_utf16(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::moritz:: unicode_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
unicode_to_utf16(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: unicode_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
unicode_to_utf32(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::moritz:: unicode_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
unicode_to_utf32(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: unicode_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
unicode_to_char(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint16_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: unicode_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
unicode_to_char(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: unicode_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
unicode_to_wchar(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint16_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::moritz:: unicode_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
unicode_to_wchar(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::moritz:: unicode_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace moritz {
extern uint16_t Lexer_LexemeNullObject;
}


namespace moritz {


inline
Token::Token()
{



}

inline
Token::Token(const Token& Other)
{
   Token_copy(this, &Other);



}

inline
Token::~Token()
{



}

inline void
Token_construct(Token* __this)
{

    new ((void*)__this) Token;
}

inline void
Token_destruct(Token* __this)
{
    __this->Token::~Token();
}

inline void
Token_copy(Token* __this, const Token* __That)
{


    (void)__this;
    (void)__That;

        (*__this)._id = (*__That)._id;
        (*__this).text = (*__That).text;
        (*__this).number = (*__That).number;


        (*__this)._line_n = (*__That)._line_n;
        (*__this)._column_n = (*__That)._column_n;





   ((__this->_id == __That->_id) ? static_cast<void> (0) : __assert_fail ("__this->_id == __That->_id", "moritz_Lexer-token", 285, __PRETTY_FUNCTION__));


    ((__this->_line_n == __That->_line_n) ? static_cast<void> (0) : __assert_fail ("__this->_line_n == __That->_line_n", "moritz_Lexer-token", 288, __PRETTY_FUNCTION__));
    ((__this->_column_n == __That->_column_n) ? static_cast<void> (0) : __assert_fail ("__this->_column_n == __That->_column_n", "moritz_Lexer-token", 289, __PRETTY_FUNCTION__));


}

inline bool
Token_take_text(Token* __this,
                           ::moritz::Lexer* __analyzer,
                           const uint16_t* Begin,
                           const uint16_t* End)
{


    (void)__this;
    (void)__analyzer;
        (*__this).text.assign(Begin, End-Begin);
        return false;



}
}

const uint32_t MORITZ_TKN_ADVERB____ = ((uint32_t)10000);
const uint32_t MORITZ_TKN_ARTICLE___ = ((uint32_t)10001);
const uint32_t MORITZ_TKN_DEDENT = ((uint32_t)3);
const uint32_t MORITZ_TKN_FILL_WORD_ = ((uint32_t)10002);
const uint32_t MORITZ_TKN_INDENT = ((uint32_t)2);
const uint32_t MORITZ_TKN_MARK______ = ((uint32_t)10003);
const uint32_t MORITZ_TKN_ME________ = ((uint32_t)10004);
const uint32_t MORITZ_TKN_MY_BROTHER = ((uint32_t)10005);
const uint32_t MORITZ_TKN_NEGATION__ = ((uint32_t)10006);
const uint32_t MORITZ_TKN_NODENT = ((uint32_t)4);
const uint32_t MORITZ_TKN_OK = ((uint32_t)10007);
const uint32_t MORITZ_TKN_PREDICATE_ = ((uint32_t)10008);
const uint32_t MORITZ_TKN_SCALLYWAG_ = ((uint32_t)10009);
const uint32_t MORITZ_TKN_SUBJECT___ = ((uint32_t)10010);
const uint32_t MORITZ_TKN_TERMINATION = ((uint32_t)0);
const uint32_t MORITZ_TKN_UKNOWN____ = ((uint32_t)10011);
const uint32_t MORITZ_TKN_UNINITIALIZED = ((uint32_t)1);
const uint32_t MORITZ_TKN_VERB______ = ((uint32_t)10012);


namespace moritz {
extern const char* Token_map_id_to_name(const uint32_t TokenID);
}

namespace moritz {

enum {
    Lexer_ModeID_NORMAL = 0,
    Lexer_ModeID_HAPPY = 1
};

        extern Lexer_Mode Lexer_NORMAL;
        extern Lexer_Mode Lexer_HAPPY;


extern uint32_t Lexer_NORMAL_analyzer_function(::moritz::Lexer*);

extern bool Lexer_NORMAL_has_base(const Lexer_Mode*);
extern bool Lexer_NORMAL_has_entry_from(const Lexer_Mode*);
extern bool Lexer_NORMAL_has_exit_to(const Lexer_Mode*);

extern uint32_t Lexer_HAPPY_analyzer_function(::moritz::Lexer*);
extern void Lexer_HAPPY_on_entry(::moritz::Lexer*, const Lexer_Mode*);

extern bool Lexer_HAPPY_has_base(const Lexer_Mode*);
extern bool Lexer_HAPPY_has_entry_from(const Lexer_Mode*);
extern bool Lexer_HAPPY_has_exit_to(const Lexer_Mode*);




typedef struct Lexer_Memento_tag {




        Lexer_Buffer buffer;

        struct Lexer_Mode_tag* __current_mode_p;
        Lexer_AnalyzerFunctionP current_analyzer_function;



        Lexer_AnalyzerFunctionP DEBUG_analyzer_function_at_entry;



        Lexer_Counter counter;



        Lexer_Accumulator accumulator;







        struct Lexer_Memento_tag* _parent_memento;


        FILE* __file_handle_allocated_by_constructor;

    Lexer_Memento_tag() {}
    ~Lexer_Memento_tag() {}




} Lexer_Memento;

}


namespace moritz {

class Lexer {
public:
        ::moritz::Token* token;

            ::moritz::Token __memory_token;




        Lexer_Buffer buffer;







        Lexer_AnalyzerFunctionP DEBUG_analyzer_function_at_entry;





        Lexer_AnalyzerFunctionP current_analyzer_function;
        struct Lexer_Mode_tag* __current_mode_p;







        struct Lexer_Mode_tag* mode_db[(2)];

        struct {
            struct Lexer_Mode_tag* (begin[(size_t)8]);
            struct Lexer_Mode_tag** end;
            struct Lexer_Mode_tag** memory_end;
        } _mode_stack;
        Lexer_Counter counter;
        Lexer_Accumulator accumulator;
        struct Lexer_Memento_tag* _parent_memento;
        FILE* __file_handle_allocated_by_constructor;

                   Lexer(const Lexer&);
public:
    typedef ::moritz::Token token_type;
    typedef uint32_t token_id_type;
    typedef uint16_t char_type;

    Lexer(uint16_t* BufferMemoryBegin, size_t BufferMemorySize,
          uint16_t* BufferEndOfContentP = 0x0,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);
    Lexer(const std::string& Filename,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);
    Lexer(std::istream* p_input_stream,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);

    Lexer(std::wistream* p_input_stream,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);

    Lexer(std::FILE* input_fh,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);







    virtual ~Lexer();


    void* buffer_fill_region_append(void* ContentBegin,
                                                    void* ContentEnd);
    void* buffer_fill_region_append_conversion(void* ContentBegin,
                                                               void* ContentEnd);
    void* buffer_fill_region_append_conversion_direct(void* ContentBegin,
                                                                      void* ContentEnd);
    void buffer_fill_region_prepare();
    uint16_t* buffer_fill_region_begin();
    uint16_t* buffer_fill_region_end();
    size_t buffer_fill_region_size();
    void buffer_fill_region_finish(const size_t LoadedN);
    void buffer_conversion_fill_region_prepare();
    uint8_t* buffer_conversion_fill_region_begin();
    uint8_t* buffer_conversion_fill_region_end();
    size_t buffer_conversion_fill_region_size();
    void buffer_conversion_fill_region_finish(const size_t ByteN);
    uint16_t* buffer_lexeme_start_pointer_get();
    void buffer_input_pointer_set(uint16_t*);


    bool byte_order_reversion();
    void byte_order_reversion_set(bool Value);
    uint32_t receive();
    ::moritz::Token* token_p();
    Lexer_Mode& mode();
    int mode_id() const;
    const char* mode_name() const;


    void set_mode_brutally(const int LexerMode);
    void set_mode_brutally(const Lexer_Mode& Mode);

    void operator<<(const int MODE_ID);
    void operator<<( Lexer_Mode& Mode);

    void pop_mode();
    void pop_drop_mode();
    void push_mode(Lexer_Mode& new_mode);

    void enter_mode( Lexer_Mode& TargetMode);


    Lexer_Mode& map_mode_id_to_mode(const int ModeID);
    int map_mode_to_mode_id(const Lexer_Mode& Mode) const;


    void send(const uint32_t TokenID)
    { (void)TokenID; do { throw std::runtime_error("Member functions .send()" " has been deprecated\n" "Please, use " "macros: self_send*()" "."); } while(0); }


    size_t line_number() const { return line_number_at_begin(); }
    size_t line_number_at_begin() const { return counter._line_number_at_begin; }
    size_t line_number_at_end() const { return counter._line_number_at_end; }

    void line_number_set(size_t Y) { counter._line_number_at_end = Y; }


    size_t column_number() const { return column_number_at_begin(); }
    size_t column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t column_number_at_end() const { return counter._column_number_at_end; }

    void column_number_set(size_t X) { counter._column_number_at_end = X; }






    const char* version() const;


    size_t tell();
    void seek(const size_t);
    void seek_forward(const size_t);
    void seek_backward(const size_t);

    void undo();
    void undo(size_t DeltaN_Backward);

    void move_forward(const size_t) { do { throw std::runtime_error("'move_forward()' has been renamed to 'seek_forward()'."); } while(0); }
    void move_backward(const size_t){ do { throw std::runtime_error("'move_backward()' has been renamed to 'seek_backward()'."); } while(0); }

public:

    void set_callback_on_buffer_content_change(void (*callback)(uint16_t*,
                                                                       uint16_t*));

    template <class InputHandleT> void reset(InputHandleT* input_handle,
                                             const char* CharacterEncodingName = 0x0);
    void reset(const char* CharacterEncodingName = 0x0)
    { reset<void>((void*)0x0, CharacterEncodingName); }

    uint16_t* reset_buffer(uint16_t* BufferMemoryBegin,
                                                    size_t BufferMemorySize,
                                                    uint16_t* BufferEndOfContentP,
                                                    const char* CharacterEncodingName = 0x0);


public:
    template<class InputHandleT> void include_push(uint16_t* InputName,
                                                    const Lexer_Mode* Mode = 0x0,
                                                    const char* IANA_CodingName = 0x0);
    template<class InputHandleT> void include_push(InputHandleT* sh,
                                                    const Lexer_Mode* Mode = 0x0,
                                                    const char* IANA_CodingName = 0x0);
    bool include_pop();

protected:
    void include_stack_delete();

private:


public:
    void print_this();

private:

    template <class InputHandleT> inline friend void
    Lexer_constructor_core(::moritz::Lexer* me,
                                InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                bool ByteOrderReversionF,
                                uint16_t* BufferMemory,
                                size_t BufferMemorySize);

    template<class InputHandleT> friend Lexer_Memento*
    Lexer_memento_pack(::moritz::Lexer*, uint16_t*,
                            InputHandleT**);
    friend void
    Lexer_memento_unpack(::moritz::Lexer*, Lexer_Memento*);

    template<class InputHandleT> friend void
    Lexer_reset(::moritz::Lexer*, InputHandleT*, const char*);


    friend uint32_t Lexer_NORMAL_analyzer_function(::moritz::Lexer*);

    friend bool Lexer_NORMAL_has_base(const Lexer_Mode*);
    friend bool Lexer_NORMAL_has_entry_from(const Lexer_Mode*);
    friend bool Lexer_NORMAL_has_exit_to(const Lexer_Mode*);

    friend uint32_t Lexer_HAPPY_analyzer_function(::moritz::Lexer*);
    friend void Lexer_HAPPY_on_entry(::moritz::Lexer*, const Lexer_Mode*);

    friend bool Lexer_HAPPY_has_base(const Lexer_Mode*);
    friend bool Lexer_HAPPY_has_entry_from(const Lexer_Mode*);
    friend bool Lexer_HAPPY_has_exit_to(const Lexer_Mode*);




public:






public:

    void get_token()
    { do { throw std::runtime_error("Member functions .get_token()" " has been deprecated\n" "Please, use " ".receive(...)" "."); } while(0); }
    void get_token(::moritz::Token* result_p) { (void)result_p; get_token(); }
    void get_token(::moritz::Token** result_pp) { (void)result_pp; get_token(); }
};

}


namespace moritz {


template <class InputHandleT> inline

void
Lexer_constructor_core(::moritz::Lexer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            bool ByteOrderReversionF,
                            uint16_t* BufferMemory,
                            size_t BufferMemorySize,
                            uint16_t* BufferEndOfFileP)
{
    ((Lexer_ModeID_NORMAL < 2) ? static_cast<void> (0) : __assert_fail ("Lexer_ModeID_NORMAL < 2", "moritz_Lexer", 382, __PRETTY_FUNCTION__));
    ((Lexer_ModeID_HAPPY < 2) ? static_cast<void> (0) : __assert_fail ("Lexer_ModeID_HAPPY < 2", "moritz_Lexer", 383, __PRETTY_FUNCTION__));

     Lexer_NORMAL.id = Lexer_ModeID_NORMAL;
     Lexer_NORMAL.name = "NORMAL";
     Lexer_NORMAL.analyzer_function = Lexer_NORMAL_analyzer_function;




     Lexer_NORMAL.on_entry = Lexer_Mode_on_entry_exit_null_function;
     Lexer_NORMAL.on_exit = Lexer_Mode_on_entry_exit_null_function;

     Lexer_NORMAL.has_base = Lexer_NORMAL_has_base;
     Lexer_NORMAL.has_entry_from = Lexer_NORMAL_has_entry_from;
     Lexer_NORMAL.has_exit_to = Lexer_NORMAL_has_exit_to;


     Lexer_HAPPY.id = Lexer_ModeID_HAPPY;
     Lexer_HAPPY.name = "HAPPY";
     Lexer_HAPPY.analyzer_function = Lexer_HAPPY_analyzer_function;




     Lexer_HAPPY.on_entry = Lexer_HAPPY_on_entry;
     Lexer_HAPPY.on_exit = Lexer_Mode_on_entry_exit_null_function;

     Lexer_HAPPY.has_base = Lexer_HAPPY_has_base;
     Lexer_HAPPY.has_entry_from = Lexer_HAPPY_has_entry_from;
     Lexer_HAPPY.has_exit_to = Lexer_HAPPY_has_exit_to;

        me->mode_db[Lexer_ModeID_NORMAL] = &(Lexer_NORMAL);
        me->mode_db[Lexer_ModeID_HAPPY] = &(Lexer_HAPPY);


    Lexer_construct_basic(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName,
                               ((size_t)65536),
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));






}





template <class InputHandleT> inline

Lexer_Memento*
Lexer_memento_pack(::moritz::Lexer* me,
                        uint16_t* InputName,
                        InputHandleT** input_handle)
{

    Lexer_Memento* memento = Lexer_MemoryManager_Memento_allocate();

    (void)InputName;
    (void)input_handle;




    new ((void*)memento) Lexer_Memento;


    memento->_parent_memento = (*me)._parent_memento;
    memento->buffer = (*me).buffer;
    memento->__current_mode_p = (*me).__current_mode_p;
    memento->current_analyzer_function = (*me).current_analyzer_function;


    memento->DEBUG_analyzer_function_at_entry = (*me).DEBUG_analyzer_function_at_entry;

    memento->counter = (*me).counter;

    memento->accumulator = (*me).accumulator;

    memento->__file_handle_allocated_by_constructor = (*me).__file_handle_allocated_by_constructor;
    return memento;

}


inline

void
Lexer_memento_unpack(::moritz::Lexer* me,
                          Lexer_Memento* memento)
{

    (*me)._parent_memento = memento->_parent_memento;
    (*me).buffer = memento->buffer;
    (*me).__current_mode_p = memento->__current_mode_p;
    (*me).current_analyzer_function = memento->current_analyzer_function;


    (*me).DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;

    (*me).counter = memento->counter;

    (*me).accumulator = memento->accumulator;

    (*me).__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;
    memento->~Lexer_Memento_tag();


    Lexer_MemoryManager_Memento_free(memento);

}


}




namespace moritz {

inline size_t
Lexer_strlen(const uint16_t* Str)
{
    const uint16_t* iterator = Str;
    while( *iterator != 0 ) ++iterator;
    return (size_t)(iterator - Str);
}

inline size_t
Lexer_strcmp(const uint16_t* it0,
                  const uint16_t* it1)
{
    for(; *it0 == *it1; ++it0, ++it1) {


        if( *it0 == 0 ) return 0;
    }
    return (size_t)(*it0) - (size_t)(*it1);
}

}

namespace moritz {

inline uint16_t*
Lexer_access_Lexeme(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( *(buffer->_input_p) != (uint16_t)0 ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Tried to access lexeme while terminating zero was not set.\n" "This happens, for example, if navigation commands (undo, seek,\n" "seek_forward, or seek_backward) are used **before** accessing\n" "the lexeme via 'Lexeme' or 'LexemeBegin'.\n"); } while(0); };
    return buffer->_lexeme_start_p;
}

inline uint16_t*
Lexer_access_LexemeBegin(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return buffer->_lexeme_start_p;
}

inline size_t
Lexer_access_LexemeL(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return (size_t)(buffer->_input_p - buffer->_lexeme_start_p);
}

inline uint16_t*
Lexer_access_LexemeEnd(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return buffer->_input_p;
}

}




namespace moritz {
    inline uint32_t
    Lexer_receive(::moritz::Lexer* me)
    {
        register uint32_t __self_result_token_id = (uint32_t)-1;
        ((me->token != 0x0) ? static_cast<void> (0) : __assert_fail ("me->token != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/token-receiving.i", 103, __PRETTY_FUNCTION__));
        me->token->_id = ((uint32_t)MORITZ_TKN_UNINITIALIZED);
        do {
            __self_result_token_id = me->current_analyzer_function(me);



            if( __self_result_token_id != me->token->_id ) {
                __self_result_token_id = me->token->_id;
            }

        } while( __self_result_token_id == ((uint32_t)MORITZ_TKN_UNINITIALIZED) );
        return __self_result_token_id;
    }







       inline uint32_t Lexer::receive()
       { return Lexer_receive(this); }





}
namespace moritz {

    inline Lexer_Mode*
    Lexer_get_mode(::moritz::Lexer* me)
    { return me->__current_mode_p; }

    inline int
    Lexer_get_mode_id(const ::moritz::Lexer* me)
    { return me->__current_mode_p->id; }

    inline const char*
    Lexer_get_mode_name(const ::moritz::Lexer* me)
    { return me->__current_mode_p->name; }

    inline void
    Lexer_set_mode_brutally(::moritz::Lexer* me, Lexer_Mode* ModeP)
    {
        me->__current_mode_p = ModeP;
        me->current_analyzer_function = ModeP->analyzer_function;
    }

    inline void
    Lexer_set_mode_brutally_by_id(::moritz::Lexer* me, const int ModeID)
    { Lexer_set_mode_brutally(me, me->mode_db[ModeID]); }

    inline void
    Lexer_enter_mode(::moritz::Lexer* me, Lexer_Mode* TargetMode)
    {

        Lexer_Mode* SourceMode = me->__current_mode_p;






        Lexer_set_mode_brutally(me, TargetMode);


        TargetMode->on_entry(me, SourceMode);

    }

    inline Lexer_Mode*
    Lexer_map_mode_id_to_mode(::moritz::Lexer* me, const int ModeID)
    {
        ((ModeID >= 0) ? static_cast<void> (0) : __assert_fail ("ModeID >= 0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 65, __PRETTY_FUNCTION__));
        ((ModeID < (2)) ? static_cast<void> (0) : __assert_fail ("ModeID < (2)", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 66, __PRETTY_FUNCTION__));
        return me->mode_db[ModeID];
    }

    inline int
    Lexer_map_mode_to_mode_id(const ::moritz::Lexer* me, const Lexer_Mode* Mode)
    { (void)me; return Mode->id; }

    inline void
    Lexer_pop_mode(::moritz::Lexer* me)
    {
        ((me->_mode_stack.end != me->_mode_stack.begin) ? static_cast<void> (0) : __assert_fail ("me->_mode_stack.end != me->_mode_stack.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 77, __PRETTY_FUNCTION__));
        --(me->_mode_stack.end);
        Lexer_enter_mode(me, *me->_mode_stack.end);
    }

    inline void
    Lexer_pop_drop_mode(::moritz::Lexer* me)
    {
        ((me->_mode_stack.end != me->_mode_stack.begin) ? static_cast<void> (0) : __assert_fail ("me->_mode_stack.end != me->_mode_stack.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 85, __PRETTY_FUNCTION__));
        --(me->_mode_stack.end);

    }

    inline void
    Lexer_push_mode(::moritz::Lexer* me, Lexer_Mode* new_mode)
    {

        if( me->_mode_stack.end == me->_mode_stack.memory_end )
            do { throw std::runtime_error("Error: Mode stack overflow. Adapt size of mode stack via the macro\n" "Error: QUEX_SETTING_MODE_STACK_SIZE, or review mode transitions.\n" "Error: I.e. check that for every GOSUB (push), there is a correspondent\n" "Error: GOUP (pop)."); } while(0);

        *me->_mode_stack.end = me->__current_mode_p;
        ++(me->_mode_stack.end);
        Lexer_enter_mode(me, new_mode);
    }


    inline Lexer_Mode&
    Lexer::mode()
    { return *Lexer_get_mode(this); }

    inline int
    Lexer::mode_id() const
    { return Lexer_get_mode_id(this); }

    inline const char*
    Lexer::mode_name() const
    { return Lexer_get_mode_name(this); }

    inline void
    Lexer::set_mode_brutally(const int ModeID)
    { Lexer_set_mode_brutally_by_id(this, ModeID); }

    inline void
    Lexer::set_mode_brutally(const Lexer_Mode& TheMode)
    { Lexer_set_mode_brutally(this, ((Lexer_Mode*)&TheMode)); }

    inline void
    Lexer::enter_mode( Lexer_Mode& TargetMode)
    { Lexer_enter_mode(this, &TargetMode); }

    inline Lexer_Mode&
    Lexer::map_mode_id_to_mode(const int ModeID)
    { return *(Lexer_map_mode_id_to_mode(this, ModeID)); }

    inline int
    Lexer::map_mode_to_mode_id(const Lexer_Mode& TheMode) const
    { return Lexer_map_mode_to_mode_id(this, &TheMode); }

    inline void
    Lexer::operator<<(const int ModeID)
    { enter_mode(*(Lexer_map_mode_id_to_mode(this, ModeID))); }

    inline void
    Lexer::operator<<( Lexer_Mode& TheMode)
    { enter_mode(TheMode); }

    inline void
    Lexer::pop_mode()
    { Lexer_pop_mode(this); }

    inline void
    Lexer::pop_drop_mode()
    { Lexer_pop_drop_mode(this); }

    inline void
    Lexer::push_mode(Lexer_Mode& new_mode)
    { Lexer_push_mode(this, &new_mode); }



}






namespace moritz {





    inline void
    QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(Lexer_Buffer* B)
    {
        (((B) != 0x0) ? static_cast<void> (0) : __assert_fail ("(B) != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 25, __PRETTY_FUNCTION__));
        if( (*B)._memory._front != 0x0 || (*B)._memory._back != 0x0 ) {
            (((*B)._memory._front < (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._front < (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 27, __PRETTY_FUNCTION__));
            ((*((*B)._memory._front) == ((uint16_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*((*B)._memory._front) == ((uint16_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 28, __PRETTY_FUNCTION__));
            (((*B)._input_p >= (*B)._memory._front) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p >= (*B)._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 29, __PRETTY_FUNCTION__));
            (((*B)._lexeme_start_p >= (*B)._memory._front) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p >= (*B)._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 30, __PRETTY_FUNCTION__));

            if( (*B)._memory._end_of_file_p == 0x0 ) {
                (((*B)._input_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 33, __PRETTY_FUNCTION__));
                (((*B)._lexeme_start_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 34, __PRETTY_FUNCTION__));
            } else {
                (((*B)._input_p <= (*B)._memory._end_of_file_p) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p <= (*B)._memory._end_of_file_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 36, __PRETTY_FUNCTION__));
                (((*B)._lexeme_start_p <= (*B)._memory._end_of_file_p) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p <= (*B)._memory._end_of_file_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 37, __PRETTY_FUNCTION__));

                (((*B)._memory._end_of_file_p >= (*B)._memory._front + 1) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._end_of_file_p >= (*B)._memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 39, __PRETTY_FUNCTION__));
                (((*B)._memory._end_of_file_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._end_of_file_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 40, __PRETTY_FUNCTION__));
            }
            (((*B)._content_character_index_begin <= (*B)._content_character_index_end) ? static_cast<void> (0) : __assert_fail ("(*B)._content_character_index_begin <= (*B)._content_character_index_end",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts"
            ,
 43
            , __PRETTY_FUNCTION__))
                                                                   ;
            if( ! ( (*B)._content_character_index_end == (size_t)0
                      && (*B)._content_character_index_begin == (size_t)0 ) ) {
                (((size_t)( (*B)._content_character_index_end - (*B)._content_character_index_begin) == (size_t)( Lexer_Buffer_text_end(B) - Lexer_Buffer_content_front(B))) ? static_cast<void> (0) : __assert_fail ("(size_t)( (*B)._content_character_index_end - (*B)._content_character_index_begin) == (size_t)( Lexer_Buffer_text_end(B) - Lexer_Buffer_content_front(B))",


 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts"
                ,


 49
                , __PRETTY_FUNCTION__))


                                                                                     ;
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_CONSISTENCY(Lexer_Buffer* B)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(B);





        if( (*B)._memory._front != 0 || (*B)._memory._back != 0x0 ) {
            ((*((*B)._memory._back) == ((uint16_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*((*B)._memory._back) == ((uint16_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 64, __PRETTY_FUNCTION__));
            if( (*B)._memory._end_of_file_p != 0x0 ) {
                ((*(*B)._memory._end_of_file_p == ((uint16_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*(*B)._memory._end_of_file_p == ((uint16_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 66, __PRETTY_FUNCTION__));
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(uint16_t* Begin,
                                            uint16_t* End)
    {
        uint16_t* iterator = 0x0;
        ((Begin <= End) ? static_cast<void> (0) : __assert_fail ("Begin <= End", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 76, __PRETTY_FUNCTION__));

        for(iterator = Begin; iterator != End; ++iterator) {
            if( *iterator != ((uint16_t)0x0) ) continue;

            if( iterator == Begin ) {
                do { throw std::runtime_error("Buffer limit code character appeared as first character in buffer.\n" "This is most probably a load failure.\n"); } while(0)
                                                                          ;
            } else {
                do { throw std::runtime_error("Buffer limit code character appeared as normal text content.\n"); } while(0);
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(const Lexer_Buffer* buffer)
    {
        uint16_t* End = buffer->_memory._back;

        if( buffer->_memory._front == 0x0 && buffer->_memory._back == 0x0 ) return;
        if( buffer->_memory._end_of_file_p != 0x0 ) End = buffer->_memory._end_of_file_p;
        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(buffer->_memory._front + 1, End);
    }

}


namespace moritz {

    inline size_t
    Lexer_BufferFillerUser_Plain_insert(Lexer_BufferFiller* me,
                                             uint16_t** insertion_p,
                                             uint16_t* BufferEnd,
                                             void* ContentBegin,
                                             void* ContentEnd)
    {
        size_t CopiedByteN = 0;

        (void)me;

        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE((uint16_t*)ContentBegin, (uint16_t*)ContentEnd);
        CopiedByteN = Lexer_MemoryManager_insert((uint8_t*)*insertion_p,
                                                      (uint8_t*)BufferEnd,
                                                      (uint8_t*)ContentBegin,
                                                      (uint8_t*)ContentEnd);

        *insertion_p += (CopiedByteN / sizeof(uint16_t));

        return CopiedByteN;
    }


    inline void*
    Lexer_buffer_fill_region_append_core(::moritz::Lexer* me,
                                              void* ContentBegin,
                                              void* ContentEnd,
                                              size_t (*insert)(Lexer_BufferFiller* me,
                                                               uint16_t** insertion_p,
                                                               uint16_t* BufferEnd,
                                                               void* ContentBegin,
                                                               void* ContentEnd))




    {
        uint16_t* insertion_p = 0x0;
        size_t CopiedByteN = 0;


        ((me->buffer._content_character_index_begin == 0) ? static_cast<void> (0) : __assert_fail ("me->buffer._content_character_index_begin == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 53, __PRETTY_FUNCTION__));
        ((me->buffer._memory._end_of_file_p != 0x0) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 54, __PRETTY_FUNCTION__));
        ((ContentEnd > ContentBegin) ? static_cast<void> (0) : __assert_fail ("ContentEnd > ContentBegin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 55, __PRETTY_FUNCTION__));
        QUEX_BUFFER_ASSERT_CONSISTENCY(&me->buffer);


        Lexer_Buffer_move_away_passed_content(&me->buffer);


        insertion_p = me->buffer._memory._end_of_file_p;

        CopiedByteN = insert(me->buffer.filler, &insertion_p,
                             me->buffer._memory._back + 1,
                             ContentBegin, ContentEnd);


        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p, insertion_p);


        Lexer_Buffer_end_of_file_set(&me->buffer, insertion_p);





        QUEX_BUFFER_ASSERT_CONSISTENCY(&me->buffer);
        return (uint8_t*)ContentBegin + CopiedByteN;
    }

    inline void*
    Lexer_buffer_fill_region_append(::moritz::Lexer* me,
                                         void* ContentBegin,
                                         void* ContentEnd)
    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Plain_insert);
    }

    inline void
    Lexer_buffer_fill_region_prepare(::moritz::Lexer* me)
    {

        Lexer_Buffer_move_away_passed_content(&me->buffer);
    }

    inline uint16_t*
    Lexer_buffer_fill_region_begin(::moritz::Lexer* me)
    {
        return Lexer_Buffer_text_end(&me->buffer);
    }

    inline uint16_t*
    Lexer_buffer_fill_region_end(::moritz::Lexer* me)
    {
        return Lexer_Buffer_content_back(&me->buffer) + 1;
    }

    inline size_t
    Lexer_buffer_fill_region_size(::moritz::Lexer* me)
    {
        ((Lexer_buffer_fill_region_end(me) >= Lexer_buffer_fill_region_begin(me)) ? static_cast<void> (0) : __assert_fail ("Lexer_buffer_fill_region_end(me) >= Lexer_buffer_fill_region_begin(me)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i"
        ,
 115
        , __PRETTY_FUNCTION__))
                                                                 ;

        return (size_t)( Lexer_buffer_fill_region_end(me)
                        - Lexer_buffer_fill_region_begin(me));
    }

    inline void
    Lexer_buffer_fill_region_finish(::moritz::Lexer* me,
                                         const size_t CharacterN)
    {
        ((me->buffer._memory._end_of_file_p != 0x0) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 125, __PRETTY_FUNCTION__));
        ((me->buffer._memory._end_of_file_p + CharacterN <= me->buffer._memory._back) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p + CharacterN <= me->buffer._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 126, __PRETTY_FUNCTION__));



        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p,
                                                 me->buffer._memory._end_of_file_p + CharacterN);

        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(me->buffer._memory._end_of_file_p,
                                                me->buffer._memory._end_of_file_p + CharacterN);


        Lexer_Buffer_end_of_file_set(&me->buffer,
                                          me->buffer._memory._end_of_file_p + CharacterN);
    }

    inline uint16_t*
    Lexer_buffer_lexeme_start_pointer_get(::moritz::Lexer* me)
    { return me->buffer._lexeme_start_p; }

    inline void
    Lexer_buffer_input_pointer_set(::moritz::Lexer* me, uint16_t* Adr)
    { me->buffer._input_p = Adr; }



    inline size_t
    Lexer_BufferFillerUser_Converter_insert(Lexer_BufferFiller* alter_ego,
                                                 uint16_t** insertion_p,
                                                 uint16_t* BufferEnd,
                                                 void* ContentBegin,
                                                 void* ContentEnd)



    {
        size_t CopiedByteN = 0;



        Lexer_BufferFiller_Converter<void>* me = (Lexer_BufferFiller_Converter<void>*)alter_ego;






        Lexer_BufferFiller_Converter_move_away_passed_content(me);

        CopiedByteN = Lexer_MemoryManager_insert(me->raw_buffer.end,
                                                      me->raw_buffer.memory_end,
                                                      (uint8_t*)ContentBegin,
                                                      (uint8_t*)ContentEnd);

        me->raw_buffer.end += CopiedByteN;




        me->converter->convert(me->converter,
                                   &me->raw_buffer.iterator, me->raw_buffer.end,
                                   insertion_p, BufferEnd);

        return CopiedByteN;
    }

    inline size_t
    Lexer_BufferFillerUser_Converter_insert_direct(Lexer_BufferFiller* alter_ego,
                                                        uint16_t** insertion_p,
                                                        uint16_t* BufferEnd,
                                                        void* ContentBegin,
                                                        void* ContentEnd)




    {


        Lexer_BufferFiller_Converter<void>* me = (Lexer_BufferFiller_Converter<void>*)alter_ego;



        uint8_t* read_iterator = (uint8_t*)ContentBegin;

        me->converter->convert(me->converter,
                               &read_iterator, (uint8_t*)ContentEnd,
                               insertion_p, BufferEnd);



        return (size_t)(read_iterator - (uint8_t*)ContentBegin);
    }

    inline void*
    Lexer_buffer_fill_region_append_conversion(::moritz::Lexer* me,
                                                    void* ContentBegin,
                                                    void* ContentEnd)



    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Converter_insert);
    }

    inline void*
    Lexer_buffer_fill_region_append_conversion_direct(::moritz::Lexer* me,
                                                           void* ContentBegin,
                                                           void* ContentEnd)




    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Converter_insert_direct);
    }

    inline void
    Lexer_buffer_conversion_fill_region_prepare(::moritz::Lexer* me)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;






        Lexer_BufferFiller_Converter_move_away_passed_content(filler);
    }

    inline uint8_t*
    Lexer_buffer_conversion_fill_region_begin(::moritz::Lexer* me)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;



        return filler->raw_buffer.end;
    }

    inline uint8_t*
    Lexer_buffer_conversion_fill_region_end(::moritz::Lexer* me)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;




        return filler->raw_buffer.memory_end;
    }

    inline size_t
    Lexer_buffer_conversion_fill_region_size(::moritz::Lexer* me)
    {
        ((Lexer_buffer_conversion_fill_region_end(me) >= Lexer_buffer_conversion_fill_region_begin(me)) ? static_cast<void> (0) : __assert_fail ("Lexer_buffer_conversion_fill_region_end(me) >= Lexer_buffer_conversion_fill_region_begin(me)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i"
        ,
 289
        , __PRETTY_FUNCTION__))
                                                                            ;

        return (size_t)( Lexer_buffer_conversion_fill_region_end(me)
                        - Lexer_buffer_conversion_fill_region_begin(me));
    }

    inline void
    Lexer_buffer_conversion_fill_region_finish(::moritz::Lexer* me,
                                                    const size_t ByteN)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;



        uint16_t* insertion_p = 0x0;

        filler->raw_buffer.end += ByteN;


        Lexer_Buffer_move_away_passed_content(&me->buffer);


        insertion_p = me->buffer._memory._end_of_file_p;
        filler->converter->convert(filler->converter,
                                   &filler->raw_buffer.iterator, filler->raw_buffer.end,
                                   &insertion_p, Lexer_Buffer_content_back(&me->buffer) + 1);

        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p, insertion_p);




        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(me->buffer._memory._end_of_file_p, insertion_p);

        Lexer_Buffer_end_of_file_set(&me->buffer, insertion_p);
    }



    inline void*
    Lexer::buffer_fill_region_append(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append(this, ContentBegin, ContentEnd); }

    inline void
    Lexer::buffer_fill_region_prepare()
    { Lexer_buffer_fill_region_prepare(this); }

    inline uint16_t*
    Lexer::buffer_fill_region_begin()
    { return Lexer_buffer_fill_region_begin(this); }

    inline uint16_t*
    Lexer::buffer_fill_region_end()
    { return Lexer_buffer_fill_region_end(this); }

    inline size_t
    Lexer::buffer_fill_region_size()
    { return Lexer_buffer_fill_region_size(this); }

    inline void
    Lexer::buffer_fill_region_finish(const size_t CharacterN)
    { Lexer_buffer_fill_region_finish(this, CharacterN); }

    inline uint16_t*
    Lexer::buffer_lexeme_start_pointer_get()
    { return Lexer_buffer_lexeme_start_pointer_get(this); }

    inline void
    Lexer::buffer_input_pointer_set(uint16_t* Adr)
    { Lexer_buffer_input_pointer_set(this, Adr); }


    inline void*
    Lexer::buffer_fill_region_append_conversion(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append_conversion(this, ContentBegin, ContentEnd); }

    inline void*
    Lexer::buffer_fill_region_append_conversion_direct(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append_conversion_direct(this, ContentBegin, ContentEnd); }

    inline void
    Lexer::buffer_conversion_fill_region_prepare()
    { Lexer_buffer_fill_region_prepare(this); }

    inline uint8_t*
    Lexer::buffer_conversion_fill_region_begin()
    { return Lexer_buffer_conversion_fill_region_begin(this); }

    inline uint8_t*
    Lexer::buffer_conversion_fill_region_end()
    { return Lexer_buffer_conversion_fill_region_end(this); }

    inline size_t
    Lexer::buffer_conversion_fill_region_size()
    { return Lexer_buffer_conversion_fill_region_size(this); }

    inline void
    Lexer::buffer_conversion_fill_region_finish(const size_t ByteN)
    { Lexer_buffer_conversion_fill_region_finish(this, ByteN); }




}

namespace moritz {

inline void
Lexer_set_callback_on_buffer_content_change(::moritz::Lexer* me,
                                                 void (*callback)(uint16_t*,
                                                                                uint16_t*))
{ me->buffer.on_buffer_content_change = callback; }

inline ::moritz::Token*
Lexer_token_p(::moritz::Lexer* me)
{

    return ((*(Lexer*)me).token);

}
inline const char*
Lexer_version(::moritz::Lexer* me)
{
    (void)me;
    return "QUEX_TYPE_ANALYZER"
           ": Version " "0.0.0-pre-release"
           ". Date " "Thu Mar 29 07:48:52 2012"
           "Generated by Quex " "0.62.2" ".";
}

inline bool
Lexer_byte_order_reversion(::moritz::Lexer* me)
{ return me->buffer._byte_order_reversion_active_f; }

inline void
Lexer_byte_order_reversion_set(::moritz::Lexer* me, bool Value)
{ me->buffer._byte_order_reversion_active_f = Value; }


inline void
Lexer_print_this(::moritz::Lexer* me)
{
    Lexer_Mode** iterator = 0x0;

    std::printf("   CurrentMode = %s;\n",
                      me->__current_mode_p == 0x0 ? "0x0" : me->__current_mode_p->name);

    Lexer_Buffer_print_this(&me->buffer);


    Lexer_Accumulator_print_this(&me->accumulator);


    Lexer_Counter_print_this(&me->counter);





    std::printf("   Mode Stack (%i/%i) = [",
                      (int)(me->_mode_stack.end - me->_mode_stack.begin),
                      (int)(me->_mode_stack.memory_end - me->_mode_stack.begin));
    for(iterator=me->_mode_stack.end-1; iterator >= me->_mode_stack.begin; --iterator)
        std::printf("%s, ", (*iterator)->name);

    std::printf("]\n");
    std::printf("   ByteOrderInversion = %s;\n",
                      Lexer_byte_order_reversion(me) ? "true" : "false");
}


inline void
Lexer::set_callback_on_buffer_content_change(void (*callback)(uint16_t*,
                                                            uint16_t*))
{ Lexer_set_callback_on_buffer_content_change(this, callback); }

inline ::moritz::Token*
Lexer::token_p()
{ return Lexer_token_p(this); }
inline const char*
Lexer::version() const
{ return Lexer_version((::moritz::Lexer*)this); }

inline void
Lexer::print_this()
{ Lexer_print_this(this); }

inline bool
Lexer::byte_order_reversion()
{ return Lexer_byte_order_reversion(this); }

inline void
Lexer::byte_order_reversion_set(bool Value)
{ Lexer_byte_order_reversion_set(this, Value); }


}
namespace moritz {

inline size_t
Lexer_tell(::moritz::Lexer* me)
{

    return (size_t)Lexer_Buffer_tell(&me->buffer);
}

inline void
Lexer_seek(::moritz::Lexer* me, const size_t CharacterIndex)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint16_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint16_t)'\0'; };
    Lexer_Buffer_seek(&me->buffer, (ptrdiff_t)CharacterIndex);
}

inline void
Lexer_seek_forward(::moritz::Lexer* me, const size_t CharacterN)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint16_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint16_t)'\0'; };
    Lexer_Buffer_move_forward(&me->buffer, (ptrdiff_t)CharacterN);
}

inline void
Lexer_seek_backward(::moritz::Lexer* me, const size_t CharacterN)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint16_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint16_t)'\0'; };
    Lexer_Buffer_move_backward(&me->buffer, (ptrdiff_t)CharacterN);
}

inline void
Lexer_undo(::moritz::Lexer* me)
{
    me->counter._line_number_at_end = me->counter._line_number_at_begin;
    me->counter._column_number_at_end = me->counter._column_number_at_begin;

    if( (&me->buffer)->_character_at_lexeme_start != (uint16_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint16_t)'\0'; };

    me->buffer._input_p = me->buffer._lexeme_start_p;

    (&me->buffer)->_character_at_lexeme_start = *((&me->buffer)->_input_p); *((&me->buffer)->_input_p) = '\0';;
}

inline void
Lexer_undo_n(::moritz::Lexer* me, size_t DeltaN_Backward)
{
    me->counter._line_number_at_end = me->counter._line_number_at_begin;
    me->counter._column_number_at_end = me->counter._column_number_at_begin;

    if( (&me->buffer)->_character_at_lexeme_start != (uint16_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint16_t)'\0'; };

    me->buffer._input_p -= (ptrdiff_t)DeltaN_Backward;

    (&me->buffer)->_character_at_lexeme_start = *((&me->buffer)->_input_p); *((&me->buffer)->_input_p) = '\0';;

    ((me->buffer._input_p >= me->buffer._lexeme_start_p) ? static_cast<void> (0) : __assert_fail ("me->buffer._input_p >= me->buffer._lexeme_start_p", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/navigation.i", 64, __PRETTY_FUNCTION__));
}



inline size_t
Lexer::tell()
{ return Lexer_tell(this); }

inline void
Lexer::seek(const size_t CharacterIndex)
{ Lexer_seek(this, CharacterIndex); }

inline void
Lexer::seek_forward(const size_t CharacterN)
{ Lexer_seek_forward(this, CharacterN); }

inline void
Lexer::seek_backward(const size_t CharacterN)
{ Lexer_seek_backward(this, CharacterN); }

inline void
Lexer::undo()
{ return Lexer_undo(this); }

inline void
Lexer::undo(size_t DeltaN_Backward)
{ return Lexer_undo_n(this, DeltaN_Backward); }



}















namespace moritz {

    inline void Lexer_Buffer_x_show_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_brief_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_content(Lexer_Buffer*);

    inline void
    Lexer_Buffer_show_brief_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_x_show_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_content_intern(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_byte_content(Lexer_Buffer* buffer, const int IndentationN);

}


namespace moritz {

    inline void Lexer_Buffer_x_show_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_brief_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_content(Lexer_Buffer*);

    inline void
    Lexer_Buffer_show_brief_content(Lexer_Buffer* buffer)
    {
        Lexer_BufferFiller* me = buffer->filler;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 25, __PRETTY_FUNCTION__));
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 26, __PRETTY_FUNCTION__));

        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        std::printf("Begin of Buffer Character Index: %i\n", (int)buffer->_content_character_index_begin);
        std::printf("End   of Buffer Character Index: %i\n", (int)me->tell_character_index(me));
        if( buffer->_memory._end_of_file_p == 0x0 )
            std::printf("_memory._memory._end_of_file_p (offset)  = <0x0>\n");
        else
            std::printf("_memory._end_of_file_p (offset)  = %08X\n",
                              (int)(buffer->_memory._end_of_file_p - buffer->_memory._front));
        std::printf("_input_p (offset)        = %08X\n", (int)(buffer->_input_p - buffer->_memory._front));
        std::printf("_lexeme_start_p (offset) = %08X\n", (int)(buffer->_lexeme_start_p - buffer->_memory._front));
        std::printf("_back (offset)           = %08X\n", (int)(buffer->_memory._back - buffer->_memory._front));
    }

    inline void
    Lexer_Buffer_x_show_content(Lexer_Buffer* buffer)
    {
        Lexer_Buffer_show_content_intern(buffer);
        Lexer_Buffer_show_brief_content(buffer);
    }

    inline uint16_t
    Lexer___Buffer_get_border_char(Lexer_Buffer* buffer, const uint16_t* C)
    {
        if ( *C != ((uint16_t)0x0) )
            return (uint16_t)'?';
        else if( buffer->_memory._end_of_file_p == C )
            return (uint16_t)']';
        else if( buffer->_content_character_index_begin == 0 && buffer->_memory._front == C )
            return (uint16_t)'[';
        else
            return (uint16_t)'|';
    }

    inline void
    Lexer_Buffer_show_content_intern(Lexer_Buffer* buffer)
    {
        size_t i = 0;
        size_t length = 0;

        uint16_t EmptyChar = (uint16_t)(-1);
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint16_t* BufferFront = buffer->_memory._front;
        uint16_t* BufferBack = buffer->_memory._back;
        uint16_t* iterator = 0x0;
        uint16_t* end_p = buffer->_memory._end_of_file_p != 0x0 ? buffer->_memory._end_of_file_p
                                         : buffer->_memory._back;

        std::printf("|%c", (int)Lexer___Buffer_get_border_char(buffer, BufferFront));
        for(iterator = ContentFront; iterator != end_p; ++iterator) {
            std::printf("%c", *iterator == EmptyChar ? (int)'~' : (int)*iterator);
        }
        std::printf("%c", (int)Lexer___Buffer_get_border_char(buffer, end_p));

        length = (buffer->_memory._end_of_file_p == 0x0) ? 0 : (size_t)(BufferBack - buffer->_memory._end_of_file_p);
        for(i=0; i < length; ++i) std::printf("|");

        std::printf("|");
    }

    inline void
    Lexer_Buffer_show_content(Lexer_Buffer* buffer)
    {




        size_t i = 0;
        char* tmp = 0;
        const size_t ContentSize = Lexer_Buffer_content_size(buffer);
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint16_t* BufferFront = buffer->_memory._front;
        uint16_t* BufferBack = buffer->_memory._back;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 101, __PRETTY_FUNCTION__));

        tmp = (char*)std::malloc(ContentSize + 4);






        for(i=2; i<ContentSize + 2 ; ++i) tmp[i] = ' ';
        tmp[ContentSize+4] = '\0';
        tmp[ContentSize+3] = '|';
        tmp[ContentSize+2] = (char)Lexer___Buffer_get_border_char(buffer, BufferBack);
        tmp[1] = (char)Lexer___Buffer_get_border_char(buffer, BufferFront);
        tmp[0] = '|';

        tmp[buffer->_input_p - ContentFront + 2] = 'C';
        if( buffer->_lexeme_start_p >= ContentFront && buffer->_lexeme_start_p <= BufferBack )
            tmp[(int)(buffer->_lexeme_start_p - ContentFront) + 2] = 'S';

        if ( buffer->_input_p == ContentFront - 2 ) {
            std::printf("%s", tmp);
            std::printf(" <out>");
        } else {
            std::printf(" ");
            if( *buffer->_input_p == ((uint16_t)0x0) )
                std::printf("BLC");
            else
                std::printf("'%c'", (char)(*buffer->_input_p));
        }

        std::printf("\n");
        Lexer_Buffer_show_content_intern(buffer);
        std::free(tmp);
    }

    inline void
    Lexer_Buffer_show_byte_content(Lexer_Buffer* buffer, const int IndentationN)
    {
        Lexer_BufferMemory* memory = &buffer->_memory;

        int i = 0, j = 0;
        uint8_t* byte_p = (uint8_t*)memory->_front;
        uint8_t* next_byte_p = (uint8_t*)memory->_front + 1;
        uint8_t* End = (uint8_t*)(memory->_back + 1);

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 147, __PRETTY_FUNCTION__));
        ((memory != 0x0) ? static_cast<void> (0) : __assert_fail ("memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 148, __PRETTY_FUNCTION__));

        for(j=0; j<IndentationN; ++j) fprintf(stdout, " ");
        for(; byte_p != End; ++byte_p, ++next_byte_p, ++i) {
            fprintf(stdout, "%02X", (int)*byte_p);
            if ( next_byte_p == (uint8_t*)buffer->_memory._end_of_file_p )
                fprintf(stdout, "[");
            else if( byte_p == (uint8_t*)buffer->_memory._end_of_file_p + sizeof(uint16_t)-1)
                fprintf(stdout, "]");
            else
                fprintf(stdout, ".");
            if( (i+1) % 0x8 == 0 ) fprintf(stdout, " ");
            if( (i+1) % 0x10 == 0 ) {
                fprintf(stdout, "\n");
                for(j=0; j<IndentationN; ++j) fprintf(stdout, " ");
            }
        }
        fprintf(stdout, "\n");
    }

    inline void
    Lexer_Buffer_show_debug_print_lines(uint16_t** iterator,
                                             uint16_t* Begin,
                                             uint16_t* TotalEnd,
                                             Lexer_Buffer* buffer)
    {
        int length = 0;
        uint16_t* end = Begin + 5 > TotalEnd ? TotalEnd : Begin + 5;

        if( Begin > *iterator ) {
            *iterator = Begin;
            std::fprintf(stderr, "                                           ...\n");
        } else if( *iterator >= end ) {
            return;
        }

        for(; *iterator < end; ++*iterator) {
            length = 0;
            std::fprintf(stderr, "   ");

            if( *iterator == buffer->_memory._front ) {
                std::fprintf(stderr, "buffer front");
                length += 12;
            }
            if( *iterator == buffer->_lexeme_start_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "lexeme start");
                length += 12;
            }
            if( *iterator == buffer->_input_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "input");
                length += 5;
            }
            if( *iterator == buffer->_memory._end_of_file_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "end of file");
                length += 11;
            }
            if( *iterator == buffer->_memory._back ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "buffer back");
                length += 11;
            }
            if( length ) {
                for(; length < 39; ++length)
                    std::fprintf(stderr, "-");
                std::fprintf(stderr, ">");
            } else {
                std::fprintf(stderr, "                                        ");
            }


            std::fprintf(stderr, "[%04X] 0x%04X\n",
                               (int)(*iterator - buffer->_memory._front),
                               (int)(**iterator));
        }
    }

    inline void
    Lexer_Buffer_show_debug_content(Lexer_Buffer* buffer)
    {
        uint16_t* iterator = buffer->_memory._front;
        uint16_t* total_end = buffer->_memory._back + 1;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 243, __PRETTY_FUNCTION__));
        std::fprintf(stderr, "_________________________________________________________________\n");
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._front, total_end, buffer);
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_lexeme_start_p - 2, total_end, buffer);
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_input_p - 2, total_end, buffer);
        if( buffer->_memory._end_of_file_p != 0x0 ) {
            Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._end_of_file_p - 4, total_end, buffer);
        }
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._back - 4, total_end, buffer);
        std::fprintf(stderr, "_________________________________________________________________\n");
    }

}



namespace moritz {

    inline void Lexer_Buffer_init(Lexer_Buffer* me,
                                             bool ByteOrderReversionF);
    inline void Lexer_Buffer_init_analyzis(Lexer_Buffer* me,
                                                      bool ByteOrderReversionF);
    inline void
    Lexer_BufferMemory_construct(Lexer_BufferMemory* me,
                                      uint16_t* Memory,
                                      const size_t Size,
                                      uint16_t* EndOfFileP);
    inline void
    Lexer_BufferMemory_init(Lexer_BufferMemory* me,
                                 uint16_t* Memory,
                                 const size_t Size,
                                 uint16_t* EndOfFileP,
                                 bool ExternalOwnerF);
    inline void Lexer_BufferMemory_destruct(Lexer_BufferMemory* me);

    template <class InputHandleT> inline void
    Lexer_Buffer_construct(Lexer_Buffer* me,
                                InputHandleT* input_handle,
                                uint16_t* InputMemory,
                                const size_t MemorySize,
                                uint16_t* EndOfFileP,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize,
                                bool ByteOrderReversionF)







    {

        if( input_handle != 0x0 ) ((InputMemory == 0x0) ? static_cast<void> (0) : __assert_fail ("InputMemory == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 53, __PRETTY_FUNCTION__));
        if( InputMemory != 0x0 ) {
            ((input_handle == 0x0) ? static_cast<void> (0) : __assert_fail ("input_handle == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 55, __PRETTY_FUNCTION__));

            QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(InputMemory + 1, EndOfFileP);
        }




        Lexer_BufferMemory_construct(&(me->_memory),
                                          InputMemory, MemorySize, EndOfFileP);

        me->on_buffer_content_change = 0x0;

        me->filler = Lexer_BufferFiller_new(input_handle, CharacterEncodingName, TranslationBufferMemorySize);


        Lexer_Buffer_init(me, ByteOrderReversionF);

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
        ((me->_input_p == me->_memory._front + 1) ? static_cast<void> (0) : __assert_fail ("me->_input_p == me->_memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 75, __PRETTY_FUNCTION__));
    }

    template <class InputHandleT> inline void
    Lexer_Buffer_reset(Lexer_Buffer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            const size_t TranslationBufferMemorySize)
    {

        if( me->filler != 0x0 ) {


            me->filler->seek_character_index(me->filler, 0);
            me->filler->delete_self(me->filler);
        }
        me->filler = Lexer_BufferFiller_new(input_handle, CharacterEncodingName, TranslationBufferMemorySize);

        Lexer_Buffer_init_analyzis(me, me->_byte_order_reversion_active_f);

        if( me->filler != 0x0 ) {

            Lexer_BufferFiller_initial_load(me);
        } else {
            me->_content_character_index_begin = 0;
            me->_content_character_index_end = 0;
        }

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
        ((me->_input_p == me->_memory._front + 1) ? static_cast<void> (0) : __assert_fail ("me->_input_p == me->_memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 114, __PRETTY_FUNCTION__));
    }

    inline void
    Lexer_Buffer_init(Lexer_Buffer* me, bool ByteOrderReversionF)
    {


        me->_content_character_index_end = 0;
        me->_content_character_index_begin = 0;

        Lexer_Buffer_init_analyzis(me, ByteOrderReversionF);

        if( me->filler != 0x0 ) {

            Lexer_BufferFiller_initial_load(me);
        }

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
    }

    inline void
    Lexer_Buffer_init_analyzis(Lexer_Buffer* me, bool ByteOrderReversionF)
    {
        me->_byte_order_reversion_active_f = ByteOrderReversionF;


        me->_input_p = me->_memory._front + 1;
        me->_lexeme_start_p = me->_memory._front + 1;




        me->_character_at_lexeme_start = '\0';



    }

    inline void
    Lexer_Buffer_destruct(Lexer_Buffer* me)
    {
        if( me->filler != 0x0 ) {
            me->filler->delete_self(me->filler);
            me->filler = 0x0;
        }

        Lexer_BufferMemory_destruct(&me->_memory);
    }

    inline void
    Lexer_Buffer_input_p_add_offset(Lexer_Buffer* buffer, const size_t Offset)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(buffer);
        buffer->_input_p += Offset;
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(buffer);
    }

    inline Lexer_MemoryPositionMimiker
    Lexer_Buffer_tell_memory_adr(Lexer_Buffer* buffer)
    {





        return Lexer_MemoryPositionMimiker(buffer->_input_p, buffer->_content_character_index_begin);



    }

    inline void
    Lexer_Buffer_seek_memory_adr(Lexer_Buffer* buffer, Lexer_MemoryPositionMimiker Position)
    {





        ((Position.buffer_start_position == (size_t)buffer->_content_character_index_begin) ? static_cast<void> (0) : __assert_fail ("Position.buffer_start_position == (size_t)buffer->_content_character_index_begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 195, __PRETTY_FUNCTION__));
        buffer->_input_p = Position.address;



        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
    }

    inline uint16_t
    Lexer_Buffer_input_get_offset(Lexer_Buffer* me, const ptrdiff_t Offset)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(me);
        ((me->_input_p + Offset > me->_memory._front) ? static_cast<void> (0) : __assert_fail ("me->_input_p + Offset > me->_memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 207, __PRETTY_FUNCTION__));
        ((me->_input_p + Offset <= me->_memory._back) ? static_cast<void> (0) : __assert_fail ("me->_input_p + Offset <= me->_memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 208, __PRETTY_FUNCTION__));
        return *(me->_input_p + Offset);
    }

    inline uint16_t*
    Lexer_Buffer_content_front(Lexer_Buffer* me)
    {
        return me->_memory._front + 1;
    }

    inline uint16_t*
    Lexer_Buffer_content_back(Lexer_Buffer* me)
    {
        return me->_memory._back - 1;
    }

    inline size_t
    Lexer_Buffer_content_size(Lexer_Buffer* me)
    {
        return Lexer_BufferMemory_size(&(me->_memory)) - 2;
    }

    inline uint16_t*
    Lexer_Buffer_text_end(Lexer_Buffer* me)
    {

        if( me->_memory._end_of_file_p != 0 ) return me->_memory._end_of_file_p;
        else return me->_memory._back;
    }

    inline ptrdiff_t
    Lexer_Buffer_distance_input_to_text_end(Lexer_Buffer* me)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(me);
        return Lexer_Buffer_text_end(me) - me->_input_p;
    }

    inline void
    Lexer_Buffer_end_of_file_set(Lexer_Buffer* me, uint16_t* Position)
    {


        me->_memory._end_of_file_p = Position;
        *(me->_memory._end_of_file_p) = ((uint16_t)0x0);


    }

    inline void
    Lexer_Buffer_end_of_file_unset(Lexer_Buffer* buffer)
    {



        buffer->_memory._end_of_file_p = 0x0;

    }

    inline bool
    Lexer_Buffer_is_end_of_file(Lexer_Buffer* buffer)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        return buffer->_input_p == buffer->_memory._end_of_file_p;
    }

    inline bool
    Lexer_Buffer_is_begin_of_file(Lexer_Buffer* buffer)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        if ( buffer->_input_p != buffer->_memory._front ) return false;
        else if( buffer->_content_character_index_begin != 0 ) return false;
        return true;
    }

    inline void
    Lexer_Buffer_move_forward(Lexer_Buffer* me, const ptrdiff_t CharacterN)
    {
       QUEX_BUFFER_ASSERT_CONSISTENCY(me);


       if( CharacterN < Lexer_Buffer_distance_input_to_text_end(me) ) {

           me->_input_p += CharacterN;
       }
       else {

           if( me->filler == 0x0 || me->_memory._end_of_file_p != 0x0 ) {
               me->_input_p = Lexer_Buffer_text_end(me);
           } else {

               ptrdiff_t delta = CharacterN;
               ptrdiff_t distance = Lexer_Buffer_distance_input_to_text_end(me);
               do {
                   delta -= distance;

                   me->_input_p = me->_memory._back;
                   me->_lexeme_start_p = me->_input_p;
                   if( Lexer_BufferFiller_load_forward(me) == 0 ) {
                       me->_input_p = Lexer_Buffer_text_end(me);
                       break;
                   }

                   ++(me->_input_p);
                   distance = Lexer_Buffer_distance_input_to_text_end(me);

                   if( delta < distance ) {

                       me->_input_p += delta;
                       break;
                   }
               } while( 1 + 1 == 2 );
           }
       }
       me->_lexeme_start_p = me->_input_p;
       me->_character_at_lexeme_start = *(me->_lexeme_start_p);




       QUEX_BUFFER_ASSERT_CONSISTENCY(me);
    }

    inline void
    Lexer_Buffer_move_backward(Lexer_Buffer* me, const ptrdiff_t CharacterN)
    {
       QUEX_BUFFER_ASSERT_CONSISTENCY(me);


       if( CharacterN < (me->_input_p - Lexer_Buffer_content_front(me)) ) {

           me->_input_p -= CharacterN;
       }
       else {

           if( me->filler == 0x0 || me->_content_character_index_begin == 0 ) {
               me->_input_p = Lexer_Buffer_content_front(me);
           } else {

               ptrdiff_t delta = (ptrdiff_t)CharacterN;
               ptrdiff_t distance = (ptrdiff_t)(me->_input_p - Lexer_Buffer_content_front(me));
               do {
                   delta -= distance;

                   me->_input_p = me->_memory._front;
                   me->_lexeme_start_p = me->_input_p + 1;
                   if( Lexer_BufferFiller_load_backward(me) == 0 ) {
                       me->_input_p = Lexer_Buffer_content_front(me);
                       break;
                   }

                   distance = (ptrdiff_t)(me->_input_p - Lexer_Buffer_content_front(me));

                   if( delta < distance ) {

                       me->_input_p -= delta;
                       break;
                   }
               } while( 1 + 1 == 2 );
           }
       }
       me->_lexeme_start_p = me->_input_p;
       me->_character_at_lexeme_start = *(me->_lexeme_start_p);




       QUEX_BUFFER_ASSERT_CONSISTENCY(me);
    }

    inline ptrdiff_t
    Lexer_Buffer_tell(Lexer_Buffer* me)
    {




        const ptrdiff_t DeltaToBufferBegin = me->_input_p - me->_memory._front - 1;


        if( me->filler == 0x0 )
            return DeltaToBufferBegin;
        else
            return DeltaToBufferBegin + me->_content_character_index_begin;
    }

    inline void
    Lexer_Buffer_seek(Lexer_Buffer* me, const ptrdiff_t CharacterIndex)
    {


        const ptrdiff_t CurrentCharacterIndex = Lexer_Buffer_tell(me);
        if( CharacterIndex > CurrentCharacterIndex )
            Lexer_Buffer_move_forward(me, CharacterIndex - CurrentCharacterIndex);
        else
            Lexer_Buffer_move_backward(me, CurrentCharacterIndex - CharacterIndex);
    }

    inline void
    Lexer_Buffer_move_away_passed_content(Lexer_Buffer* me)
    {
        uint16_t* ContentFront = Lexer_Buffer_content_front(me);
        uint16_t* RemainderBegin = me->_input_p;
        uint16_t* RemainderEnd = me->_memory._end_of_file_p;
        uint16_t* MoveRegionBegin = RemainderBegin - (ptrdiff_t)(256);
        ptrdiff_t MoveRegionSize = (ptrdiff_t)(RemainderEnd - MoveRegionBegin);


        ((me->_content_character_index_begin == 0) ? static_cast<void> (0) : __assert_fail ("me->_content_character_index_begin == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 431, __PRETTY_FUNCTION__));


        if( MoveRegionBegin <= ContentFront ) { return; }

        std::memmove((void*)ContentFront,
                           (void*)MoveRegionBegin,
                           (size_t)MoveRegionSize * sizeof(uint16_t));





        Lexer_Buffer_end_of_file_set(me, ContentFront + MoveRegionSize);




        me->_input_p = ContentFront + (256);



        me->_lexeme_start_p = me->_input_p;
    }

    inline size_t
    Lexer_BufferMemory_size(Lexer_BufferMemory* me)
    { return (size_t)(me->_back - me->_front + 1); }

    inline void
    Lexer_Buffer_reverse_byte_order(uint16_t* Begin, uint16_t* End)
    {
        uint8_t tmp = 0xFF;
        uint16_t* iterator = 0x0;

        switch( sizeof(uint16_t) ) {
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 468, __PRETTY_FUNCTION__));
            break;
        case 1:

            break;
        case 2:
            for(iterator=Begin; iterator != End; ++iterator) {
                tmp = *(((uint8_t*)iterator) + 0);
                *(((uint8_t*)iterator) + 0) = *(((uint8_t*)iterator) + 1);
                *(((uint8_t*)iterator) + 1) = tmp;
            }
            break;
        case 4:
            for(iterator=Begin; iterator != End; ++iterator) {
                tmp = *(((uint8_t*)iterator) + 0);
                *(((uint8_t*)iterator) + 0) = *(((uint8_t*)iterator) + 3);
                *(((uint8_t*)iterator) + 3) = tmp;
                tmp = *(((uint8_t*)iterator) + 1);
                *(((uint8_t*)iterator) + 1) = *(((uint8_t*)iterator) + 2);
                *(((uint8_t*)iterator) + 2) = tmp;
            }
            break;
        }
    }

    inline void
    Lexer_BufferMemory_construct(Lexer_BufferMemory* me,
                                      uint16_t* Memory,
                                      const size_t Size,
                                      uint16_t* EndOfFileP)


    {
        uint16_t* chunk = Memory;
        uint16_t* end_of_file_p = EndOfFileP;
        bool external_f = true;

        if( Memory == 0x0 ) {


            chunk = Lexer_MemoryManager_BufferMemory_allocate(Size * sizeof(uint16_t));
            end_of_file_p = 0x0;
            external_f = false;
        }

        Lexer_BufferMemory_init(me, chunk, Size, end_of_file_p, external_f);
    }

    inline uint16_t*
    Lexer_BufferMemory_reset(Lexer_BufferMemory* me,
                                  uint16_t* Memory,
                                  const size_t Size,
                                  uint16_t* EndOfContentP)

    {
        uint16_t* old_memory = (me->_external_owner_f) ? me->_front : 0x0;

        if( Memory == 0x0 ) return old_memory;


        Lexer_BufferMemory_destruct(me);


        ((Memory != 0x0) ? static_cast<void> (0) : __assert_fail ("Memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 531, __PRETTY_FUNCTION__));


        ((EndOfContentP > Memory) ? static_cast<void> (0) : __assert_fail ("EndOfContentP > Memory", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 534, __PRETTY_FUNCTION__));
        ((EndOfContentP <= Memory + Size) ? static_cast<void> (0) : __assert_fail ("EndOfContentP <= Memory + Size", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 535, __PRETTY_FUNCTION__));

        Lexer_BufferMemory_init(me, Memory, Size, EndOfContentP, true);

        return old_memory;
    }

    inline void
    Lexer_BufferMemory_init(Lexer_BufferMemory* me,
                                 uint16_t* Memory,
                                 const size_t Size,
                                 uint16_t* EndOfFileP,
                                 bool ExternalOwnerF)
    {


        ((Memory != 0x0) ? static_cast<void> (0) : __assert_fail ("Memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 551, __PRETTY_FUNCTION__));
        ((Size != 0) ? static_cast<void> (0) : __assert_fail ("Size != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 552, __PRETTY_FUNCTION__));

        if( Size <= (256) + 2) {
            do { throw std::runtime_error("Error: Tried to initialize buffer memory with a size less or equal\n" "Error: to QUEX_SETTING_BUFFER_MIN_FALLBACK_N + 2. Maybe, define\n" "Error: -DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=0, if no pre-contexts\n" "Error: are involved."); } while(0)


                                                   ;
        }
        else if( EndOfFileP != 0x0 ) {
            ((EndOfFileP > Memory) ? static_cast<void> (0) : __assert_fail ("EndOfFileP > Memory", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 561, __PRETTY_FUNCTION__));
            ((EndOfFileP <= Memory + Size) ? static_cast<void> (0) : __assert_fail ("EndOfFileP <= Memory + Size", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 562, __PRETTY_FUNCTION__));
        }


        me->_front = Memory;
        me->_end_of_file_p = EndOfFileP;
        me->_back = Memory + (Size - 1);
        me->_external_owner_f = ExternalOwnerF;
        *(me->_front) = ((uint16_t)0x0);
        *(me->_back) = ((uint16_t)0x0);
        if( me->_end_of_file_p != 0x0 ) {
            *(me->_end_of_file_p) = ((uint16_t)0x0);
        }


        if( EndOfFileP != 0x0 ) {
           if( EndOfFileP < me->_back - 1 ) {
               std::memset(EndOfFileP + 1, 0xFF, (size_t)((me->_back - EndOfFileP) - (ptrdiff_t)(1)));
            }
        }

    }

    inline void
    Lexer_BufferMemory_destruct(Lexer_BufferMemory* me)
    {
        if( me->_external_owner_f == false && me->_front != (uint16_t*)0x0 ) {
            Lexer_MemoryManager_BufferMemory_free(me->_front);

        }

        me->_front = me->_back = (uint16_t*)0x0;
    }

    inline void
    Lexer_Buffer_print_this(Lexer_Buffer* me)
    {
        uint16_t* Offset = me->_memory._front;

        std::printf("   Buffer:\n");
        std::printf("      Memory:\n");
        std::printf("      _front         =  0;\n");
        std::printf("      _back          = +0x%X;\n", (int)(me->_memory._back - Offset));
        if( me->_memory._end_of_file_p != 0x0 )
            std::printf("      _end_of_file_p = +0x%X;\n", (int)(me->_memory._end_of_file_p - Offset));
        else
            std::printf("      _end_of_file_p = <void>;\n");


        std::printf("      _external_owner_f = %s;\n", me->_memory._external_owner_f ? "true" : "false");

        std::printf("   _input_p        = +0x%X;\n", (int)(me->_input_p - Offset));
        std::printf("   _lexeme_start_p = +0x%X;\n", (int)(me->_lexeme_start_p - Offset));

        std::printf("   _character_at_lexeme_start = %X;\n", (int)me->_character_at_lexeme_start);



        std::printf("   _content_character_index_begin = %i;\n", (int)me->_content_character_index_begin);
        std::printf("   _content_character_index_end   = %i;\n", (int)me->_content_character_index_end);
        std::printf("   _byte_order_reversion_active_f = %s;\n", me->_byte_order_reversion_active_f ? "true" : "false");
    }

}




namespace moritz {

    inline uint8_t*
    Lexer_MemoryManager_Default_allocate(const size_t ByteN)
    {
         uint8_t* result = (uint8_t*)std::malloc((size_t)ByteN);

         std::memset((void*)result, 0xFF, ByteN);

         return result;
    }

    inline void
    Lexer_MemoryManager_Default_free(void* Obj)
    { std::free(Obj); }

    struct __QuexBufferFiller_tag;
    inline uint16_t*
    Lexer_MemoryManager_BufferMemory_allocate(const size_t ByteN)
    { return (uint16_t*)Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferMemory_free(uint16_t* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }

    inline void*
    Lexer_MemoryManager_BufferFiller_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferFiller_free(void* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }

    inline uint8_t*
    Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free(memory); }


    inline void*
    Lexer_MemoryManager_Converter_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_Converter_free(void* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }



    inline uint16_t*
    Lexer_MemoryManager_Text_allocate(const size_t ByteN)
    { return (uint16_t*)Lexer_MemoryManager_Default_allocate(ByteN); }

    extern uint16_t Lexer_LexemeNullObject;

    inline void
    Lexer_MemoryManager_Text_free(uint16_t* memory)
    {

        ((memory != &(Lexer_LexemeNullObject)) ? static_cast<void> (0) : __assert_fail ("memory != &(Lexer_LexemeNullObject)", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 92, __PRETTY_FUNCTION__));

        if( memory != 0x0 ) {
            Lexer_MemoryManager_Default_free((void*)memory);
        }
    }
    inline size_t
    Lexer_MemoryManager_insert(uint8_t* drain_begin_p, uint8_t* drain_end_p,
                                    uint8_t* source_begin_p, uint8_t* source_end_p)





    {

        const size_t DrainSize = (size_t)(drain_end_p - drain_begin_p);
        size_t size = (size_t)(source_end_p - source_begin_p);
        ((drain_end_p >= drain_begin_p) ? static_cast<void> (0) : __assert_fail ("drain_end_p >= drain_begin_p", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 137, __PRETTY_FUNCTION__));
        ((source_end_p >= source_begin_p) ? static_cast<void> (0) : __assert_fail ("source_end_p >= source_begin_p", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 138, __PRETTY_FUNCTION__));

        if( DrainSize < size ) size = DrainSize;



        if( drain_begin_p > source_begin_p ) ((drain_begin_p >= source_begin_p + size) ? static_cast<void> (0) : __assert_fail ("drain_begin_p >= source_begin_p + size", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 144, __PRETTY_FUNCTION__));
        else ((drain_begin_p <= source_begin_p - size) ? static_cast<void> (0) : __assert_fail ("drain_begin_p <= source_begin_p - size", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 145, __PRETTY_FUNCTION__));

        std::memcpy(drain_begin_p, source_begin_p, size);

        return size;
    }
    inline Lexer_Memento*
    Lexer_MemoryManager_Memento_allocate()
    {
        const size_t MemorySize = sizeof(Lexer_Memento);
        return (Lexer_Memento*)Lexer_MemoryManager_Default_allocate(MemorySize);
    }

    inline void
    Lexer_MemoryManager_Memento_free(struct Lexer_Memento_tag* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }


}



namespace moritz {

inline void
Lexer_construct_memory(::moritz::Lexer* me,
                            uint16_t* BufferMemoryBegin,
                            size_t BufferMemorySize,
                            uint16_t* BufferEndOfContentP,
                            const char* CharacterEncodingName ,
                            bool ByteOrderReversionF )
{
    size_t memory_size = BufferMemoryBegin != 0 ? BufferMemorySize
                          : 65536;

    uint16_t* iterator = 0x0;

    ((memory_size == 0 || memory_size > 2) ? static_cast<void> (0) : __assert_fail ("memory_size == 0 || memory_size > 2", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 26, __PRETTY_FUNCTION__));
    if( BufferMemoryBegin != 0x0 ) {


        if( BufferMemorySize <= (256) + 2) {
            do { throw std::runtime_error("\nConstructor: Provided memory size must be more than 2 greater than\n" "Constructor: QUEX_SETTING_BUFFER_MIN_FALLBACK_N. If in doubt, specify\n" "Constructor: -DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=0 as compile option.\n"); } while(0)

                                                                                                       ;
        }
        if( BufferEndOfContentP < BufferMemoryBegin
            || BufferEndOfContentP > (BufferMemoryBegin + BufferMemorySize - 1)) {
            do { throw std::runtime_error("\nConstructor: Argument 'BufferEndOfContentP' must be inside the provided memory\n" "Constructor: buffer (speficied by 'BufferMemoryBegin' and 'BufferMemorySize').\n" "Constructor: Note, that the last element of the buffer is to be filled with\n" "Constructor: the buffer limit code character.\n"); } while(0)


                                                                              ;
        }
    }
    if( BufferEndOfContentP != 0x0 ) {
        ((BufferEndOfContentP > BufferMemoryBegin) ? static_cast<void> (0) : __assert_fail ("BufferEndOfContentP > BufferMemoryBegin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 44, __PRETTY_FUNCTION__));
        ((BufferEndOfContentP <= BufferMemoryBegin + memory_size - 1) ? static_cast<void> (0) : __assert_fail ("BufferEndOfContentP <= BufferMemoryBegin + memory_size - 1", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 45, __PRETTY_FUNCTION__));



        for(iterator = BufferMemoryBegin + 1; iterator != BufferEndOfContentP; ++iterator) {
            if( *iterator == ((uint16_t)0x0)
                || *iterator == ((uint16_t)0x1) ) {
                do { throw std::runtime_error("\nConstructor: Buffer limit code and/or path termination code appeared in buffer\n" "Constructor: when pointed to user memory. Note, that the memory pointed to must\n" "Constructor: be initialized! You might redefine QUEX_SETTING_PATH_TERMINATION_CODE\n" "Constructor: and/or QUEX_SETTING_PATH_TERMINATION_CODE; or use command line arguments\n" "Constructor: '--buffer-limit' and '--path-termination'."); } while(0)



                                                                                          ;
            }
        }
    }


    Lexer_constructor_core(me,



                                (void*)0x0,

                                CharacterEncodingName, ByteOrderReversionF,
                                BufferMemoryBegin, memory_size, BufferEndOfContentP);
}

inline void
Lexer_construct_file_name(::moritz::Lexer* me,
                               const char* Filename,
                               const char* CharacterEncodingName ,
                               bool ByteOrderReversionF )
{



    std::FILE* fh = std::fopen(Filename, "rb");

    Lexer_construct_FILE(me, fh, CharacterEncodingName, ByteOrderReversionF);


    me->__file_handle_allocated_by_constructor = fh;
}

inline void
Lexer_construct_FILE(::moritz::Lexer* me,
                          std::FILE* fh,
                          const char* CharacterEncodingName ,
                          bool ByteOrderReversionF )
{
    if( fh == __null ) do { throw std::runtime_error("Error: received NULL as a file handle."); } while(0);
    setbuf(fh, 0);

    Lexer_constructor_core(me, fh,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}


inline void
Lexer_construct_istream(::moritz::Lexer* me,
                             std::istream* p_input_stream,
                             const char* CharacterEncodingName ,
                             bool ByteOrderReversionF )
{
    if( p_input_stream == __null ) do { throw std::runtime_error("Error: received NULL as pointer to input stream."); } while(0);
    if( p_input_stream == std::cin ) do { throw std::runtime_error("Error: Quex engine constructor has received a standard input handle!\n" "Error: Standard input has to be treated like buffered input. Please,\n" "Error: consult the documentation or the example 'stdinlexer.cpp' in\n" "Error: directory $QUEX_PATH/demo/010 (> make stdinlexer.exe). Please,\n" "Error: review the other (non-stdin) examples in this directory to\n" "Error: conclude how to read encoded data via stdin.\n"); } while(0);
    Lexer_constructor_core(me, p_input_stream,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}




inline void
Lexer_construct_wistream(::moritz::Lexer* me,
                              std::wistream* p_input_stream,
                              const char* CharacterEncodingName ,
                              bool ByteOrderReversionF )
{
    if( p_input_stream == __null )
        do { throw std::runtime_error("Error: received NULL as pointer to input stream.\n"); } while(0);
    Lexer_constructor_core(me, p_input_stream,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}


inline void
Lexer_destruct(::moritz::Lexer* me)
{
    Lexer_destruct_basic(me);
}

template <class InputHandleT> inline void
Lexer_reset(::moritz::Lexer* me,
                 InputHandleT* input_handle,
                 const char* CharacterEncodingName )
{
    Lexer_reset_basic(me, input_handle, CharacterEncodingName,
                           ((size_t)65536));
    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));
}

inline uint16_t*
Lexer_reset_buffer(::moritz::Lexer* me,
                        uint16_t* BufferMemoryBegin,
                        size_t BufferMemorySize,
                        uint16_t* BufferEndOfContentP,
                        const char* CharacterEncodingName )
{
    uint16_t* old_memory = 0x0;


    if( BufferEndOfContentP < BufferMemoryBegin
        || BufferEndOfContentP > (BufferMemoryBegin + BufferMemorySize - 1)) {
        do { throw std::runtime_error("\nreset_buffer: Argument 'BufferEndOfContentP' must be inside the provided memory\n" "reset_buffer: buffer (speficied by 'BufferMemoryBegin' and 'BufferMemorySize').\n" "reset_buffer: Note, that the last element of the buffer is to be filled with\n" "reset_buffer: the buffer limit code character.\n"); } while(0)


                                                                           ;
    }




    old_memory = Lexer_BufferMemory_reset(&me->buffer._memory,
                                               BufferMemoryBegin, BufferMemorySize,
                                               BufferEndOfContentP);

    if( BufferMemoryBegin == 0x0 ) return old_memory;

    Lexer_reset_basic(me, (FILE*)0x0, CharacterEncodingName,
                           ((size_t)65536));

    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));

    return old_memory;
}

inline void
Lexer_reset_plain(::moritz::Lexer* me,
                       const char* CharacterEncodingName )
{ Lexer_reset(me, (FILE*)0x0, CharacterEncodingName); }


inline
Lexer::Lexer(uint16_t* BufferMemoryBegin,
                                 size_t BufferMemorySize,
                                 uint16_t* BufferEndOfFileP,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfFileP,
                              CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(const std::string& Filename,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_file_name(this, Filename.c_str(), CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(std::FILE* fh,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_FILE(this, fh, CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(std::istream* p_input_stream,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_istream(this, p_input_stream, CharacterEncodingName, ByteOrderReversionF); }


inline
Lexer::Lexer(std::wistream* p_input_stream,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_wistream(this, p_input_stream, CharacterEncodingName, ByteOrderReversionF); }
inline
Lexer::~Lexer()
{ Lexer_destruct(this); }

template<class InputHandleT> void
Lexer::reset(InputHandleT* input_handle, const char* CharacterEncodingName )
{ Lexer_reset(this, input_handle, CharacterEncodingName); }

inline uint16_t*
Lexer::reset_buffer(uint16_t* BufferMemoryBegin,
                          size_t BufferMemorySize,
                          uint16_t* BufferEndOfContentP,
                          const char* CharacterEncodingName )
{ return Lexer_reset_buffer(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP, CharacterEncodingName); }


}



namespace moritz {
    struct Lexer_Mode_tag;

    template <class InputHandleT> inline void
    Lexer_construct_basic(::moritz::Lexer* me,
                               InputHandleT* input_handle,
                               uint16_t* BufferMemory,
                               const size_t BufferMemorySize,
                               uint16_t* EndOfFileP,
                               const char* CharacterEncodingName,
                               const size_t TranslationBufferMemorySize,
                               bool ByteOrderReversionF)
    {





        if( ((uint16_t)0x0) == ((uint16_t)0x1) ) {
            do { throw std::runtime_error("Path termination code (PTC) and buffer limit code (BLC) must be different.\n"); } while(0);
        }
            me->token = &me->__memory_token;






        Lexer_Counter_construct(&me->counter);


        Lexer_Accumulator_construct(&me->accumulator, (::moritz::Lexer*)me);



        me->_parent_memento = 0x0;






        me->_mode_stack.end = me->_mode_stack.begin;
        me->_mode_stack.memory_end = me->_mode_stack.begin + (size_t)8;




        std::memset((uint8_t*)&me->buffer, 0xFF, sizeof(me->buffer));


        Lexer_Buffer_construct(&me->buffer, input_handle,
                                    BufferMemory, BufferMemorySize, EndOfFileP,
                                    CharacterEncodingName, TranslationBufferMemorySize,
                                    ByteOrderReversionF);

        if( input_handle == 0x0 ) {



            if( BufferMemory == 0x0 ) {

                Lexer_Buffer_end_of_file_set(&me->buffer, me->buffer._memory._front + 1);
            }


            ((me->buffer._memory._end_of_file_p > me->buffer._memory._front) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p > me->buffer._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 108, __PRETTY_FUNCTION__));
            ((me->buffer._memory._end_of_file_p <= me->buffer._memory._back) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p <= me->buffer._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 109, __PRETTY_FUNCTION__));
        }

        me->__file_handle_allocated_by_constructor = 0x0;
    }

    template <class InputHandleT> inline void
    Lexer_reset_basic(::moritz::Lexer* me,
                           InputHandleT* input_handle,
                           const char* CharacterEncodingName,
                           const size_t TranslationBufferMemorySize)

    {
        Lexer_Counter_reset(&me->counter);






        Lexer_include_stack_delete((::moritz::Lexer*)me);





        Lexer_Accumulator_clear(&me->accumulator);






        me->_mode_stack.end = me->_mode_stack.begin;
        me->_mode_stack.memory_end = me->_mode_stack.begin + (size_t)8;

        Lexer_Buffer_reset(&me->buffer, input_handle, CharacterEncodingName, TranslationBufferMemorySize);
    }


    inline void
    Lexer_destruct_basic(::moritz::Lexer* me)
    {





        Lexer_include_stack_delete((::moritz::Lexer*)me);





        Lexer_Accumulator_destruct(&me->accumulator);






        Lexer_Buffer_destruct(&me->buffer);

        if( me->__file_handle_allocated_by_constructor != 0x0 ) {
            std::fclose(me->__file_handle_allocated_by_constructor);
        }
    }





    inline void
    Lexer_buffer_reload_backward(Lexer_Buffer* buffer)
    {
        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 184, __PRETTY_FUNCTION__));
        ((buffer->filler != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->filler != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 185, __PRETTY_FUNCTION__));

        if( buffer->on_buffer_content_change != 0x0 ) {


            buffer->on_buffer_content_change(buffer->_memory._front,
                                             Lexer_Buffer_text_end(buffer));
        }

        (void)Lexer_BufferFiller_load_backward(buffer);
    }

    inline size_t
    Lexer___buffer_reload_forward_core(Lexer_Buffer* buffer)
    {
        size_t loaded_character_n = (size_t)-1;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 212, __PRETTY_FUNCTION__));
        ((buffer->filler != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->filler != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 213, __PRETTY_FUNCTION__));
        ((buffer->_memory._end_of_file_p == 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 214, __PRETTY_FUNCTION__));

        if( buffer->_memory._end_of_file_p != 0x0 ) {
            return 0;
        }

        if( buffer->on_buffer_content_change != 0x0 ) {



            buffer->on_buffer_content_change(buffer->_memory._front,
                                             buffer->_memory._back);
        }

        loaded_character_n = Lexer_BufferFiller_load_forward(buffer);
        return loaded_character_n;
    }

    inline void
    Lexer_buffer_reload_forward(Lexer_Buffer* buffer,
                                     Lexer_MemoryPositionMimiker* position_register,
                                     const size_t PositionRegisterN)
    {
        Lexer_MemoryPositionMimiker* iterator = 0x0;
        Lexer_MemoryPositionMimiker* End = position_register + (ptrdiff_t)PositionRegisterN;
        size_t loaded_character_n = (size_t)-1;

        loaded_character_n = Lexer___buffer_reload_forward_core(buffer);

        for(iterator = position_register; iterator != End; ++iterator) {


            *iterator -= (ptrdiff_t)loaded_character_n;
        }
    }


}


namespace moritz {

    inline uint32_t
    Lexer_Mode_uncallable_analyzer_function(::moritz::Lexer* me)
    {
        ((0) ? static_cast<void> (0) : __assert_fail ("0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Mode.i", 15, __PRETTY_FUNCTION__));
        (void)me;



        return (uint32_t)0;

    }


    inline void
    Lexer_Mode_on_indentation_null_function(::moritz::Lexer* me,
                                                 uint16_t* LexemeBegin,
                                                 uint16_t* LexemeEnd)
    { (void)me; (void)LexemeBegin; (void)LexemeEnd; }


    inline void
    Lexer_Mode_on_entry_exit_null_function(::moritz::Lexer* me,
                                                const Lexer_Mode* TheMode)
    { (void)me; (void)TheMode; }

}



namespace moritz {

    inline ptrdiff_t Lexer___BufferFiller_forward_compute_fallback_region(Lexer_Buffer* buffer,
                                                                                     const ptrdiff_t Distance_LexemeStart_to_InputP);
    inline ptrdiff_t Lexer___BufferFiller_backward_compute_backward_distance(Lexer_Buffer* buffer);

    inline void Lexer___BufferFiller_forward_copy_fallback_region(Lexer_Buffer*,
                                                                                  const ptrdiff_t FallBackN);
    inline void Lexer___BufferFiller_forward_adapt_pointers(Lexer_Buffer*,
                                                                            const ptrdiff_t DesiredLoadN,
                                                                            const size_t LoadedN,
                                                                            const ptrdiff_t FallBackN,
                                                                            const ptrdiff_t Distance_LexemeStart_to_InputP);
    inline void Lexer___BufferFiller_backward_copy_backup_region(Lexer_Buffer*,
                                                                                 const ptrdiff_t BackwardDistance);
    inline void Lexer___BufferFiller_backward_adapt_pointers(Lexer_Buffer*,
                                                                             const ptrdiff_t BackwardDistance);
    inline void Lexer___BufferFiller_on_overflow(Lexer_Buffer*, bool ForwardF);

    inline size_t Lexer___BufferFiller_read_characters(Lexer_Buffer*, uint16_t*,
                                                                     const ptrdiff_t);



    inline Lexer_Converter* Lexer___Converter_EMPTY_new() { return 0x0; }

    template <class InputHandleT> inline Lexer_BufferFiller*
    Lexer_BufferFiller_new(InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize)



    {
        (void)TranslationBufferMemorySize;

        if( CharacterEncodingName == 0x0 ) {

            std::printf("Warning: No character encoding name specified, while this\n"
                              "Warning: analyzer was generated for use with a converter.\n"
                              "Warning: Please, consult the documentation about the constructor\n"
                              "Warning: or the reset function. If it is desired to do a plain\n"
                              "Warning: buffer filler with this setup, you might want to disable\n"
                              "Warning: this warning with the macro:\n"
                              "Warning:     QUEX_OPTION_WARNING_ON_PLAIN_FILLER_DISABLED\n");

            return (Lexer_BufferFiller*)0x0;
        }

        if( Lexer_Converter_IConv_new == Lexer___Converter_EMPTY_new ) {
            do { throw std::runtime_error("Use of buffer filler type 'CharacterEncodingName' while " "'QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW' has not\n" "been defined (use --iconv, --icu, --converter-new to specify converter).\n"); } while(0)

                                                                                                         ;
        }





        return (Lexer_BufferFiller*)Lexer_BufferFiller_Converter_new(input_handle,
                                                                               Lexer_Converter_IConv_new(),
                                                                               CharacterEncodingName,
                                                                                                             0x0,
                                                                               TranslationBufferMemorySize);
    }
    inline void
    Lexer_BufferFiller_delete_self(Lexer_BufferFiller* me)
    {
        if( me->delete_self == 0x0 ) do { throw std::runtime_error("BufferFiller object did not specify 'delete_self()'\n"); } while(0);
        else me->delete_self(me);
    }

    inline void
    Lexer_BufferFiller_setup_functions(Lexer_BufferFiller* me,
                                            ptrdiff_t (*tell_character_index)(Lexer_BufferFiller*),
                                            void (*seek_character_index)(Lexer_BufferFiller*,
                                                                                 const ptrdiff_t),
                                            size_t (*read_characters)(Lexer_BufferFiller*,
                                                                            uint16_t*, const size_t),
                                            void (*delete_self)(Lexer_BufferFiller*))
    {
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 121, __PRETTY_FUNCTION__));
        ((tell_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("tell_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 122, __PRETTY_FUNCTION__));
        ((seek_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("seek_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 123, __PRETTY_FUNCTION__));
        ((read_characters != 0x0) ? static_cast<void> (0) : __assert_fail ("read_characters != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 124, __PRETTY_FUNCTION__));
        ((delete_self != 0x0) ? static_cast<void> (0) : __assert_fail ("delete_self != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 125, __PRETTY_FUNCTION__));


        me->tell_character_index = tell_character_index;
        me->seek_character_index = seek_character_index;
        me->read_characters = read_characters;
        me->_on_overflow = 0x0;
        me->delete_self = delete_self;
    }

    inline void
    Lexer_BufferFiller_initial_load(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);
        Lexer_BufferFiller* me = buffer->filler;
        size_t LoadedN = 0;


        ((buffer->_input_p == ContentFront) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == ContentFront", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 144, __PRETTY_FUNCTION__));
        ((buffer->_lexeme_start_p == ContentFront) ? static_cast<void> (0) : __assert_fail ("buffer->_lexeme_start_p == ContentFront", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 145, __PRETTY_FUNCTION__));







        me->seek_character_index(me, 0);

        LoadedN = Lexer___BufferFiller_read_characters(buffer, ContentFront, ContentSize);

        buffer->_content_character_index_begin = 0;
        buffer->_content_character_index_end = me->tell_character_index(buffer->filler);

        if( me->tell_character_index(me) != (ptrdiff_t)LoadedN )
            do { throw std::runtime_error("\nThe provided input stream behaves strangely. Number of read\n" "characters is not proportional to the stream position increase.\n" "The buffer filler type which you are using might be able to\n" "deal with those cases. Try compile option:\n" "\n" "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" "\n" "However, those mechanisms imply a trade-off in terms of speed.\n" "Please, consider using a 'binary' for your input stream, or use\n" "a different implementation of the standard I/O library (e.g.\n" "not Microsoft(tm)).\n"); } while(0);


        if( LoadedN != (size_t)ContentSize ) Lexer_Buffer_end_of_file_set(buffer, ContentFront + LoadedN);
        else Lexer_Buffer_end_of_file_unset(buffer);

        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);
    }

    inline size_t
    Lexer_BufferFiller_load_forward(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);
        ptrdiff_t Distance_LexemeStart_to_InputP = (ptrdiff_t)-1;
        ptrdiff_t FallBackN = (ptrdiff_t)-1;
        ptrdiff_t DesiredLoadN = (ptrdiff_t)-1;
        uint16_t* new_content_begin = 0x0;
        size_t LoadedN = (size_t)-1;
        Lexer_BufferFiller* me = buffer->filler;
        if( me == 0x0 ) return 0;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 211, __PRETTY_FUNCTION__));
        ((me->tell_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 212, __PRETTY_FUNCTION__));
        ((me->seek_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("me->seek_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 213, __PRETTY_FUNCTION__));
        ((me->read_characters != 0x0) ? static_cast<void> (0) : __assert_fail ("me->read_characters != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 214, __PRETTY_FUNCTION__));



        Distance_LexemeStart_to_InputP = buffer->_input_p - buffer->_lexeme_start_p;
        if( Distance_LexemeStart_to_InputP >= ContentSize ) {
            Lexer___BufferFiller_on_overflow(buffer, true);
            return 0;
        }
        ;


        if ( buffer->_input_p == buffer->_memory._front ) { return 0; }
        else if( buffer->_input_p == buffer->_memory._end_of_file_p ) { return 0; }
        else if( buffer->_input_p != buffer->_memory._back ) {
            do { throw std::runtime_error("Call to 'load_forward() but '_input_p' not on buffer border.\n" "(Check character encoding)"); } while(0)
                                                         ;
        }
        else if( buffer->_memory._end_of_file_p != 0x0 ) {

            return 0;
        }





        FallBackN = Lexer___BufferFiller_forward_compute_fallback_region(buffer,
                                                                                 Distance_LexemeStart_to_InputP);
        ((FallBackN < ContentSize) ? static_cast<void> (0) : __assert_fail ("FallBackN < ContentSize", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 243, __PRETTY_FUNCTION__));
        DesiredLoadN = ContentSize - FallBackN;

        Lexer___BufferFiller_forward_copy_fallback_region(buffer, FallBackN);





        me->seek_character_index(me, buffer->_content_character_index_end);
        buffer->_content_character_index_begin = buffer->_content_character_index_end - FallBackN;

        new_content_begin = ContentFront + FallBackN;
        LoadedN = Lexer___BufferFiller_read_characters(buffer,
                                                                       new_content_begin,
                                                                       DesiredLoadN);



        Lexer___BufferFiller_forward_adapt_pointers(buffer,
                                                         DesiredLoadN, LoadedN, FallBackN,
                                                         Distance_LexemeStart_to_InputP);

        buffer->_content_character_index_end = buffer->_content_character_index_begin
                                                 + (Lexer_Buffer_text_end(buffer) - ContentFront);




        if( (me->tell_character_index(me) - buffer->_content_character_index_begin - FallBackN) != (ptrdiff_t)LoadedN )
            do { throw std::runtime_error("\nThe provided input stream behaves strangely. Number of read\n" "characters is not proportional to the stream position increase.\n" "The buffer filler type which you are using might be able to\n" "deal with those cases. Try compile option:\n" "\n" "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" "\n" "However, those mechanisms imply a trade-off in terms of speed.\n" "Please, consider using a 'binary' for your input stream, or use\n" "a different implementation of the standard I/O library (e.g.\n" "not Microsoft(tm)).\n"); } while(0);

        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);


        return (size_t)DesiredLoadN;
    }

    inline ptrdiff_t
    Lexer___BufferFiller_forward_compute_fallback_region(Lexer_Buffer* buffer,
                                                              const ptrdiff_t Distance_LexemeStart_to_InputP)
    {
        ptrdiff_t FallBackN = (ptrdiff_t)-1;

        (void)buffer;
        ((buffer->_memory._end_of_file_p == 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 307, __PRETTY_FUNCTION__));
        ((buffer->_input_p == buffer->_memory._back) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == buffer->_memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 308, __PRETTY_FUNCTION__));
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        ((Distance_LexemeStart_to_InputP == buffer->_input_p - buffer->_lexeme_start_p) ? static_cast<void> (0) : __assert_fail ("Distance_LexemeStart_to_InputP == buffer->_input_p - buffer->_lexeme_start_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 310, __PRETTY_FUNCTION__));
        ((Distance_LexemeStart_to_InputP < (ptrdiff_t)Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("Distance_LexemeStart_to_InputP < (ptrdiff_t)Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 311, __PRETTY_FUNCTION__));


        FallBackN = (ptrdiff_t)(256) > Distance_LexemeStart_to_InputP
                    ? (ptrdiff_t)(256)
                    : Distance_LexemeStart_to_InputP;
        return FallBackN;
    }

    inline void
    Lexer___BufferFiller_forward_copy_fallback_region(Lexer_Buffer* buffer, const ptrdiff_t FallBackN)
    {



        uint16_t* source = Lexer_Buffer_content_back(buffer) - FallBackN + 1;
        uint16_t* drain = Lexer_Buffer_content_front(buffer);


        if( drain + FallBackN >= source ) {
            std::memmove((uint8_t*)drain, (uint8_t*)source, (size_t)FallBackN * sizeof(uint16_t));
        } else {
            std::memcpy((uint8_t*)drain, (uint8_t*)source, (size_t)FallBackN * sizeof(uint16_t));
        }



        std::memset((uint8_t*)(drain + FallBackN), (uint8_t)(0xFF),
                          (Lexer_Buffer_content_size(buffer) - (size_t)FallBackN)*sizeof(uint16_t));


        (((size_t)FallBackN < Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("(size_t)FallBackN < Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 342, __PRETTY_FUNCTION__));
    }

    inline void
    Lexer___BufferFiller_forward_adapt_pointers(Lexer_Buffer* buffer,
                                                     const ptrdiff_t DesiredLoadN,
                                                     const size_t LoadedN,
                                                     const ptrdiff_t FallBackN,
                                                     const ptrdiff_t Distance_LexemeStart_to_InputP)
    {
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);

        ((buffer->_memory._end_of_file_p == 0x0 || (LoadedN + (size_t)FallBackN) == Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0 || (LoadedN + (size_t)FallBackN) == Lexer_Buffer_content_size(buffer)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i"
        ,
 355
        , __PRETTY_FUNCTION__))
                                                                                                   ;
        ((DesiredLoadN != 0) ? static_cast<void> (0) : __assert_fail ("DesiredLoadN != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 356, __PRETTY_FUNCTION__));


        if( LoadedN != (size_t)DesiredLoadN )
            Lexer_Buffer_end_of_file_set(buffer, ContentFront + FallBackN + (ptrdiff_t)LoadedN);
        else
            Lexer_Buffer_end_of_file_unset(buffer);




        buffer->_input_p = ContentFront + FallBackN - 1;


        buffer->_lexeme_start_p = (buffer->_input_p + 1) - Distance_LexemeStart_to_InputP;


        ((buffer->_memory._end_of_file_p == 0x0 || ((ptrdiff_t)LoadedN + FallBackN) == buffer->_memory._end_of_file_p - buffer->_memory._front - 1) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0 || ((ptrdiff_t)LoadedN + FallBackN) == buffer->_memory._end_of_file_p - buffer->_memory._front - 1",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i"
        ,
 374
        , __PRETTY_FUNCTION__))
                                                                                                                         ;

    }


    inline size_t
    Lexer_BufferFiller_load_backward(Lexer_Buffer* buffer)
    {
        Lexer_BufferFiller* me = buffer->filler;
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint16_t* ContentBack = Lexer_Buffer_content_back(buffer);
        ptrdiff_t BackwardDistance = (ptrdiff_t)-1;
        ptrdiff_t NewContentCharacterIndexBegin = (ptrdiff_t)-1;

        size_t LoadedN = (size_t)-1;





        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);

        if( me == 0x0 ) return 0;
        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 433, __PRETTY_FUNCTION__));
        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);


        if ( buffer->_input_p == buffer->_memory._back ) { return 0; }
        else if( buffer->_input_p == buffer->_memory._end_of_file_p ) { return 0; }
        else if( buffer->_input_p != buffer->_memory._front ) {
            do { throw std::runtime_error("Call to 'load_backward() but '_input_p' not on buffer border.\n" "(Check character encoding)"); } while(0)
                                                         ;
        }
        else if( buffer->_content_character_index_begin == 0 ) { return 0; }





        if( buffer->_lexeme_start_p == ContentBack ) {
            Lexer___BufferFiller_on_overflow(buffer, false);
            return 0;
        }



        BackwardDistance = Lexer___BufferFiller_backward_compute_backward_distance(buffer);






        NewContentCharacterIndexBegin = buffer->_content_character_index_begin - BackwardDistance;
        ((BackwardDistance != 0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 465, __PRETTY_FUNCTION__));
        me->seek_character_index(me, NewContentCharacterIndexBegin);



        buffer->_content_character_index_begin = NewContentCharacterIndexBegin;
        Lexer___BufferFiller_backward_copy_backup_region(buffer, BackwardDistance);






        LoadedN =



        Lexer___BufferFiller_read_characters(buffer, ContentFront, BackwardDistance);
        ((LoadedN == (size_t)BackwardDistance) ? static_cast<void> (0) : __assert_fail ("LoadedN == (size_t)BackwardDistance", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 483, __PRETTY_FUNCTION__));



        Lexer___BufferFiller_backward_adapt_pointers(buffer, BackwardDistance);

        buffer->_content_character_index_end = buffer->_content_character_index_begin
                                               + (Lexer_Buffer_text_end(buffer) - ContentFront);



        (((size_t)(me->tell_character_index(me) - buffer->_content_character_index_begin) == LoadedN) ? static_cast<void> (0) : __assert_fail ("(size_t)(me->tell_character_index(me) - buffer->_content_character_index_begin) == LoadedN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 494, __PRETTY_FUNCTION__));

        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);

        return (size_t)BackwardDistance;
    }


    inline ptrdiff_t
    Lexer___BufferFiller_backward_compute_backward_distance(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        ptrdiff_t IntendedBackwardDistance = (ptrdiff_t)-1;
        ptrdiff_t Distance_InputP_to_LexemeStart = (ptrdiff_t)-1;
        ptrdiff_t LimitBackwardDist_1 = -1;
        ptrdiff_t LimitBackwardDist_2 = -1;
        ptrdiff_t Limit_1_and_2 = -1;
        ptrdiff_t BackwardDistance = -1;

        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);


        ((buffer->_input_p == buffer->_memory._front) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == buffer->_memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 518, __PRETTY_FUNCTION__));


        ((buffer->_content_character_index_begin != 0) ? static_cast<void> (0) : __assert_fail ("buffer->_content_character_index_begin != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 521, __PRETTY_FUNCTION__));




        ((buffer->_lexeme_start_p > buffer->_input_p) ? static_cast<void> (0) : __assert_fail ("buffer->_lexeme_start_p > buffer->_input_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 526, __PRETTY_FUNCTION__));
        (((size_t)(buffer->_lexeme_start_p - buffer->_input_p) < Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->_lexeme_start_p - buffer->_input_p) < Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 527, __PRETTY_FUNCTION__));

        IntendedBackwardDistance = ContentSize > (ptrdiff_t)3 ? (ptrdiff_t)(ContentSize / 3)
                                   : (ptrdiff_t)1;
        Distance_InputP_to_LexemeStart = buffer->_lexeme_start_p - buffer->_input_p;
        LimitBackwardDist_1 = ContentSize - Distance_InputP_to_LexemeStart;




        LimitBackwardDist_2 = buffer->_content_character_index_begin;




        Limit_1_and_2 = LimitBackwardDist_1 < LimitBackwardDist_2 ? LimitBackwardDist_1
                        : LimitBackwardDist_2;

        BackwardDistance = IntendedBackwardDistance < Limit_1_and_2 ? IntendedBackwardDistance
                           : Limit_1_and_2;

        ((BackwardDistance > (ptrdiff_t)0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance > (ptrdiff_t)0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 564, __PRETTY_FUNCTION__));
        return (ptrdiff_t)BackwardDistance;
    }

    inline void
    Lexer___BufferFiller_backward_copy_backup_region(Lexer_Buffer* buffer,
                                                          const ptrdiff_t BackwardDistance)
    {
        const size_t ContentSize = Lexer_Buffer_content_size(buffer);
        uint16_t* ContentFront = Lexer_Buffer_content_front(buffer);

        ((BackwardDistance >= (ptrdiff_t)0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance >= (ptrdiff_t)0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 575, __PRETTY_FUNCTION__));
        (((size_t)BackwardDistance < ContentSize) ? static_cast<void> (0) : __assert_fail ("(size_t)BackwardDistance < ContentSize", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 576, __PRETTY_FUNCTION__));



        std::memmove(ContentFront + BackwardDistance, ContentFront,
                           (size_t)(ContentSize - (size_t)BackwardDistance)*sizeof(uint16_t));



        std::memset((uint8_t*)ContentFront, (uint8_t)(0xFF),
                          (size_t)BackwardDistance * sizeof(uint16_t));

    }

    inline void
    Lexer___BufferFiller_backward_adapt_pointers(Lexer_Buffer* buffer,
                                                      const ptrdiff_t BackwardDistance)
    {

        if( buffer->_memory._end_of_file_p ) {
            uint16_t* NewEndOfFileP = buffer->_memory._end_of_file_p + BackwardDistance;
            if( NewEndOfFileP <= buffer->_memory._back )
                Lexer_Buffer_end_of_file_set(buffer, NewEndOfFileP);
            else
                Lexer_Buffer_end_of_file_unset(buffer);
        }

        buffer->_input_p += BackwardDistance + 1;
        buffer->_lexeme_start_p += BackwardDistance;
    }

    inline void
    Lexer___BufferFiller_on_overflow(Lexer_Buffer* buffer, bool ForwardF)
    {
        Lexer_BufferFiller* me = buffer->filler;
        if( me->_on_overflow == 0x0
            || me->_on_overflow(buffer, ForwardF) == false ) {
            do { throw std::runtime_error("Distance between lexeme start and current pointer exceeds buffer size.\n" "(tried to load buffer forward). Please, compile with option\n\n" "    QUEX_OPTION_INFORMATIVE_BUFFER_OVERFLOW_MESSAGE\n\n" "in order to get a more informative output. Most likely, one of your patterns\n" "eats longer as you inteded it. Alternatively you might want to set the buffer\n" "size to a greate value or use skippers (<skip: [ \\n\\t]> for example).\n"); } while(0)




                                                                                                        ;

        }
    }

    inline void
    Lexer_BufferFiller_step_forward_n_characters(Lexer_BufferFiller* me,
                                                      const ptrdiff_t ForwardN)
    {
        const ptrdiff_t TargetIndex = me->tell_character_index(me) + ForwardN;





        size_t remaining_character_n = (size_t)ForwardN;
        const size_t ChunkSize = (512);
        uint16_t chunk[(512)];

        (((512) >= 1) ? static_cast<void> (0) : __assert_fail ("(512) >= 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 679, __PRETTY_FUNCTION__));






        for(; remaining_character_n > ChunkSize; remaining_character_n -= ChunkSize )
            if( me->read_characters(me, (uint16_t*)chunk, ChunkSize) < ChunkSize ) {
                ((me->tell_character_index(me) <= TargetIndex) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index(me) <= TargetIndex", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 688, __PRETTY_FUNCTION__));
                return;
            }
        if( remaining_character_n )
            me->read_characters(me, (uint16_t*)chunk, remaining_character_n);

        ((me->tell_character_index(me) <= TargetIndex) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index(me) <= TargetIndex", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 694, __PRETTY_FUNCTION__));
    }

    inline size_t
    Lexer___BufferFiller_read_characters(Lexer_Buffer* buffer,
                                              uint16_t* memory,
                                              const ptrdiff_t CharacterNToRead)
    {
        const size_t LoadedN = buffer->filler->read_characters(buffer->filler, memory, (size_t)CharacterNToRead);

        if( buffer->_byte_order_reversion_active_f ) {
            Lexer_Buffer_reverse_byte_order(memory, memory + LoadedN);
        }
        return LoadedN;
    }

}



    struct __Adapter_FuncIconv_SecondArgument {
        __Adapter_FuncIconv_SecondArgument(uint8_t ** in) : data(in) {}
        uint8_t ** data;
        operator const char **(void) const { return (const char **)(data); }
        operator char **(void) const { return ( char **)(data); }
    };



namespace moritz {
    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_construct(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                                InputHandleT* input_handle,
                                                Lexer_Converter* converter,
                                                const char* FromCoding,
                                                const char* ToCoding,
                                                size_t RawBufferSize);
    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_init(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                           InputHandleT* input_handle,
                                           Lexer_Converter* converter,
                                           const char* FromCoding,
                                           const char* ToCoding,
                                           size_t RawBufferSize);
    template <class InputHandleT> inline ptrdiff_t
    Lexer_BufferFiller_Converter_tell_character_index(Lexer_BufferFiller* alter_ego);

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_seek_character_index(Lexer_BufferFiller* alter_ego,
                                                           const ptrdiff_t CharacterIndex);
    template <class InputHandleT> inline size_t
    Lexer_BufferFiller_Converter_read_characters(Lexer_BufferFiller* alter_ego,
                                                      uint16_t* start_of_buffer,
                                                      const size_t N);
    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_delete_self(Lexer_BufferFiller* alter_ego);

    template <class InputHandleT> inline size_t
    Lexer___BufferFiller_Converter_fill_raw_buffer(Lexer_BufferFiller_Converter<InputHandleT>* me);

    template <class InputHandleT> inline void
    Lexer_RawBuffer_init(Lexer_RawBuffer<InputHandleT>* me,
                              uint8_t* Begin, size_t SizeInBytes,
                              typename InputPolicy<InputHandleT*>::stream_position StartPosition);

    template <class InputHandleT> inline Lexer_BufferFiller_Converter<InputHandleT>*
    Lexer_BufferFiller_Converter_new(InputHandleT* input_handle,
                                          Lexer_Converter* converter,
                                          const char* FromCoding,
                                          const char* ToCoding,
                                          size_t RawBufferSize)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)0x0;
        ((RawBufferSize >= 6) ? static_cast<void> (0) : __assert_fail ("RawBufferSize >= 6", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 63, __PRETTY_FUNCTION__));

        me = (Lexer_BufferFiller_Converter<InputHandleT>*)
 Lexer_MemoryManager_BufferFiller_allocate(sizeof(Lexer_BufferFiller_Converter<InputHandleT>));
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 67, __PRETTY_FUNCTION__));

        Lexer_BufferFiller_Converter_construct(me, input_handle, converter, FromCoding, ToCoding, RawBufferSize);

        return me;

    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_construct(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                                InputHandleT* input_handle,
                                                Lexer_Converter* converter,
                                                const char* FromCoding,
                                                const char* ToCoding,
                                                size_t RawBufferSize)
    {
        Lexer_BufferFiller_setup_functions(&me->base,
                                                Lexer_BufferFiller_Converter_tell_character_index<InputHandleT>,
                                                Lexer_BufferFiller_Converter_seek_character_index<InputHandleT>,
                                                Lexer_BufferFiller_Converter_read_characters<InputHandleT>,
                                                Lexer_BufferFiller_Converter_delete_self<InputHandleT>);

        Lexer_BufferFiller_Converter_init(me, input_handle, converter, FromCoding, ToCoding, RawBufferSize);
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_init(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                           InputHandleT* input_handle,
                                           Lexer_Converter* converter,
                                           const char* FromCoding,
                                           const char* ToCoding,
                                           size_t RawBufferSize)
    {
        uint8_t* raw_buffer_p = 0x0;

        me->ih = input_handle;


        me->converter = converter;
        me->converter->open(me->converter, FromCoding, ToCoding);



        if( me->ih != 0x0 ) {
            me->start_position = InputPolicy<InputHandleT*>::tell((me->ih));
        } else {
            me->start_position = 0;
        }



        raw_buffer_p = Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(RawBufferSize);
        Lexer_RawBuffer_init(&me->raw_buffer, raw_buffer_p, RawBufferSize,
                                  me->start_position);


        me->hint_begin_character_index = (ptrdiff_t)-1;


        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__));;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_reset(Lexer_BufferFiller_Converter<InputHandleT>* me, InputHandleT* input_handle)
    {
        (void)me;
        (void)input_handle;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_delete_self(Lexer_BufferFiller* alter_ego)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__));;

        me->converter->delete_self(me->converter);

        Lexer_MemoryManager_BufferFiller_RawBuffer_free(me->raw_buffer.begin);

        Lexer_MemoryManager_BufferFiller_free((void*)me);
    }


    template <class InputHandleT> inline size_t
    Lexer_BufferFiller_Converter_read_characters(Lexer_BufferFiller* alter_ego,
                                                      uint16_t* user_memory_p,
                                                      const size_t N)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        uint16_t* user_buffer_iterator = user_memory_p;
        const uint16_t* UserBufferEnd = user_memory_p + N;
        const ptrdiff_t StartCharacterIndex = me->raw_buffer.iterators_character_index;
        ptrdiff_t ConvertedCharN = 0;

        ((me->converter != 0x0) ? static_cast<void> (0) : __assert_fail ("me->converter != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 186, __PRETTY_FUNCTION__));
        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 187, __PRETTY_FUNCTION__));
        ((user_memory_p != 0x0) ? static_cast<void> (0) : __assert_fail ("user_memory_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 188, __PRETTY_FUNCTION__));
        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__));;

        std::memset((uint8_t*)user_memory_p, 0xFF, N * sizeof(uint16_t));


        while( ! me->converter->convert(me->converter,
                                        &me->raw_buffer.iterator, me->raw_buffer.end,
                                        &user_buffer_iterator, UserBufferEnd) ) {

            ((user_buffer_iterator < UserBufferEnd) ? static_cast<void> (0) : __assert_fail ("user_buffer_iterator < UserBufferEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 198, __PRETTY_FUNCTION__));
            ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__));;


            me->raw_buffer.iterators_character_index = StartCharacterIndex
                                                       + (user_buffer_iterator - user_memory_p);

            if( Lexer___BufferFiller_Converter_fill_raw_buffer(me) == 0 ) {

                if( me->raw_buffer.end != me->raw_buffer.begin )

                    do { throw std::runtime_error("Error. At end of file, byte sequence not interpreted as character."); } while(0);
                break;
            }
        }

        ConvertedCharN = user_buffer_iterator - user_memory_p;
        me->raw_buffer.iterators_character_index = StartCharacterIndex + ConvertedCharN;

        if( ConvertedCharN != (ptrdiff_t)N ) {


            ((UserBufferEnd >= user_buffer_iterator) ? static_cast<void> (0) : __assert_fail ("UserBufferEnd >= user_buffer_iterator", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 220, __PRETTY_FUNCTION__));

            std::memset((uint8_t*)(user_buffer_iterator), (uint8_t)0xFF,
                              (size_t)(UserBufferEnd - user_buffer_iterator) * sizeof(uint16_t));

        }
        return (size_t)ConvertedCharN;
    }

    template <class InputHandleT> inline ptrdiff_t
    Lexer_BufferFiller_Converter_tell_character_index(Lexer_BufferFiller* alter_ego)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 233, __PRETTY_FUNCTION__));
        ((me->converter != 0x0) ? static_cast<void> (0) : __assert_fail ("me->converter != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 234, __PRETTY_FUNCTION__));



        return me->raw_buffer.iterators_character_index;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_seek_character_index(Lexer_BufferFiller* alter_ego,
                                                           const ptrdiff_t Index)
    {







        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        Lexer_RawBuffer<InputHandleT>* buffer = &me->raw_buffer;

        const ptrdiff_t Hint_Index = me->hint_begin_character_index;
        uint8_t* Hint_Pointer = buffer->begin;
        ptrdiff_t ContentSize = 0;
        ptrdiff_t EndIndex = 0;
        uint8_t* new_iterator = 0;

        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 261, __PRETTY_FUNCTION__));
        ((me->converter != 0x0) ? static_cast<void> (0) : __assert_fail ("me->converter != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 262, __PRETTY_FUNCTION__));







        if( Index == buffer->iterators_character_index ) {
            return;
        }



        if( me->converter->on_conversion_discontinuity != 0x0 )
            me->converter->on_conversion_discontinuity(me->converter);
        if( me->converter->dynamic_character_size_f == false ) {

            ((buffer->end >= buffer->begin) ? static_cast<void> (0) : __assert_fail ("buffer->end >= buffer->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 290, __PRETTY_FUNCTION__));
            ContentSize = buffer->end - buffer->begin;
            EndIndex = Hint_Index + (ContentSize / (ptrdiff_t)sizeof(uint16_t));

            if( Index >= Hint_Index && Index < EndIndex && Hint_Index != (ptrdiff_t)-1 ) {
                new_iterator = buffer->begin + (Index - Hint_Index) * (ptrdiff_t)sizeof(uint16_t);
                buffer->iterator = new_iterator;
                buffer->iterators_character_index = Index;
            }
            else {
                typename InputPolicy<InputHandleT*>::stream_position avoid_tmp_arg =
                    (typename InputPolicy<InputHandleT*>::stream_position)((size_t)Index * sizeof(uint16_t))
                    + me->start_position;

                if( me->ih != 0x0 ) {
                    InputPolicy<InputHandleT*>::seek((me->ih), (avoid_tmp_arg));
                }
                buffer->end_stream_position = avoid_tmp_arg;

                buffer->iterator = buffer->end;
                buffer->iterators_character_index = Index;
            }
        }
        else {




            if( Index == Hint_Index && Hint_Index != (ptrdiff_t)-1 ) {



                buffer->iterators_character_index = Index;
                buffer->iterator = Hint_Pointer;
            }
            else if( Index > Hint_Index && Hint_Index != (ptrdiff_t)-1 ) {



                buffer->iterators_character_index = Hint_Index;
                buffer->iterator = Hint_Pointer;
                Lexer_BufferFiller_step_forward_n_characters((Lexer_BufferFiller*)me,
                                                                  Index - Hint_Index);

            }
            else {





                if( me->ih != 0x0 ) {
                    InputPolicy<InputHandleT*>::seek((me->ih), (me->start_position));
                }
                buffer->end_stream_position = me->start_position;

                buffer->end = buffer->begin;

                buffer->iterator = buffer->end;
                buffer->iterators_character_index = 0;
                Lexer_BufferFiller_step_forward_n_characters((Lexer_BufferFiller*)me, Index);

                ((buffer->iterators_character_index == Index) ? static_cast<void> (0) : __assert_fail ("buffer->iterators_character_index == Index", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 352, __PRETTY_FUNCTION__));
            }
        }
        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__));;
    }

    template <class InputHandleT> inline size_t
    Lexer___BufferFiller_Converter_fill_raw_buffer(Lexer_BufferFiller_Converter<InputHandleT>* me)
    {



       Lexer_RawBuffer<InputHandleT>* buffer = &me->raw_buffer;
       const size_t RemainingBytesN = (size_t)(buffer->end - buffer->iterator);
       uint8_t* FillStartPosition = 0;
       size_t FillSize = 0;
       size_t LoadedByteN = 0;

       ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__));;
       (((size_t)(buffer->end - buffer->begin) >= RemainingBytesN) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->end - buffer->begin) >= RemainingBytesN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 371, __PRETTY_FUNCTION__));

       if( me->ih != 0x0 ) {
           ((buffer->end_stream_position == InputPolicy<InputHandleT*>::tell((me->ih))) ? static_cast<void> (0) : __assert_fail ("buffer->end_stream_position == InputPolicy<InputHandleT*>::tell((me->ih))", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 374, __PRETTY_FUNCTION__));
       }
       if( me->converter->on_conversion_discontinuity == 0x0 )
           me->hint_begin_character_index = buffer->iterators_character_index;




       if( RemainingBytesN != 0 ) {



           std::memmove((uint8_t*)(buffer->begin), (uint8_t*)(buffer->iterator), RemainingBytesN);
       }

       FillStartPosition = buffer->begin + RemainingBytesN;
       FillSize = (size_t)(buffer->memory_end - buffer->begin) - RemainingBytesN;

       if( me->ih != 0x0 ) {
           LoadedByteN = InputPolicy<InputHandleT*>::load_bytes((me->ih), (uint8_t*)(FillStartPosition), (FillSize))
                                                                                  ;
       }



       if( me->ih != 0x0 ) {
           buffer->end_stream_position = InputPolicy<InputHandleT*>::tell((me->ih));
       }



       buffer->iterator = buffer->begin;
       buffer->end = buffer->begin + LoadedByteN + RemainingBytesN;


       ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__));;

       return LoadedByteN;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_move_away_passed_content(Lexer_BufferFiller_Converter<InputHandleT>* me)

    {
        Lexer_RawBuffer<InputHandleT>* buffer = &me->raw_buffer;
        const size_t RemainingBytesN = (size_t)(buffer->end - buffer->iterator);

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__));;
        (((size_t)(buffer->end - buffer->begin) >= RemainingBytesN) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->end - buffer->begin) >= RemainingBytesN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 439, __PRETTY_FUNCTION__));




        if( RemainingBytesN != 0 ) {



            std::memmove((uint8_t*)(buffer->begin), (uint8_t*)(buffer->iterator), RemainingBytesN);
        }


        buffer->iterator = buffer->begin;
        buffer->end = buffer->begin + RemainingBytesN;

        (((size_t)(buffer->memory_end - buffer->begin) >= RemainingBytesN) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->memory_end - buffer->begin) >= RemainingBytesN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 455, __PRETTY_FUNCTION__));
        std::memset((uint8_t*)(buffer->begin) + RemainingBytesN, 0xFF,
                          (size_t)(buffer->memory_end - buffer->begin) - RemainingBytesN);


        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__));;
    }

    template <class InputHandleT> inline void
    Lexer_RawBuffer_init(Lexer_RawBuffer<InputHandleT>* me,
                              uint8_t* Begin, size_t SizeInBytes,
                              typename InputPolicy<InputHandleT*>::stream_position StartPosition)
    {
        me->begin = Begin;

        me->end = Begin;
        me->end_stream_position = StartPosition;

        me->memory_end = Begin + (ptrdiff_t)SizeInBytes;

        me->iterator = me->end;
        me->iterators_character_index = 0;



        std::memset((uint8_t*)Begin, (uint8_t)0xFF, SizeInBytes);

    }

}










extern "C" {


}

namespace moritz {

    inline void
    Lexer_Converter_IConv_open(Lexer_Converter_IConv* me,
                                    const char* FromCoding, const char* ToCoding)
    {

        me->base.dynamic_character_size_f = true;


        if( ToCoding == 0 ) {
            switch( sizeof(uint16_t) ) {
            default: ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/iconv/Converter_IConv.i", 36, __PRETTY_FUNCTION__)); return;

            case 4: me->handle = iconv_open("UCS-4LE", FromCoding); break;
            case 2: me->handle = iconv_open("UCS-2LE", FromCoding); break;







            case 1: me->handle = iconv_open("ASCII", FromCoding); break;
            }
        } else {
            me->handle = iconv_open(ToCoding, FromCoding);
        }

        if( me->handle == (iconv_t)-1 ) {


            do { throw std::runtime_error("<<IConv conversion: source or target character encoding name unknown.>>"); } while(0);
        }
    }

    inline bool
    Lexer_Converter_IConv_convert(Lexer_Converter_IConv* me,
                                       uint8_t** source, const uint8_t* SourceEnd,
                                       uint16_t** drain, const uint16_t* DrainEnd)
    {
        size_t source_bytes_left_n = (size_t)(SourceEnd - *source);
        size_t drain_bytes_left_n = (size_t)(DrainEnd - *drain)*sizeof(uint16_t);

        size_t report = iconv(me->handle,
                              (__Adapter_FuncIconv_SecondArgument(source)), &source_bytes_left_n,
                              (char**)drain, &drain_bytes_left_n);

        if( report != (size_t)-1 ) {
            ((source_bytes_left_n == 0) ? static_cast<void> (0) : __assert_fail ("source_bytes_left_n == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/iconv/Converter_IConv.i", 89, __PRETTY_FUNCTION__));


            if( drain_bytes_left_n == 0 ) {
                ((*drain == DrainEnd) ? static_cast<void> (0) : __assert_fail ("*drain == DrainEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/iconv/Converter_IConv.i", 93, __PRETTY_FUNCTION__));
                return true;
            }





            if( *source != SourceEnd ) {

                return true;
            }
            else {


                return false;
            }
        }

        switch( (*__errno_location ()) ) {
        default:
            do { throw std::runtime_error("Unexpected setting of 'errno' after call to GNU's iconv()."); } while(0);

        case 84:
            do { throw std::runtime_error("Invalid byte sequence encountered for given character coding."); } while(0);

        case 22:






            if( *drain == DrainEnd ) return true;
            else return false;

        case 7:


            return true;
        }
    }

    inline void
    Lexer_Converter_IConv_delete_self(Lexer_Converter_IConv* me)
    {
        iconv_close(me->handle);
        Lexer_MemoryManager_Converter_free(me);
    }

    inline Lexer_Converter*
    Lexer_Converter_IConv_new()
    {
        Lexer_Converter_IConv* me =
           (Lexer_Converter_IConv*)Lexer_MemoryManager_Converter_allocate(sizeof(Lexer_Converter_IConv));

        me->base.open = (Lexer_ConverterFunctionP_open)Lexer_Converter_IConv_open;
        me->base.convert = (Lexer_ConverterFunctionP_convert)Lexer_Converter_IConv_convert;
        me->base.delete_self = (Lexer_ConverterFunctionP_delete_self)Lexer_Converter_IConv_delete_self;
        me->base.on_conversion_discontinuity = 0x0;

        me->handle = (iconv_t)-1;

        return (Lexer_Converter*)me;
    }

}













namespace moritz {

    inline void
    Lexer_Counter_init(Lexer_Counter* me)
    {
        me->_line_number_at_begin = (size_t)0;
        me->_line_number_at_end = (size_t)1;
        me->_column_number_at_begin = (size_t)0;
        me->_column_number_at_end = (size_t)1;
        ;
    }

    inline void
    Lexer_Counter_construct(Lexer_Counter* me)
    {

        memset((void*)me, 0xFF, sizeof(Lexer_Counter));

        Lexer_Counter_init((Lexer_Counter*)me);
    }

    inline void
    Lexer_Counter_reset(Lexer_Counter* me)
    {
        Lexer_Counter_init((Lexer_Counter*)me);
    }

    inline void
    Lexer_Counter_count(Lexer_Counter* me,
                             uint16_t* Begin, uint16_t* End)






    {


        uint16_t* it = Lexer_Counter_count_chars_to_newline_backwards(me, Begin, End);
        if( *it == '\n' ) ++(me->_line_number_at_end);






        ((it >= Begin) ? static_cast<void> (0) : __assert_fail ("it >= Begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 55, __PRETTY_FUNCTION__));


        while( it != Begin ) {
            --it;
            if( *it == '\n' ) ++(me->_line_number_at_end);
        }



    }

    inline void
    Lexer_Counter_count_FixNewlineN(Lexer_Counter* me,
                                                   uint16_t* Lexeme,
                                                   uint16_t* LexemeEnd,
                                                   const int LineNIncrement)
    {
        ((LexemeEnd > Lexeme) ? static_cast<void> (0) : __assert_fail ("LexemeEnd > Lexeme", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 73, __PRETTY_FUNCTION__));


        Lexer_Counter_count_chars_to_newline_backwards(me, (uint16_t*)Lexeme,
                                                            (uint16_t*)(LexemeEnd));

        me->_line_number_at_end += (size_t)LineNIncrement;
    }


    inline uint16_t*
    Lexer_Counter_count_chars_to_newline_backwards(Lexer_Counter* me,
                                                        uint16_t* Begin,
                                                        uint16_t* End)
    {
        uint16_t* it = 0x0;

        ((Begin < End) ? static_cast<void> (0) : __assert_fail ("Begin < End", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 103, __PRETTY_FUNCTION__));
        for(it = End - 1; *it != '\n' ; --it) {
            if( it == Begin ) {




                me->_column_number_at_end += (size_t)(End - Begin);
                return it;
            }
        }

        ((End >= it) ? static_cast<void> (0) : __assert_fail ("End >= it", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 123, __PRETTY_FUNCTION__));


        me->_column_number_at_end = (size_t)(End - it);

        return it;
    }

    inline void
    Lexer_Counter_print_this(Lexer_Counter* me)
    {
        ;

        std::printf("   Counter:\n");

        std::printf("   _line_number_at_begin = %i;\n", (int)me->_line_number_at_begin);
        std::printf("   _line_number_at_end   = %i;\n", (int)me->_line_number_at_end);


        std::printf("   _column_number_at_begin = %i;\n", (int)me->_column_number_at_begin);
        std::printf("   _column_number_at_end   = %i;\n", (int)me->_column_number_at_end);
    }
}



namespace moritz {

    template <class InputHandleT> inline void
    Lexer_include_push(::moritz::Lexer* me,
                            InputHandleT* Optional_InputHandle,
                            uint16_t* Optional_InputName,
                            const Lexer_Mode* Mode,
                            const char* CharacterCodecName )
    {



        InputHandleT* input_handle = Optional_InputHandle;

        Lexer_Memento* m = Lexer_memento_pack<InputHandleT>(me, Optional_InputName, &input_handle);




        if( input_handle == 0x0 ) {
            do { throw std::runtime_error("Segment 'memento_pack' segment did not set the input_handle."); } while(0);
        }




        Lexer_Buffer_construct(&me->buffer, input_handle,
                                    0x0, 65536, 0x0,
                                    CharacterCodecName, ((size_t)65536),
                                    me->buffer._byte_order_reversion_active_f);


        if( Mode != 0x0 ) Lexer_set_mode_brutally(me, (Lexer_Mode*)Mode);
        Lexer_Counter_construct(&me->counter);



        Lexer_Accumulator_construct(&me->accumulator, me);




        me->__file_handle_allocated_by_constructor = 0x0;


        me->_parent_memento = m;
    }

    template <class InputHandleT> inline void
    Lexer_include_push_input_name(::moritz::Lexer* me,
                                       uint16_t* InputName,
                                       const Lexer_Mode* mode,
                                       const char* CharacterCodecName )
    {



        Lexer_include_push<InputHandleT>(me, 0x0, InputName, mode, CharacterCodecName);



    }

    template <class InputHandleT> inline void
    Lexer_include_push_input_handle(::moritz::Lexer* me,
                                         InputHandleT* sh,
                                         const Lexer_Mode* mode,
                                         const char* CharacterCodecName )
    {


        Lexer_include_push<InputHandleT>(me, sh, 0x0, mode, CharacterCodecName);



    }

    inline bool
    Lexer_include_pop(::moritz::Lexer* me)
    {

        if( me->_parent_memento == 0x0 ) return false;



        Lexer_Buffer_destruct(&me->buffer);
        Lexer_Accumulator_destruct(&me->accumulator);







        Lexer_memento_unpack(me, me->_parent_memento);


        return true;
    }

    inline void
    Lexer_include_stack_delete(::moritz::Lexer* me)
    {
        while( me->_parent_memento != 0x0 ) {
            if( Lexer_include_pop(me) == false ) {
                do { throw std::runtime_error("Error during deletion of include stack."); } while(0);
            }
        }
    }


    template <class InputHandleT> inline void
    Lexer::include_push(InputHandleT* sh,
                              const Lexer_Mode* Mode,
                              const char* CharacterCodecName )
    { Lexer_include_push_input_handle<InputHandleT>(this, sh, Mode, CharacterCodecName); }

    template <class InputHandleT> inline void
    Lexer::include_push(uint16_t* InputName,
                              const Lexer_Mode* Mode,
                              const char* CharacterCodecName )
    { Lexer_include_push_input_name<InputHandleT>(this, InputName, Mode, CharacterCodecName); }

    inline bool
    Lexer::include_pop()
    { return Lexer_include_pop(this); }

    inline void
    Lexer::include_stack_delete()
    { Lexer_include_stack_delete(this); }


}




namespace moritz {

inline void
Lexer_Accumulator_construct(Lexer_Accumulator* me,
                                 ::moritz::Lexer* lexer)
{
    me->the_lexer = lexer;
    Lexer_Accumulator_init_memory(me);
    me->_begin_line = 0;
    me->_begin_column = 0;
}


inline void
Lexer_Accumulator_destruct(Lexer_Accumulator* me)
{
    if( me->text.begin != 0x0 ) {
        Lexer_MemoryManager_Text_free(me->text.begin);
    }
    me->the_lexer = 0x0;
    me->text.begin = 0x0;
    me->text.end = 0x0;
    me->text.memory_end = 0x0;
}

inline void
Lexer_Accumulator_init_memory(Lexer_Accumulator* me)
{
    if( (256) == 0 ) {
        me->text.begin = 0x0;
    } else {
        me->text.begin =
 Lexer_MemoryManager_Text_allocate(
                      (256) * sizeof(uint16_t));
        if( me->text.begin == 0x0 ) {
            do { throw std::runtime_error("Quex engine: out of memory--cannot allocate Accumulator."); } while(0);
        }
    }
    me->text.end = me->text.begin;
    me->text.memory_end = me->text.begin + (256);
}

inline bool
Lexer_Accumulator_extend(Lexer_Accumulator* me, size_t MinAddSize)
{
    const size_t OldContentSize = (size_t)(me->text.end - me->text.begin);
    const size_t Size = (size_t)(me->text.memory_end - me->text.begin);
    const size_t AddSize = (size_t)((float)Size * (float)(0.8));
    const size_t NewSize = Size + (AddSize < MinAddSize ? MinAddSize : AddSize);

    uint16_t* chunk =
 Lexer_MemoryManager_Text_allocate(NewSize*sizeof(uint16_t));

    if( chunk == 0x0 ) return false;

    ((me->text.end >= me->text.begin) ? static_cast<void> (0) : __assert_fail ("me->text.end >= me->text.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 71, __PRETTY_FUNCTION__));
    ((me->text.memory_end >= me->text.begin) ? static_cast<void> (0) : __assert_fail ("me->text.memory_end >= me->text.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 72, __PRETTY_FUNCTION__));

    std::memcpy(chunk, me->text.begin, sizeof(uint16_t) * Size);

    Lexer_MemoryManager_Text_free(me->text.begin);

    me->text.begin = chunk;
    me->text.end = chunk + OldContentSize;
    me->text.memory_end = chunk + NewSize;
    return true;
}

inline void
Lexer_Accumulator_clear(Lexer_Accumulator* me)
{

    if( me->text.begin == me->text.end ) return;
    me->text.end = me->text.begin;
}

inline void
Lexer_Accumulator_add(Lexer_Accumulator* me,
                           const uint16_t* Begin, const uint16_t* End)
{
    const size_t L = (size_t)(End - Begin);
    ((End > Begin) ? static_cast<void> (0) : __assert_fail ("End > Begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 97, __PRETTY_FUNCTION__));



    if( me->text.begin == me->text.end ) {
        me->_begin_column = me->the_lexer->counter._column_number_at_begin;
        me->_begin_line = me->the_lexer->counter._line_number_at_begin;
    }




    if( me->text.memory_end <= me->text.end + L ) {

        if( Lexer_Accumulator_extend(me, L + 1) == false ) {
            do { throw std::runtime_error("Quex Engine: Out of Memory. Accumulator could not be further extended.\n"); } while(0);
        }
    }

    std::memcpy(me->text.end, Begin, L * sizeof(uint16_t));
    me->text.end += L;
}


inline void
Lexer_Accumulator_add_character(Lexer_Accumulator* me,
                                     const uint16_t Character)
{


    if( me->text.begin == me->text.end ) {
        me->_begin_column = me->the_lexer->counter._column_number_at_begin;
        me->_begin_line = me->the_lexer->counter._line_number_at_begin;
    }




    if( me->text.memory_end <= me->text.end + 1 ) {

        if( Lexer_Accumulator_extend(me, 2) == false ) {
            do { throw std::runtime_error("Quex Engine: Out of Memory. Accumulator could not be further extended.\n"); } while(0);
        }
    }

    *(me->text.end) = Character;
    ++(me->text.end);
}
inline void
Lexer_Accumulator_print_this(Lexer_Accumulator* me)
{

    ((me->text.end < me->text.memory_end) ? static_cast<void> (0) : __assert_fail ("me->text.end < me->text.memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 181, __PRETTY_FUNCTION__));

    *(me->text.end) = (uint16_t)0;

    std::printf("   Accumulator = '%s'\n", (const char*)me->text.begin);
}

}


namespace moritz {
}








namespace max {
    struct Lexer_Engine_tag;
    struct Lexer_Memento_tag;

    class Lexer;
    typedef uint32_t (*Lexer_AnalyzerFunctionP)(::max::Lexer*);
}



namespace max {
    class Token;
}






       


namespace max {




inline void
unicode_to_utf8_character(const uint32_t** input_pp,
                                           uint8_t** output_pp);
inline void
unicode_to_utf16_character(const uint32_t** input_pp,
                                            uint16_t** output_pp);
inline void
unicode_to_utf32_character(const uint32_t** input_pp,
                                            uint32_t** output_pp);
inline void
unicode_to_char_character(const uint32_t** input_pp,
                                           char** output_pp);

inline void
unicode_to_wchar_character(const uint32_t** input_pp,
                                            wchar_t** output_pp);



inline void
unicode_to_utf8(const uint32_t** source_pp,
                                             const uint32_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
unicode_to_utf16(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
unicode_to_utf32(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
unicode_to_char(const uint32_t** source_pp,
                                             const uint32_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
unicode_to_wchar(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    unicode_to_utf8(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<uint16_t>
    unicode_to_utf16(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<uint32_t>
    unicode_to_utf32(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<char>
    unicode_to_char(const std::basic_string<uint32_t>& Source);

    inline std::basic_string<wchar_t>
    unicode_to_wchar(const std::basic_string<uint32_t>& Source);

}







namespace max {

inline size_t
Lexer_strlen(const uint32_t* Str);


inline size_t
Lexer_strcmp(const uint32_t* it0,
                  const uint32_t* it1);

}














namespace max {
    struct Lexer_MemoryPositionMimiker {

        typedef size_t character_index;







        Lexer_MemoryPositionMimiker(uint32_t* Adr=0x0, character_index Pos=0)
            : address(Adr), buffer_start_position(Pos) {}

        uint32_t* address;
        character_index buffer_start_position;

        bool operator==(const Lexer_MemoryPositionMimiker& That)
        {
          ((this->buffer_start_position == That.buffer_start_position) ? static_cast<void> (0) : __assert_fail ("this->buffer_start_position == That.buffer_start_position", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/MemoryPositionMimiker", 63, __PRETTY_FUNCTION__));
          return this->address == That.address;
        }
        bool operator!=(const Lexer_MemoryPositionMimiker& That)
        { return ! (this->operator==(That)); }

        bool operator==(const uint32_t* ThatAdr) { return this->address == ThatAdr; }
        bool operator!=(const uint32_t* ThatAdr) { return this->address != ThatAdr; }




        void operator+=(const ptrdiff_t Value) { address += Value; buffer_start_position -= (character_index)Value; }
        void operator-=(const ptrdiff_t Value) { address -= Value; buffer_start_position += (character_index)Value; }



        operator uint32_t*() { return address; }
    };

}



namespace max {

    typedef struct {






        uint32_t* _front;
        uint32_t* _back;




        uint32_t* _end_of_file_p;


        bool _external_owner_f;
    } Lexer_BufferMemory;

    inline size_t Lexer_BufferMemory_size(Lexer_BufferMemory*);

    typedef struct {
        Lexer_BufferMemory _memory;


        uint32_t* _input_p;
        uint32_t* _lexeme_start_p;
        uint32_t _character_at_lexeme_start;






        ptrdiff_t _content_character_index_begin;





        ptrdiff_t _content_character_index_end;



        bool _byte_order_reversion_active_f;

        struct Lexer_BufferFiller_tag* filler;

        void (*on_buffer_content_change)(uint32_t* BeginOfContent,
                                              uint32_t* EndOfContent);
    } Lexer_Buffer;

    template <class InputHandleT> inline void Lexer_Buffer_construct(Lexer_Buffer* me,
                                                                  InputHandleT* input_handle,
                                                                  uint32_t* InputMemory,
                                                                  const size_t BufferMemorySize,
                                                                  uint32_t* EndOfFileP,
                                                                  const char* CharacterEncodingName,
                                                                  const size_t TranslationBufferMemorySize,
                                                                  bool ByteOrderReversionF);

    template <class InputHandleT> inline void Lexer_Buffer_reset(Lexer_Buffer* me,
                                                              InputHandleT* input_handle,
                                                              const char* CharacterEncodingName,
                                                              const size_t TranslationBufferMemorySize);

    inline void Lexer_Buffer_destruct(Lexer_Buffer* me);

    inline uint32_t* Lexer_Buffer_content_front(Lexer_Buffer*);
    inline uint32_t* Lexer_Buffer_content_back(Lexer_Buffer*);
    inline uint32_t* Lexer_Buffer_text_end(Lexer_Buffer*);
    inline size_t Lexer_Buffer_content_size(Lexer_Buffer*);

    inline Lexer_MemoryPositionMimiker Lexer_Buffer_tell_memory_adr(Lexer_Buffer*);
    inline void Lexer_Buffer_seek_memory_adr(Lexer_Buffer*,
                                                                                Lexer_MemoryPositionMimiker);

    inline void Lexer_Buffer_move_forward(Lexer_Buffer*, const ptrdiff_t CharacterN);
    inline void Lexer_Buffer_move_backward(Lexer_Buffer*, const ptrdiff_t CharacterN);
    inline ptrdiff_t Lexer_Buffer_tell(Lexer_Buffer*);
    inline void Lexer_Buffer_seek(Lexer_Buffer*, const ptrdiff_t CharacterIndex);
    inline void Lexer_Buffer_move_away_passed_content(Lexer_Buffer* me);

    inline void Lexer_Buffer_end_of_file_set(Lexer_Buffer*, uint32_t* Position);
    inline void Lexer_Buffer_end_of_file_unset(Lexer_Buffer*);
    inline bool Lexer_Buffer_is_end_of_file(Lexer_Buffer*);
    inline bool Lexer_Buffer_is_begin_of_file(Lexer_Buffer*);

    inline void Lexer_Buffer_reverse_byte_order(uint32_t* Begin,
                                                             uint32_t* End);

    inline void Lexer_Buffer_print_this(Lexer_Buffer*);

    inline uint32_t* Lexer_BufferMemory_reset(Lexer_BufferMemory* me,
                                                                      uint32_t* Memory,
                                                                      const size_t Size,
                                                                      uint32_t* EndOfContentP);

}

namespace max {

    inline uint32_t* Lexer_access_Lexeme(const char* FileName, size_t LineN, Lexer_Buffer*);
    inline size_t Lexer_access_LexemeL(const char* FileName, size_t LineN, Lexer_Buffer*);
    inline uint32_t* Lexer_access_LexemeEnd(const char* FileName, size_t LineN, Lexer_Buffer*);

}








namespace max {

     typedef struct Lexer_BufferFiller_tag {
        ptrdiff_t (*tell_character_index)(struct Lexer_BufferFiller_tag*);





        void (*seek_character_index)(struct Lexer_BufferFiller_tag*,
                                            const ptrdiff_t Index);


        size_t (*read_characters)(struct Lexer_BufferFiller_tag*,
                                       uint32_t* memory, const size_t N);



        bool (*_on_overflow)(Lexer_Buffer*, bool ForwardF);



        void (*delete_self)(struct Lexer_BufferFiller_tag*);

    } Lexer_BufferFiller;

    inline void
    Lexer_BufferFiller_setup_functions(Lexer_BufferFiller* me,
                                            ptrdiff_t (*tell_character_index)(Lexer_BufferFiller*),
                                            void (*seek_character_index)(Lexer_BufferFiller*,
                                                                                 const ptrdiff_t),
                                            size_t (*read_characters)(Lexer_BufferFiller*,
                                                                            uint32_t*, const size_t),
                                            void (*delete_self)(Lexer_BufferFiller*));
    template <class InputHandleT> inline Lexer_BufferFiller*
    Lexer_BufferFiller_new(InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize);
    inline void Lexer_BufferFiller_delete_self(Lexer_BufferFiller*);

    inline void Lexer_BufferFiller_initial_load(Lexer_Buffer*);
    inline size_t Lexer_BufferFiller_load_forward(Lexer_Buffer*);
    inline size_t Lexer_BufferFiller_load_backward(Lexer_Buffer*);



    inline void Lexer_BufferFiller_step_forward_n_characters(Lexer_BufferFiller* me,
                                                                          const ptrdiff_t ForwardN);

}



       


       












       



namespace max {
    template <class InputHandleT> struct InputPolicy;

    template <>
    struct InputPolicy<void*> {
        typedef long stream_position;
        typedef long stream_offset;



        static long tell(void* me) { (void)me; return -1L; }
        static void seek(void* me, long& Pos) { (void)me; (void)Pos; ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 30, __PRETTY_FUNCTION__)); }
        static size_t load_bytes(void*, void*, const size_t) { return (size_t)0; }
    };

    template <>
    struct InputPolicy<std::FILE*> {
        typedef long stream_position;
        typedef long stream_offset;

        static long tell(std::FILE* me) { return std::ftell(me); }
        static void seek(std::FILE* me, long& Pos) { std::fseek(me, Pos, 0); }

        static size_t load_bytes(std::FILE* ih, void* buffer_position, const size_t ByteNToRead)
        {
            return fread(buffer_position, 1, ByteNToRead, ih);
        }
    };

    template <class StdStreamType>
    struct InputPolicy<StdStreamType*> {
        typedef typename StdStreamType::pos_type stream_position;
        typedef typename StdStreamType::off_type stream_offset;

        typedef typename StdStreamType::char_type character_type;
        static const size_t CharacterSize = sizeof(typename StdStreamType::char_type);

        static stream_position tell(StdStreamType* me) {
            return me->tellg() * CharacterSize;
        }
        static void seek(StdStreamType* me, const stream_position& Pos) {
            ((Pos % CharacterSize == 0) ? static_cast<void> (0) : __assert_fail ("Pos % CharacterSize == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 74, __PRETTY_FUNCTION__));
            me->seekg(Pos / CharacterSize);
        }

        static size_t load_bytes(StdStreamType* me, void* buffer_position, const size_t ByteNToRead)
        {
            ((CharacterSize != 0) ? static_cast<void> (0) : __assert_fail ("CharacterSize != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 80, __PRETTY_FUNCTION__));
            const stream_position position_before = me->tellg();



            me->read((character_type*)buffer_position, ByteNToRead / CharacterSize);

            const size_t Result = (size_t)(me->gcount());

            if( me->eof() && ! me->bad() ) {
                me->clear();


                if( position_before != (stream_position)-1 ) {
                    me->seekg(position_before + (stream_offset)(Result));
                }
            } else if( me->fail() ) {
                throw std::runtime_error("Fatal error during stream reading.");
            }


            return Result * CharacterSize;
        }
    };







}







namespace max {

    typedef struct Lexer_Converter_tag {
        void (*open)(struct Lexer_Converter_tag*,
                        const char* FromCodingName, const char* ToCodingName);







        bool (*convert)(struct Lexer_Converter_tag*,
                           uint8_t** source, const uint8_t* SourceEnd,
                           uint32_t** drain, const uint32_t* DrainEnd);
        void (*on_conversion_discontinuity)(struct Lexer_Converter_tag*);
        void (*delete_self)(struct Lexer_Converter_tag*);



        bool dynamic_character_size_f;




    } Lexer_Converter;



    typedef void (*Lexer_ConverterFunctionP_open)(Lexer_Converter*,
                                                          const char* FromCodingName,
                                                          const char* ToCodingName);

    typedef bool (*Lexer_ConverterFunctionP_convert)(Lexer_Converter*,
                                                             uint8_t** source,
                                                             const uint8_t* SourceEnd,
                                                             uint32_t** drain,
                                                             const uint32_t* DrainEnd);

    typedef void (*Lexer_ConverterFunctionP_on_conversion_discontinuity)(Lexer_Converter*);

    typedef void (*Lexer_ConverterFunctionP_delete_self)(Lexer_Converter*);

}


namespace max {

    template <class InputHandleT> struct Lexer_RawBuffer {
        uint8_t* begin;
        uint8_t* end;
        uint8_t* memory_end;

        uint8_t* iterator;
        ptrdiff_t iterators_character_index;

        typename InputPolicy<InputHandleT*>::stream_position end_stream_position;

        bool _external_owner_f;
    } ;

    template <class InputHandleT> struct Lexer_BufferFiller_Converter {



        Lexer_BufferFiller base;

        InputHandleT* ih;

        Lexer_Converter* converter;

        Lexer_RawBuffer<InputHandleT> raw_buffer;



        ptrdiff_t hint_begin_character_index;


        typename InputPolicy<InputHandleT*>::stream_position start_position;

    } ;


    template <class InputHandleT> inline Lexer_BufferFiller_Converter<InputHandleT>*
    Lexer_BufferFiller_Converter_new(InputHandleT* input_handle,
                                          Lexer_Converter* converter,
                                          const char* FromCoding,
                                          const char* ToCoding,
                                          size_t RawBufferSize);

    template <class InputHandleT> inline void Lexer_BufferFiller_Converter_move_away_passed_content(Lexer_BufferFiller_Converter<InputHandleT>*);
    template <class InputHandleT> inline size_t Lexer___BufferFiller_Converter_fill_raw_buffer(Lexer_BufferFiller_Converter<InputHandleT>*);

    template <class InputHandleT> inline void Lexer_RawBuffer_init(Lexer_RawBuffer<InputHandleT>* me,
                                                                uint8_t* Begin, size_t SizeInBytes,
                                                                typename InputPolicy<InputHandleT*>::stream_position StartPosition);
}











    extern "C" {

    }


namespace max {

    typedef struct {
        Lexer_Converter base;

        iconv_t handle;

    } Lexer_Converter_IConv;

    inline Lexer_Converter* Lexer_Converter_IConv_new();

}


namespace max {

inline uint32_t*
Lexer_MemoryManager_BufferMemory_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferMemory_free(uint32_t* memory);

inline void*
Lexer_MemoryManager_BufferFiller_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferFiller_free(void* memory);

inline uint8_t*
Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory);


inline uint32_t*
Lexer_MemoryManager_Text_allocate(const size_t ByteN);
inline void
Lexer_MemoryManager_Text_free(uint32_t* memory);


inline void* Lexer_MemoryManager_Converter_allocate(const size_t ByteN);
inline void Lexer_MemoryManager_Converter_free(void* memory);






inline size_t
Lexer_MemoryManager_insert(uint8_t* drain_begin_p, uint8_t* drain_end_p,
                                uint8_t* source_begin_p, uint8_t* source_end_p);
inline struct Lexer_Memento_tag*
Lexer_MemoryManager_Memento_allocate();

inline void
Lexer_MemoryManager_Memento_free(struct Lexer_Memento_tag* memory);


}








namespace max {




    class Lexer;


    typedef struct Lexer_Mode_tag {
        int id;
        const char* name;
        ::max::Lexer* the_lexer;

        Lexer_AnalyzerFunctionP analyzer_function;






        void (*on_entry)(::max::Lexer*, const struct Lexer_Mode_tag* FromMode);
        void (*on_exit)(::max::Lexer*, const struct Lexer_Mode_tag* ToMode);

        bool (*has_base)(const struct Lexer_Mode_tag* Mode);
        bool (*has_entry_from)(const struct Lexer_Mode_tag* Mode);
        bool (*has_exit_to)(const struct Lexer_Mode_tag* Mode);

    } Lexer_Mode;

    inline uint32_t
    Lexer_Mode_uncallable_analyzer_function(::max::Lexer*);


    inline void
    Lexer_Mode_on_indentation_null_function(::max::Lexer*,
                                                 uint32_t* LexemeBegin,
                                                 uint32_t* LexemeEnd);


    inline void
    Lexer_Mode_on_entry_exit_null_function(::max::Lexer*, const Lexer_Mode*);

}









       







namespace max {
    typedef struct {

        size_t _line_number_at_begin;
        size_t _line_number_at_end;


        size_t _column_number_at_begin;
        size_t _column_number_at_end;





    } Lexer_Counter;


    inline void Lexer_Counter_construct(Lexer_Counter* me);
    inline void Lexer_Counter_init(Lexer_Counter* me);
    inline void Lexer_Counter_reset(Lexer_Counter* me);
    inline void Lexer_Counter_copy_construct(Lexer_Counter* me,
                                                       const Lexer_Counter* That);

    inline void Lexer_Counter_count(Lexer_Counter* me,
                                                         uint32_t* Lexeme,
                                                         uint32_t* LexemeEnd);
    inline uint32_t*
    Lexer_Counter_count_chars_to_newline_backwards(Lexer_Counter* me,
                                                        uint32_t* Begin,
                                                        uint32_t* End);

    inline void Lexer_Counter_print_this(Lexer_Counter* me);

}









namespace max {

    struct Lexer_Memento_tag;







    template <class InputHandleT> inline



    Lexer_Memento_tag*
    Lexer_memento_pack(::max::Lexer* me,
                            uint32_t* InputName,
                            InputHandleT** input_handle);


    inline

                            void
    Lexer_memento_unpack(::max::Lexer* me,
                              struct Lexer_Memento_tag* memento);

    template <class InputHandleT> inline void
    Lexer_include_push(::max::Lexer* me,
                            InputHandleT* Optional_InputHandle,
                            uint32_t* Optional_InputName,
                            const Lexer_Mode* Mode,
                            const char* CharacterCodecName );

    template <class InputHandleT> inline void
    Lexer_include_push_input_name(::max::Lexer* me,
                                       uint32_t* InputName ,
                                       const Lexer_Mode* mode ,
                                       const char* CharacterCodecName );

    template <class InputHandleT> inline void
    Lexer_include_push_input_handle(::max::Lexer* me,
                                         InputHandleT* sh ,
                                         const Lexer_Mode* mode ,
                                         const char* CharacterCodecName );

    inline bool Lexer_include_pop(::max::Lexer* me);

    inline void Lexer_include_stack_delete(::max::Lexer* me);


}


namespace max {




    class Lexer;



    typedef struct {

        size_t _begin_line;


        size_t _begin_column;


        struct {
            uint32_t* begin;
            uint32_t* end;
            uint32_t* memory_end;
        } text;
        ::max::Lexer* the_lexer;

    } Lexer_Accumulator;

    inline void
    Lexer_Accumulator_init_memory(Lexer_Accumulator* me);

    inline void
    Lexer_Accumulator_construct(Lexer_Accumulator*, ::max::Lexer*);

    inline void
    Lexer_Accumulator_destruct(Lexer_Accumulator* me);

    inline bool
    Lexer_Accumulator_extend(Lexer_Accumulator* me, size_t MinAddSize);

    inline void
    Lexer_Accumulator_clear(Lexer_Accumulator* me);

    inline void
    Lexer_Accumulator_add(Lexer_Accumulator* me,
                               const uint32_t* Begin, const uint32_t* End);

    inline void
    Lexer_Accumulator_add_character(Lexer_Accumulator* me,
                                         const uint32_t Character);

    inline void
    Lexer_Accumulator_print_this(Lexer_Accumulator* me);

}

namespace max {

    template <class InputHandleT> inline void
    Lexer_construct_basic(::max::Lexer* me,
                               InputHandleT* input_handle,
                               uint32_t* BufferMemory,
                               const size_t BufferMemorySize,
                               uint32_t* EndOfFileP,
                               const char* CharacterEncodingName,
                               const size_t TranslationBufferMemorySize,
                               bool ByteOrderReversionF);

    inline void
    Lexer_destruct_basic(::max::Lexer* me);

    template <class InputHandleT> inline void
    Lexer_reset_basic(::max::Lexer* me,
                           InputHandleT* input_handle,
                           const char* CharacterEncodingName,
                           const size_t TranslationBufferMemorySize);

    inline void Lexer_buffer_reload_backward(Lexer_Buffer* buffer);
    inline void Lexer_buffer_reload_forward(Lexer_Buffer* buffer,
                                                           Lexer_MemoryPositionMimiker* post_context_start_position,
                                                           const size_t PostContextN);

}



namespace max {




template <class InputHandleT> inline

void
Lexer_constructor_core(::max::Lexer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            bool ByteOrderReversionF,
                            uint32_t* BufferMemory,
                            size_t BufferMemorySize,
                            uint32_t* BufferEndOfFileP);

inline void
Lexer_construct_memory(::max::Lexer* me,
                            uint32_t* BufferMemoryBegin,
                            size_t BufferMemorySize,
                            uint32_t* BufferEndOfFileP,
                            const char* CharacterEncodingName ,
                            bool ByteOrderReversionF );

inline void
Lexer_construct_file_name(::max::Lexer* me,
                               const char* Filename,
                               const char* CharacterEncodingName ,
                               bool ByteOrderReversionF );

inline void
Lexer_construct_FILE(::max::Lexer* me,
                          std::FILE* fh,
                          const char* CharacterEncodingName ,
                          bool ByteOrderReversionF );


inline void
Lexer_construct_istream(::max::Lexer* me,
                             std::istream* p_input_stream,
                             const char* CharacterEncodingName ,
                             bool ByteOrderReversionF );




inline void
Lexer_construct_wistream(::max::Lexer* me,
                              std::wistream* p_input_stream,
                              const char* CharacterEncodingName ,
                              bool ByteOrderReversionF );


inline void
Lexer_destruct(::max::Lexer* me);

template <class InputHandleT> inline void
Lexer_reset(::max::Lexer* me,
                 InputHandleT* input_handle,
                 const char* CharacterEncodingName );

inline uint32_t*
Lexer_reset_buffer(::max::Lexer* me,
                        uint32_t* BufferMemoryBegin,
                        size_t BufferMemorySize,
                        uint32_t* BufferEndOfContentP,
                        const char* CharacterEncodingName );

inline void
Lexer_reset_plain(::max::Lexer* me,
                       const char* CharacterEncodingName );

}

namespace max {


inline void* Lexer_buffer_fill_region_append(::max::Lexer* me,
                                                                        void* ContentBegin,
                                                                        void* ContentEnd);
inline void Lexer_buffer_fill_region_prepare(::max::Lexer* me);
inline uint32_t* Lexer_buffer_fill_region_begin(::max::Lexer* me);
inline uint32_t* Lexer_buffer_fill_region_end(::max::Lexer* me);
inline size_t Lexer_buffer_fill_region_size(::max::Lexer* me);
inline void Lexer_buffer_fill_region_finish(::max::Lexer* me,
                                                                        const size_t LoadedN);

inline uint32_t* Lexer_buffer_lexeme_start_pointer_get(::max::Lexer* me);
inline void Lexer_buffer_input_pointer_set(::max::Lexer* me,
                                                                       uint32_t*);


inline void* Lexer_buffer_fill_region_append_conversion(::max::Lexer* me,
                                                                       void* ContentBegin,
                                                                       void* ContentEnd);
inline void* Lexer_buffer_fill_region_append_conversion_direct(::max::Lexer* me,
                                                                              void* ContentBegin,
                                                                              void* ContentEnd);
inline void Lexer_buffer_conversion_fill_region_prepare(::max::Lexer* me);
inline uint8_t* Lexer_buffer_conversion_fill_region_begin(::max::Lexer* me);
inline uint8_t* Lexer_buffer_conversion_fill_region_end(::max::Lexer* me);
inline size_t Lexer_buffer_conversion_fill_region_size(::max::Lexer* me);
inline void Lexer_buffer_conversion_fill_region_finish(::max::Lexer* me,
                                                                       const size_t ByteN);


}
namespace max {


inline void
Lexer_set_callback_on_buffer_content_change(::max::Lexer* me,
                                                 void (*callback)(uint32_t*,
                                                                                uint32_t*));


inline bool Lexer_byte_order_reversion(::max::Lexer* me);
inline void Lexer_byte_order_reversion_set(::max::Lexer* me,
                                                          bool Value);

inline const char* Lexer_version(::max::Lexer* me);


inline ::max::Token* Lexer_token_p(::max::Lexer* me);
inline void Lexer_print_this(::max::Lexer* me);

}
namespace max {


inline size_t Lexer_tell(::max::Lexer* me);
inline void Lexer_seek(::max::Lexer* me, const size_t);
inline void Lexer_seek_forward(::max::Lexer* me, const size_t);
inline void Lexer_seek_backward(::max::Lexer* me, const size_t);
inline void Lexer_undo(::max::Lexer* me);
inline void Lexer_undo_n(::max::Lexer* me, size_t DeltaN_Backward);

}
namespace max {


inline Lexer_Mode* Lexer_mode(::max::Lexer* me);
inline int Lexer_mode_id(::max::Lexer* me);
inline const char* Lexer_mode_name(::max::Lexer* me);


inline Lexer_Mode* Lexer_map_mode_id_to_mode(::max::Lexer* me,
                                                              const int ModeID);
inline int Lexer_map_mode_to_mode_id(const ::max::Lexer* me,
                                                              const Lexer_Mode* Mode);


inline void Lexer_set_mode_brutally_by_id(::max::Lexer* me,
                                                           const int LexerMode);
inline void Lexer_set_mode_brutally(::max::Lexer* me,
                                                     Lexer_Mode* Mode);
inline void Lexer_enter_mode(::max::Lexer* me,
                                                             Lexer_Mode* TargetMode);


inline void Lexer_pop_mode(::max::Lexer* me);
inline void Lexer_pop_drop_mode(::max::Lexer* me);
inline void Lexer_push_mode(::max::Lexer* me, Lexer_Mode* new_mode);

}
namespace max {
    inline uint32_t
    Lexer_receive(::max::Lexer* me);





}







namespace max {
}

       
namespace max {
extern uint32_t Lexer_LexemeNullObject;
}






namespace max {


class Token;



extern const char* Token_map_id_to_name(const uint32_t);

inline void Token_construct(Token* __this);
inline void Token_destruct(Token* __this);
inline void Token_copy(Token* me, const Token* That);
inline bool Token_take_text(Token* __this,
                                          ::max::Lexer* analyzer,
                                          const uint32_t* Begin,
                                          const uint32_t* End);






class Token {
public:
    Token();
    Token(const Token& That);


    Token& operator=(const Token& That)
    { Token_copy(this, &That); return *this; }
    virtual ~Token();
    std::basic_string<uint32_t> text;
    size_t number;


public:
    std::basic_string<uint32_t> get_text() const { return text; }
    void set_text(std::basic_string<uint32_t>& Value) { text = Value; }
    size_t get_number() const { return number; }
    void set_number(size_t Value) { number = Value; }

    void set(const uint32_t ID) { _id = ID; }
    void set(const uint32_t ID, const std::basic_string<uint32_t>& Value0)
    { _id = ID; text = Value0; }
    void set(const uint32_t ID, const size_t& Value0)
    { _id = ID; number = Value0; }
    void set(const uint32_t ID, const std::basic_string<uint32_t>& Value0, const size_t& Value1)
    { _id = ID; text = Value0; number = Value1; }


    public:




        uint32_t _id;
        uint32_t type_id() const { return _id; }
        const char* map_id_to_name(uint32_t ID) const { return Token_map_id_to_name(ID); }
        const std::string type_id_name() const { return map_id_to_name(_id); }



    public:
        size_t _line_n;
        size_t line_number() const { return _line_n; }
        void set_line_number(const size_t Value) { _line_n = Value; }


    public:
        size_t _column_n;
        size_t column_number() const { return _column_n; }
        void set_column_number(const size_t Value) { _column_n = Value; }


    public:

        typedef std::basic_string<uint32_t> __string;

        operator
        const std::string() const
        { return get_string(); }

        const std::string
        get_string() const
        {
            std::string tmp;

            tmp = map_id_to_name((*this)._id);

            tmp += " '" + pretty_char_text() + "' ";

            return tmp;
        }

        const std::string
        pretty_char_text() const
        {
            std::string tmp = ::max:: unicode_to_char((*this).text);
            std::string::size_type pos = 0;

            while( (pos = tmp.find("\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\n");
            while( (pos = tmp.find("\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\t");
            while( (pos = tmp.find("\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\r");

            return tmp;
        }


        const std::wstring
        pretty_wchar_text() const
        {
            std::wstring tmp = ::max:: unicode_to_wchar((*this).text);
            std::wstring::size_type pos = 0;

            while( (pos = tmp.find(L"\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\n");
            while( (pos = tmp.find(L"\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\t");
            while( (pos = tmp.find(L"\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\r");

            return tmp;
        }



    private:
        friend void Token_copy(Token* me, const Token* That);
        friend bool Token_take_text(Token* __this,
                                               ::max::Lexer* analyzer,
                                               const uint32_t* Begin,
                                               const uint32_t* End);
};

}

        namespace max {

        inline std::ostream&
        operator<<(std::ostream& ostr, const Token& Tok)
        { ostr << std::string(Tok); return ostr; }
        }





namespace max {




inline void
utf8_to_utf8_character(const uint8_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf8_to_utf16_character(const uint8_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf8_to_utf32_character(const uint8_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf8_to_char_character(const uint8_t** input_pp,
                                           char** output_pp);

inline void
utf8_to_wchar_character(const uint8_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf8_to_utf8(const uint8_t** source_pp,
                                             const uint8_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf8_to_utf16(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf8_to_utf32(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf8_to_char(const uint8_t** source_pp,
                                             const uint8_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf8_to_wchar(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf8_to_utf8(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<uint16_t>
    utf8_to_utf16(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<uint32_t>
    utf8_to_utf32(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<char>
    utf8_to_char(const std::basic_string<uint8_t>& Source);

    inline std::basic_string<wchar_t>
    utf8_to_wchar(const std::basic_string<uint8_t>& Source);

}




namespace max {



inline void

utf8_to_utf8_character(const uint8_t** input_pp, uint8_t** output_pp)
{

    if( (**input_pp & (uint8_t)0x80) == (uint8_t)0 ) {
        *((*output_pp)++) = *(*input_pp)++;
    }
    else if( **input_pp < (uint8_t)0xE0 ) {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
    else if( **input_pp < (uint8_t)0xF0 ) {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
    else {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
}

inline void

utf8_to_utf16_character(const uint8_t** input_pp, uint16_t** output_pp)
{
    const uint8_t* iterator = *input_pp;
    uint32_t tmp = 0;

    if( (*iterator & (uint8_t)0x80) == (uint8_t)0 ) {

        **output_pp = (uint16_t)*(iterator++);

        ++(*output_pp);
    }
    else if( *iterator < (uint8_t)0xE0 ) {


        **output_pp = (uint16_t)(( ((uint16_t)*(iterator++)) & (uint16_t)0x1F ) << 6);
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F )));

        ++(*output_pp);
    }
    else if( *iterator < (uint8_t)0xF0 ) {


        **output_pp = (uint16_t)(( ((uint16_t)*(iterator++)) & (uint16_t)0x0F ) << 12);
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F ) << 6));
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F )));

        ++(*output_pp);
    }
    else {
        tmp = (uint32_t)( (((uint32_t)*(iterator++)) & (uint32_t)0x07 ) << 18);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 12);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ));

        tmp = (uint32_t)(tmp - (uint32_t)0x10000);
        *((*output_pp)++) = (uint16_t)((tmp >> 10) | (uint32_t)0xD800);
        *((*output_pp)++) = (uint16_t)((tmp & (uint32_t)0x3FF) | (uint32_t)0xDC00);
    }
    *input_pp = iterator;
}

inline void

utf8_to_utf32_character(const uint8_t** input_pp, uint32_t** output_pp)
{
    const uint8_t* iterator = *input_pp;

    if( (*iterator & (uint8_t)0x80) == (uint8_t)0 ) {

        **output_pp = (uint32_t)*(iterator++);
    }
    else if( *iterator < (uint8_t)0xE0 ) {


        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x1F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    else if( *iterator < (uint8_t)0xF0 ) {


        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x0F ) << 12);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    else {






        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x07 ) << 18);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 12);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    ++(*output_pp);
    *input_pp = iterator;
}




inline void
utf8_to_char_character(const uint8_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::max:: utf8_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::max:: utf8_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::max:: utf8_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf8_to_wchar_character(const uint8_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::max:: utf8_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::max:: utf8_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::max:: utf8_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf8_to_utf8(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf8_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf8_to_utf8(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf8_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_utf16(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::max:: utf8_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf8_to_utf16(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf8_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_utf32(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::max:: utf8_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf8_to_utf32(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf8_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_char(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint8_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf8_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf8_to_char(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf8_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf8_to_wchar(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint8_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf8_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf8_to_wchar(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf8_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace max {




inline void
utf16_to_utf8_character(const uint16_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf16_to_utf16_character(const uint16_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf16_to_utf32_character(const uint16_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf16_to_char_character(const uint16_t** input_pp,
                                           char** output_pp);

inline void
utf16_to_wchar_character(const uint16_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf16_to_utf8(const uint16_t** source_pp,
                                             const uint16_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf16_to_utf16(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf16_to_utf32(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf16_to_char(const uint16_t** source_pp,
                                             const uint16_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf16_to_wchar(const uint16_t** source_pp,
                                              const uint16_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf16_to_utf8(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<uint16_t>
    utf16_to_utf16(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<uint32_t>
    utf16_to_utf32(const std::basic_string<uint16_t>& Source);
    inline std::basic_string<char>
    utf16_to_char(const std::basic_string<uint16_t>& Source);

    inline std::basic_string<wchar_t>
    utf16_to_wchar(const std::basic_string<uint16_t>& Source);

}






namespace max {

inline void
utf16_to_utf8_character(const uint16_t** input_pp, uint8_t** output_pp)
{
    uint32_t x0 = (uint16_t)0;
    uint32_t x1 = (uint16_t)0;
    uint32_t unicode = (uint32_t)0;

    if ( **input_pp <= (uint16_t)0x7f ) {
        *((*output_pp)++) = (uint8_t)*(*input_pp);
        ++(*input_pp);

    } else if ( **input_pp <= (uint16_t)0x7ff ) {
        *((*output_pp)++) = (uint8_t)(0xC0 | (*(*input_pp) >> 6));
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0x3F));
        ++(*input_pp);

    } else if ( **input_pp < (uint16_t)0xD800 ) {
        *((*output_pp)++) = (uint8_t)(0xE0 | *(*input_pp) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0x3F));
        ++(*input_pp);

    } else if ( **input_pp < (uint16_t)0xE000 ) {

        x0 = (uint32_t)(*(*input_pp)++ - (uint32_t)0xD800);
        x1 = (uint32_t)(*(*input_pp)++ - (uint32_t)0xDC00);
        unicode = (x0 << 10) + x1 + 0x10000;


        ((unicode <= (uint16_t)0x1FFFFF) ? static_cast<void> (0) : __assert_fail ("unicode <= (uint16_t)0x1FFFFF", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/from-utf16.i", 79, __PRETTY_FUNCTION__));

        *((*output_pp)++) = (uint8_t)(0xF0 | unicode >> 18);
        *((*output_pp)++) = (uint8_t)(0x80 | (unicode & (uint32_t)0x3FFFF) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (unicode & (uint32_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (unicode & (uint32_t)0x3F));

    } else {

        *((*output_pp)++) = (uint8_t)(0xE0 | *(*input_pp) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (*(*input_pp) & (uint16_t)0x3F));
        ++(*input_pp);
    }
}

inline void
utf16_to_utf16_character(const uint16_t** input_pp,
                                      uint16_t** output_pp)
{
    if( **input_pp < (uint16_t)0xD800 || **input_pp >= (uint16_t)0xE000 ) {
        *((*output_pp)++) = *(*input_pp)++;
    } else {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
}

inline void
utf16_to_utf32_character(const uint16_t** input_pp,
                                      uint32_t** output_pp)
{
    uint32_t x0 = (uint32_t)0;
    uint32_t x1 = (uint32_t)0;

    if( **input_pp < (uint16_t)0xD800 || **input_pp >= (uint16_t)0xE000 ) {
        *((*output_pp)++) = *(*input_pp)++;
    } else {
        x0 = (uint32_t)(*(*input_pp)++) - (uint32_t)0xD800;
        x1 = (uint32_t)(*(*input_pp)++) - (uint32_t)0xDC00;
        *((*output_pp)++) = (x0 << 10) + x1 + (uint32_t)0x10000;
    }
}



inline void
utf16_to_char_character(const uint16_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::max:: utf16_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::max:: utf16_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::max:: utf16_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf16_to_wchar_character(const uint16_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::max:: utf16_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::max:: utf16_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::max:: utf16_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf16_to_utf8(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf16_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf16_to_utf8(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf16_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf16_to_utf16(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::max:: utf16_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf16_to_utf16(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf16_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf16_to_utf32(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint16_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::max:: utf16_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf16_to_utf32(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf16_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf16_to_char(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint16_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf16_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf16_to_char(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf16_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf16_to_wchar(const uint16_t** source_pp,
                                                  const uint16_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint16_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf16_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf16_to_wchar(const std::basic_string<uint16_t>& Source)
{
    const uint16_t* source_iterator = (uint16_t*)Source.c_str();
    const uint16_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf16_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint16_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint16_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace max {




inline void
utf32_to_utf8_character(const uint32_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf32_to_utf16_character(const uint32_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf32_to_utf32_character(const uint32_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf32_to_char_character(const uint32_t** input_pp,
                                           char** output_pp);

inline void
utf32_to_wchar_character(const uint32_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf32_to_utf8(const uint32_t** source_pp,
                                             const uint32_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf32_to_utf16(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf32_to_utf32(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf32_to_char(const uint32_t** source_pp,
                                             const uint32_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf32_to_wchar(const uint32_t** source_pp,
                                              const uint32_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf32_to_utf8(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<uint16_t>
    utf32_to_utf16(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<uint32_t>
    utf32_to_utf32(const std::basic_string<uint32_t>& Source);
    inline std::basic_string<char>
    utf32_to_char(const std::basic_string<uint32_t>& Source);

    inline std::basic_string<wchar_t>
    utf32_to_wchar(const std::basic_string<uint32_t>& Source);

}




namespace max {



inline void
utf32_to_utf8_character(const uint32_t** input_pp,
                                     uint8_t** output_pp)
{
    uint32_t Unicode = **input_pp;


    if (Unicode <= 0x0000007f) {
        *((*output_pp)++) = (uint8_t)Unicode;
    } else if (Unicode <= 0x000007ff) {
        *((*output_pp)++) = (uint8_t)(0xC0 | (Unicode >> 6));
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3f));
    } else if (Unicode <= 0x0000ffff) {
        *((*output_pp)++) = (uint8_t)(0xE0 | Unicode >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3F));
    } else {

        ((Unicode <= (uint32_t)0x1FFFFF) ? static_cast<void> (0) : __assert_fail ("Unicode <= (uint32_t)0x1FFFFF", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/from-utf32.i", 78, __PRETTY_FUNCTION__));

        ((! (Unicode >= 0xd800 && Unicode <= 0xdfff)) ? static_cast<void> (0) : __assert_fail ("! (Unicode >= 0xd800 && Unicode <= 0xdfff)", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/from-utf32.i", 80, __PRETTY_FUNCTION__));

        *((*output_pp)++) = (uint8_t)(0xF0 | Unicode >> 18);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3FFFF) >> 12);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0xFFF) >> 6);
        *((*output_pp)++) = (uint8_t)(0x80 | (Unicode & (uint32_t)0x3F));
    }


    ++(*input_pp);
}

inline void
utf32_to_utf16_character(const uint32_t** input_pp,
                                    uint16_t** output_pp)
{
    uint32_t tmp = 0;

    if( **input_pp < 0x10000 ) {
        *((*output_pp)++) = (uint16_t)**input_pp;
    } else {
        tmp = (uint32_t)(**input_pp - (uint32_t)0x10000);

        *(((*output_pp)++)) = (uint16_t)((tmp >> 10) | (uint16_t)0xD800);
        *(((*output_pp)++)) = (uint16_t)((tmp & (uint32_t)0x3FF) | (uint16_t)0xDC00);
    }
    ++(*input_pp);
}

inline void
utf32_to_utf32_character(const uint32_t** input_pp,
                                    uint32_t** output_pp)
{
    *((*output_pp)++) = (uint32_t)(*(*input_pp)++);
}



inline void
utf32_to_char_character(const uint32_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::max:: utf32_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::max:: utf32_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::max:: utf32_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf32_to_wchar_character(const uint32_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::max:: utf32_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::max:: utf32_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::max:: utf32_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf32_to_utf8(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf32_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf32_to_utf8(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf32_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf32_to_utf16(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::max:: utf32_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf32_to_utf16(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf32_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf32_to_utf32(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::max:: utf32_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf32_to_utf32(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf32_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf32_to_char(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint32_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf32_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf32_to_char(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf32_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf32_to_wchar(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint32_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: utf32_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf32_to_wchar(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: utf32_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}

namespace max {


inline void
unicode_to_utf8_character(const uint32_t** input_pp,
                                       uint8_t** output_pp)
{
    switch( sizeof(uint32_t) )
    {
    case 1: ::max:: utf8_to_utf8_character((const uint8_t**)input_pp, output_pp); break;
    case 2: ::max:: utf16_to_utf8_character((const uint16_t**)input_pp, output_pp); break;
    case 4: ::max:: utf32_to_utf8_character((const uint32_t**)input_pp, output_pp); break;
    default: do { throw std::runtime_error("Cannot derive converter for given element size."); } while(0);
    }
}

inline void
unicode_to_utf16_character(const uint32_t** input_pp,
                                        uint16_t** output_pp)
{
    switch( sizeof(uint32_t) )
    {
    case 1: ::max:: utf8_to_utf16_character((const uint8_t**)input_pp, output_pp); break;
    case 2: ::max:: utf16_to_utf16_character((const uint16_t**)input_pp, output_pp); break;
    case 4: ::max:: utf32_to_utf16_character((const uint32_t**)input_pp, output_pp); break;
    default: do { throw std::runtime_error("Cannot derive converter for given element size."); } while(0);
    }
}

inline void
unicode_to_utf32_character(const uint32_t** input_pp,
                                        uint32_t** output_pp)
{
    switch( sizeof(uint32_t) )
    {
    case 1: ::max:: utf8_to_utf32_character((const uint8_t**)input_pp, output_pp); break;
    case 2: ::max:: utf16_to_utf32_character((const uint16_t**)input_pp, output_pp); break;
    case 4: ::max:: utf32_to_utf32_character((const uint32_t**)input_pp, output_pp); break;
    default: do { throw std::runtime_error("Cannot derive converter for given element size."); } while(0);
    }
}






inline void
unicode_to_char_character(const uint32_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::max:: unicode_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::max:: unicode_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::max:: unicode_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    unicode_to_wchar_character(const uint32_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::max:: unicode_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::max:: unicode_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::max:: unicode_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
unicode_to_utf8(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: unicode_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
unicode_to_utf8(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: unicode_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
unicode_to_utf16(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::max:: unicode_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
unicode_to_utf16(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: unicode_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
unicode_to_utf32(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint32_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::max:: unicode_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
unicode_to_utf32(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: unicode_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
unicode_to_char(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint32_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: unicode_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
unicode_to_char(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: unicode_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
unicode_to_wchar(const uint32_t** source_pp,
                                                  const uint32_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint32_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::max:: unicode_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
unicode_to_wchar(const std::basic_string<uint32_t>& Source)
{
    const uint32_t* source_iterator = (uint32_t*)Source.c_str();
    const uint32_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::max:: unicode_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint32_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint32_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace max {
extern uint32_t Lexer_LexemeNullObject;
}


namespace max {


inline
Token::Token()
{



}

inline
Token::Token(const Token& Other)
{
   Token_copy(this, &Other);



}

inline
Token::~Token()
{



}

inline void
Token_construct(Token* __this)
{

    new ((void*)__this) Token;
}

inline void
Token_destruct(Token* __this)
{
    __this->Token::~Token();
}

inline void
Token_copy(Token* __this, const Token* __That)
{


    (void)__this;
    (void)__That;

        (*__this)._id = (*__That)._id;
        (*__this).text = (*__That).text;
        (*__this).number = (*__That).number;


        (*__this)._line_n = (*__That)._line_n;
        (*__this)._column_n = (*__That)._column_n;





   ((__this->_id == __That->_id) ? static_cast<void> (0) : __assert_fail ("__this->_id == __That->_id", "max_Lexer-token", 285, __PRETTY_FUNCTION__));


    ((__this->_line_n == __That->_line_n) ? static_cast<void> (0) : __assert_fail ("__this->_line_n == __That->_line_n", "max_Lexer-token", 288, __PRETTY_FUNCTION__));
    ((__this->_column_n == __That->_column_n) ? static_cast<void> (0) : __assert_fail ("__this->_column_n == __That->_column_n", "max_Lexer-token", 289, __PRETTY_FUNCTION__));


}

inline bool
Token_take_text(Token* __this,
                           ::max::Lexer* __analyzer,
                           const uint32_t* Begin,
                           const uint32_t* End)
{


    (void)__this;
    (void)__analyzer;
        (*__this).text.assign(Begin, End-Begin);
        return false;



}
}

const uint32_t MAX_TKN_ADVERB____ = ((uint32_t)10000);
const uint32_t MAX_TKN_ARTICLE___ = ((uint32_t)10001);
const uint32_t MAX_TKN_DEDENT = ((uint32_t)3);
const uint32_t MAX_TKN_FILL_WORD_ = ((uint32_t)10002);
const uint32_t MAX_TKN_INDENT = ((uint32_t)2);
const uint32_t MAX_TKN_MARK______ = ((uint32_t)10003);
const uint32_t MAX_TKN_ME________ = ((uint32_t)10004);
const uint32_t MAX_TKN_MY_BROTHER = ((uint32_t)10005);
const uint32_t MAX_TKN_NEGATION__ = ((uint32_t)10006);
const uint32_t MAX_TKN_NODENT = ((uint32_t)4);
const uint32_t MAX_TKN_OK = ((uint32_t)10007);
const uint32_t MAX_TKN_PREDICATE_ = ((uint32_t)10008);
const uint32_t MAX_TKN_SCALLYWAG_ = ((uint32_t)10009);
const uint32_t MAX_TKN_SUBJECT___ = ((uint32_t)10010);
const uint32_t MAX_TKN_TERMINATION = ((uint32_t)0);
const uint32_t MAX_TKN_UKNOWN____ = ((uint32_t)10011);
const uint32_t MAX_TKN_UNINITIALIZED = ((uint32_t)1);
const uint32_t MAX_TKN_VERB______ = ((uint32_t)10012);


namespace max {
extern const char* Token_map_id_to_name(const uint32_t TokenID);
}

namespace max {

enum {
    Lexer_ModeID_NORMAL = 0,
    Lexer_ModeID_HAPPY = 1
};

        extern Lexer_Mode Lexer_NORMAL;
        extern Lexer_Mode Lexer_HAPPY;


extern uint32_t Lexer_NORMAL_analyzer_function(::max::Lexer*);

extern bool Lexer_NORMAL_has_base(const Lexer_Mode*);
extern bool Lexer_NORMAL_has_entry_from(const Lexer_Mode*);
extern bool Lexer_NORMAL_has_exit_to(const Lexer_Mode*);

extern uint32_t Lexer_HAPPY_analyzer_function(::max::Lexer*);
extern void Lexer_HAPPY_on_entry(::max::Lexer*, const Lexer_Mode*);

extern bool Lexer_HAPPY_has_base(const Lexer_Mode*);
extern bool Lexer_HAPPY_has_entry_from(const Lexer_Mode*);
extern bool Lexer_HAPPY_has_exit_to(const Lexer_Mode*);




typedef struct Lexer_Memento_tag {




        Lexer_Buffer buffer;

        struct Lexer_Mode_tag* __current_mode_p;
        Lexer_AnalyzerFunctionP current_analyzer_function;



        Lexer_AnalyzerFunctionP DEBUG_analyzer_function_at_entry;



        Lexer_Counter counter;



        Lexer_Accumulator accumulator;







        struct Lexer_Memento_tag* _parent_memento;


        FILE* __file_handle_allocated_by_constructor;

    Lexer_Memento_tag() {}
    ~Lexer_Memento_tag() {}




} Lexer_Memento;

}


namespace max {

class Lexer {
public:
        ::max::Token* token;

            ::max::Token __memory_token;




        Lexer_Buffer buffer;







        Lexer_AnalyzerFunctionP DEBUG_analyzer_function_at_entry;





        Lexer_AnalyzerFunctionP current_analyzer_function;
        struct Lexer_Mode_tag* __current_mode_p;







        struct Lexer_Mode_tag* mode_db[(2)];

        struct {
            struct Lexer_Mode_tag* (begin[(size_t)8]);
            struct Lexer_Mode_tag** end;
            struct Lexer_Mode_tag** memory_end;
        } _mode_stack;
        Lexer_Counter counter;
        Lexer_Accumulator accumulator;
        struct Lexer_Memento_tag* _parent_memento;
        FILE* __file_handle_allocated_by_constructor;

                   Lexer(const Lexer&);
public:
    typedef ::max::Token token_type;
    typedef uint32_t token_id_type;
    typedef uint32_t char_type;

    Lexer(uint32_t* BufferMemoryBegin, size_t BufferMemorySize,
          uint32_t* BufferEndOfContentP = 0x0,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);
    Lexer(const std::string& Filename,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);
    Lexer(std::istream* p_input_stream,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);

    Lexer(std::wistream* p_input_stream,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);

    Lexer(std::FILE* input_fh,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);







    virtual ~Lexer();


    void* buffer_fill_region_append(void* ContentBegin,
                                                    void* ContentEnd);
    void* buffer_fill_region_append_conversion(void* ContentBegin,
                                                               void* ContentEnd);
    void* buffer_fill_region_append_conversion_direct(void* ContentBegin,
                                                                      void* ContentEnd);
    void buffer_fill_region_prepare();
    uint32_t* buffer_fill_region_begin();
    uint32_t* buffer_fill_region_end();
    size_t buffer_fill_region_size();
    void buffer_fill_region_finish(const size_t LoadedN);
    void buffer_conversion_fill_region_prepare();
    uint8_t* buffer_conversion_fill_region_begin();
    uint8_t* buffer_conversion_fill_region_end();
    size_t buffer_conversion_fill_region_size();
    void buffer_conversion_fill_region_finish(const size_t ByteN);
    uint32_t* buffer_lexeme_start_pointer_get();
    void buffer_input_pointer_set(uint32_t*);


    bool byte_order_reversion();
    void byte_order_reversion_set(bool Value);
    uint32_t receive();
    ::max::Token* token_p();
    Lexer_Mode& mode();
    int mode_id() const;
    const char* mode_name() const;


    void set_mode_brutally(const int LexerMode);
    void set_mode_brutally(const Lexer_Mode& Mode);

    void operator<<(const int MODE_ID);
    void operator<<( Lexer_Mode& Mode);

    void pop_mode();
    void pop_drop_mode();
    void push_mode(Lexer_Mode& new_mode);

    void enter_mode( Lexer_Mode& TargetMode);


    Lexer_Mode& map_mode_id_to_mode(const int ModeID);
    int map_mode_to_mode_id(const Lexer_Mode& Mode) const;


    void send(const uint32_t TokenID)
    { (void)TokenID; do { throw std::runtime_error("Member functions .send()" " has been deprecated\n" "Please, use " "macros: self_send*()" "."); } while(0); }


    size_t line_number() const { return line_number_at_begin(); }
    size_t line_number_at_begin() const { return counter._line_number_at_begin; }
    size_t line_number_at_end() const { return counter._line_number_at_end; }

    void line_number_set(size_t Y) { counter._line_number_at_end = Y; }


    size_t column_number() const { return column_number_at_begin(); }
    size_t column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t column_number_at_end() const { return counter._column_number_at_end; }

    void column_number_set(size_t X) { counter._column_number_at_end = X; }






    const char* version() const;


    size_t tell();
    void seek(const size_t);
    void seek_forward(const size_t);
    void seek_backward(const size_t);

    void undo();
    void undo(size_t DeltaN_Backward);

    void move_forward(const size_t) { do { throw std::runtime_error("'move_forward()' has been renamed to 'seek_forward()'."); } while(0); }
    void move_backward(const size_t){ do { throw std::runtime_error("'move_backward()' has been renamed to 'seek_backward()'."); } while(0); }

public:

    void set_callback_on_buffer_content_change(void (*callback)(uint32_t*,
                                                                       uint32_t*));

    template <class InputHandleT> void reset(InputHandleT* input_handle,
                                             const char* CharacterEncodingName = 0x0);
    void reset(const char* CharacterEncodingName = 0x0)
    { reset<void>((void*)0x0, CharacterEncodingName); }

    uint32_t* reset_buffer(uint32_t* BufferMemoryBegin,
                                                    size_t BufferMemorySize,
                                                    uint32_t* BufferEndOfContentP,
                                                    const char* CharacterEncodingName = 0x0);


public:
    template<class InputHandleT> void include_push(uint32_t* InputName,
                                                    const Lexer_Mode* Mode = 0x0,
                                                    const char* IANA_CodingName = 0x0);
    template<class InputHandleT> void include_push(InputHandleT* sh,
                                                    const Lexer_Mode* Mode = 0x0,
                                                    const char* IANA_CodingName = 0x0);
    bool include_pop();

protected:
    void include_stack_delete();

private:


public:
    void print_this();

private:

    template <class InputHandleT> inline friend void
    Lexer_constructor_core(::max::Lexer* me,
                                InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                bool ByteOrderReversionF,
                                uint32_t* BufferMemory,
                                size_t BufferMemorySize);

    template<class InputHandleT> friend Lexer_Memento*
    Lexer_memento_pack(::max::Lexer*, uint32_t*,
                            InputHandleT**);
    friend void
    Lexer_memento_unpack(::max::Lexer*, Lexer_Memento*);

    template<class InputHandleT> friend void
    Lexer_reset(::max::Lexer*, InputHandleT*, const char*);


    friend uint32_t Lexer_NORMAL_analyzer_function(::max::Lexer*);

    friend bool Lexer_NORMAL_has_base(const Lexer_Mode*);
    friend bool Lexer_NORMAL_has_entry_from(const Lexer_Mode*);
    friend bool Lexer_NORMAL_has_exit_to(const Lexer_Mode*);

    friend uint32_t Lexer_HAPPY_analyzer_function(::max::Lexer*);
    friend void Lexer_HAPPY_on_entry(::max::Lexer*, const Lexer_Mode*);

    friend bool Lexer_HAPPY_has_base(const Lexer_Mode*);
    friend bool Lexer_HAPPY_has_entry_from(const Lexer_Mode*);
    friend bool Lexer_HAPPY_has_exit_to(const Lexer_Mode*);




public:






public:

    void get_token()
    { do { throw std::runtime_error("Member functions .get_token()" " has been deprecated\n" "Please, use " ".receive(...)" "."); } while(0); }
    void get_token(::max::Token* result_p) { (void)result_p; get_token(); }
    void get_token(::max::Token** result_pp) { (void)result_pp; get_token(); }
};

}


namespace max {


template <class InputHandleT> inline

void
Lexer_constructor_core(::max::Lexer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            bool ByteOrderReversionF,
                            uint32_t* BufferMemory,
                            size_t BufferMemorySize,
                            uint32_t* BufferEndOfFileP)
{
    ((Lexer_ModeID_NORMAL < 2) ? static_cast<void> (0) : __assert_fail ("Lexer_ModeID_NORMAL < 2", "max_Lexer", 382, __PRETTY_FUNCTION__));
    ((Lexer_ModeID_HAPPY < 2) ? static_cast<void> (0) : __assert_fail ("Lexer_ModeID_HAPPY < 2", "max_Lexer", 383, __PRETTY_FUNCTION__));

     Lexer_NORMAL.id = Lexer_ModeID_NORMAL;
     Lexer_NORMAL.name = "NORMAL";
     Lexer_NORMAL.analyzer_function = Lexer_NORMAL_analyzer_function;




     Lexer_NORMAL.on_entry = Lexer_Mode_on_entry_exit_null_function;
     Lexer_NORMAL.on_exit = Lexer_Mode_on_entry_exit_null_function;

     Lexer_NORMAL.has_base = Lexer_NORMAL_has_base;
     Lexer_NORMAL.has_entry_from = Lexer_NORMAL_has_entry_from;
     Lexer_NORMAL.has_exit_to = Lexer_NORMAL_has_exit_to;


     Lexer_HAPPY.id = Lexer_ModeID_HAPPY;
     Lexer_HAPPY.name = "HAPPY";
     Lexer_HAPPY.analyzer_function = Lexer_HAPPY_analyzer_function;




     Lexer_HAPPY.on_entry = Lexer_HAPPY_on_entry;
     Lexer_HAPPY.on_exit = Lexer_Mode_on_entry_exit_null_function;

     Lexer_HAPPY.has_base = Lexer_HAPPY_has_base;
     Lexer_HAPPY.has_entry_from = Lexer_HAPPY_has_entry_from;
     Lexer_HAPPY.has_exit_to = Lexer_HAPPY_has_exit_to;

        me->mode_db[Lexer_ModeID_NORMAL] = &(Lexer_NORMAL);
        me->mode_db[Lexer_ModeID_HAPPY] = &(Lexer_HAPPY);


    Lexer_construct_basic(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName,
                               ((size_t)65536),
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));






}





template <class InputHandleT> inline

Lexer_Memento*
Lexer_memento_pack(::max::Lexer* me,
                        uint32_t* InputName,
                        InputHandleT** input_handle)
{

    Lexer_Memento* memento = Lexer_MemoryManager_Memento_allocate();

    (void)InputName;
    (void)input_handle;




    new ((void*)memento) Lexer_Memento;


    memento->_parent_memento = (*me)._parent_memento;
    memento->buffer = (*me).buffer;
    memento->__current_mode_p = (*me).__current_mode_p;
    memento->current_analyzer_function = (*me).current_analyzer_function;


    memento->DEBUG_analyzer_function_at_entry = (*me).DEBUG_analyzer_function_at_entry;

    memento->counter = (*me).counter;

    memento->accumulator = (*me).accumulator;

    memento->__file_handle_allocated_by_constructor = (*me).__file_handle_allocated_by_constructor;
    return memento;

}


inline

void
Lexer_memento_unpack(::max::Lexer* me,
                          Lexer_Memento* memento)
{

    (*me)._parent_memento = memento->_parent_memento;
    (*me).buffer = memento->buffer;
    (*me).__current_mode_p = memento->__current_mode_p;
    (*me).current_analyzer_function = memento->current_analyzer_function;


    (*me).DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;

    (*me).counter = memento->counter;

    (*me).accumulator = memento->accumulator;

    (*me).__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;
    memento->~Lexer_Memento_tag();


    Lexer_MemoryManager_Memento_free(memento);

}


}




namespace max {

inline size_t
Lexer_strlen(const uint32_t* Str)
{
    const uint32_t* iterator = Str;
    while( *iterator != 0 ) ++iterator;
    return (size_t)(iterator - Str);
}

inline size_t
Lexer_strcmp(const uint32_t* it0,
                  const uint32_t* it1)
{
    for(; *it0 == *it1; ++it0, ++it1) {


        if( *it0 == 0 ) return 0;
    }
    return (size_t)(*it0) - (size_t)(*it1);
}

}

namespace max {

inline uint32_t*
Lexer_access_Lexeme(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( *(buffer->_input_p) != (uint32_t)0 ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Tried to access lexeme while terminating zero was not set.\n" "This happens, for example, if navigation commands (undo, seek,\n" "seek_forward, or seek_backward) are used **before** accessing\n" "the lexeme via 'Lexeme' or 'LexemeBegin'.\n"); } while(0); };
    return buffer->_lexeme_start_p;
}

inline uint32_t*
Lexer_access_LexemeBegin(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return buffer->_lexeme_start_p;
}

inline size_t
Lexer_access_LexemeL(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return (size_t)(buffer->_input_p - buffer->_lexeme_start_p);
}

inline uint32_t*
Lexer_access_LexemeEnd(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return buffer->_input_p;
}

}




namespace max {
    inline uint32_t
    Lexer_receive(::max::Lexer* me)
    {
        register uint32_t __self_result_token_id = (uint32_t)-1;
        ((me->token != 0x0) ? static_cast<void> (0) : __assert_fail ("me->token != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/token-receiving.i", 103, __PRETTY_FUNCTION__));
        me->token->_id = ((uint32_t)MAX_TKN_UNINITIALIZED);
        do {
            __self_result_token_id = me->current_analyzer_function(me);



            if( __self_result_token_id != me->token->_id ) {
                __self_result_token_id = me->token->_id;
            }

        } while( __self_result_token_id == ((uint32_t)MAX_TKN_UNINITIALIZED) );
        return __self_result_token_id;
    }







       inline uint32_t Lexer::receive()
       { return Lexer_receive(this); }





}
namespace max {

    inline Lexer_Mode*
    Lexer_get_mode(::max::Lexer* me)
    { return me->__current_mode_p; }

    inline int
    Lexer_get_mode_id(const ::max::Lexer* me)
    { return me->__current_mode_p->id; }

    inline const char*
    Lexer_get_mode_name(const ::max::Lexer* me)
    { return me->__current_mode_p->name; }

    inline void
    Lexer_set_mode_brutally(::max::Lexer* me, Lexer_Mode* ModeP)
    {
        me->__current_mode_p = ModeP;
        me->current_analyzer_function = ModeP->analyzer_function;
    }

    inline void
    Lexer_set_mode_brutally_by_id(::max::Lexer* me, const int ModeID)
    { Lexer_set_mode_brutally(me, me->mode_db[ModeID]); }

    inline void
    Lexer_enter_mode(::max::Lexer* me, Lexer_Mode* TargetMode)
    {

        Lexer_Mode* SourceMode = me->__current_mode_p;






        Lexer_set_mode_brutally(me, TargetMode);


        TargetMode->on_entry(me, SourceMode);

    }

    inline Lexer_Mode*
    Lexer_map_mode_id_to_mode(::max::Lexer* me, const int ModeID)
    {
        ((ModeID >= 0) ? static_cast<void> (0) : __assert_fail ("ModeID >= 0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 65, __PRETTY_FUNCTION__));
        ((ModeID < (2)) ? static_cast<void> (0) : __assert_fail ("ModeID < (2)", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 66, __PRETTY_FUNCTION__));
        return me->mode_db[ModeID];
    }

    inline int
    Lexer_map_mode_to_mode_id(const ::max::Lexer* me, const Lexer_Mode* Mode)
    { (void)me; return Mode->id; }

    inline void
    Lexer_pop_mode(::max::Lexer* me)
    {
        ((me->_mode_stack.end != me->_mode_stack.begin) ? static_cast<void> (0) : __assert_fail ("me->_mode_stack.end != me->_mode_stack.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 77, __PRETTY_FUNCTION__));
        --(me->_mode_stack.end);
        Lexer_enter_mode(me, *me->_mode_stack.end);
    }

    inline void
    Lexer_pop_drop_mode(::max::Lexer* me)
    {
        ((me->_mode_stack.end != me->_mode_stack.begin) ? static_cast<void> (0) : __assert_fail ("me->_mode_stack.end != me->_mode_stack.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 85, __PRETTY_FUNCTION__));
        --(me->_mode_stack.end);

    }

    inline void
    Lexer_push_mode(::max::Lexer* me, Lexer_Mode* new_mode)
    {

        if( me->_mode_stack.end == me->_mode_stack.memory_end )
            do { throw std::runtime_error("Error: Mode stack overflow. Adapt size of mode stack via the macro\n" "Error: QUEX_SETTING_MODE_STACK_SIZE, or review mode transitions.\n" "Error: I.e. check that for every GOSUB (push), there is a correspondent\n" "Error: GOUP (pop)."); } while(0);

        *me->_mode_stack.end = me->__current_mode_p;
        ++(me->_mode_stack.end);
        Lexer_enter_mode(me, new_mode);
    }


    inline Lexer_Mode&
    Lexer::mode()
    { return *Lexer_get_mode(this); }

    inline int
    Lexer::mode_id() const
    { return Lexer_get_mode_id(this); }

    inline const char*
    Lexer::mode_name() const
    { return Lexer_get_mode_name(this); }

    inline void
    Lexer::set_mode_brutally(const int ModeID)
    { Lexer_set_mode_brutally_by_id(this, ModeID); }

    inline void
    Lexer::set_mode_brutally(const Lexer_Mode& TheMode)
    { Lexer_set_mode_brutally(this, ((Lexer_Mode*)&TheMode)); }

    inline void
    Lexer::enter_mode( Lexer_Mode& TargetMode)
    { Lexer_enter_mode(this, &TargetMode); }

    inline Lexer_Mode&
    Lexer::map_mode_id_to_mode(const int ModeID)
    { return *(Lexer_map_mode_id_to_mode(this, ModeID)); }

    inline int
    Lexer::map_mode_to_mode_id(const Lexer_Mode& TheMode) const
    { return Lexer_map_mode_to_mode_id(this, &TheMode); }

    inline void
    Lexer::operator<<(const int ModeID)
    { enter_mode(*(Lexer_map_mode_id_to_mode(this, ModeID))); }

    inline void
    Lexer::operator<<( Lexer_Mode& TheMode)
    { enter_mode(TheMode); }

    inline void
    Lexer::pop_mode()
    { Lexer_pop_mode(this); }

    inline void
    Lexer::pop_drop_mode()
    { Lexer_pop_drop_mode(this); }

    inline void
    Lexer::push_mode(Lexer_Mode& new_mode)
    { Lexer_push_mode(this, &new_mode); }



}






namespace max {





    inline void
    QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(Lexer_Buffer* B)
    {
        (((B) != 0x0) ? static_cast<void> (0) : __assert_fail ("(B) != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 25, __PRETTY_FUNCTION__));
        if( (*B)._memory._front != 0x0 || (*B)._memory._back != 0x0 ) {
            (((*B)._memory._front < (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._front < (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 27, __PRETTY_FUNCTION__));
            ((*((*B)._memory._front) == ((uint32_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*((*B)._memory._front) == ((uint32_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 28, __PRETTY_FUNCTION__));
            (((*B)._input_p >= (*B)._memory._front) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p >= (*B)._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 29, __PRETTY_FUNCTION__));
            (((*B)._lexeme_start_p >= (*B)._memory._front) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p >= (*B)._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 30, __PRETTY_FUNCTION__));

            if( (*B)._memory._end_of_file_p == 0x0 ) {
                (((*B)._input_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 33, __PRETTY_FUNCTION__));
                (((*B)._lexeme_start_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 34, __PRETTY_FUNCTION__));
            } else {
                (((*B)._input_p <= (*B)._memory._end_of_file_p) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p <= (*B)._memory._end_of_file_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 36, __PRETTY_FUNCTION__));
                (((*B)._lexeme_start_p <= (*B)._memory._end_of_file_p) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p <= (*B)._memory._end_of_file_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 37, __PRETTY_FUNCTION__));

                (((*B)._memory._end_of_file_p >= (*B)._memory._front + 1) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._end_of_file_p >= (*B)._memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 39, __PRETTY_FUNCTION__));
                (((*B)._memory._end_of_file_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._end_of_file_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 40, __PRETTY_FUNCTION__));
            }
            (((*B)._content_character_index_begin <= (*B)._content_character_index_end) ? static_cast<void> (0) : __assert_fail ("(*B)._content_character_index_begin <= (*B)._content_character_index_end",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts"
            ,
 43
            , __PRETTY_FUNCTION__))
                                                                   ;
            if( ! ( (*B)._content_character_index_end == (size_t)0
                      && (*B)._content_character_index_begin == (size_t)0 ) ) {
                (((size_t)( (*B)._content_character_index_end - (*B)._content_character_index_begin) == (size_t)( Lexer_Buffer_text_end(B) - Lexer_Buffer_content_front(B))) ? static_cast<void> (0) : __assert_fail ("(size_t)( (*B)._content_character_index_end - (*B)._content_character_index_begin) == (size_t)( Lexer_Buffer_text_end(B) - Lexer_Buffer_content_front(B))",


 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts"
                ,


 49
                , __PRETTY_FUNCTION__))


                                                                                     ;
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_CONSISTENCY(Lexer_Buffer* B)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(B);





        if( (*B)._memory._front != 0 || (*B)._memory._back != 0x0 ) {
            ((*((*B)._memory._back) == ((uint32_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*((*B)._memory._back) == ((uint32_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 64, __PRETTY_FUNCTION__));
            if( (*B)._memory._end_of_file_p != 0x0 ) {
                ((*(*B)._memory._end_of_file_p == ((uint32_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*(*B)._memory._end_of_file_p == ((uint32_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 66, __PRETTY_FUNCTION__));
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(uint32_t* Begin,
                                            uint32_t* End)
    {
        uint32_t* iterator = 0x0;
        ((Begin <= End) ? static_cast<void> (0) : __assert_fail ("Begin <= End", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 76, __PRETTY_FUNCTION__));

        for(iterator = Begin; iterator != End; ++iterator) {
            if( *iterator != ((uint32_t)0x0) ) continue;

            if( iterator == Begin ) {
                do { throw std::runtime_error("Buffer limit code character appeared as first character in buffer.\n" "This is most probably a load failure.\n"); } while(0)
                                                                          ;
            } else {
                do { throw std::runtime_error("Buffer limit code character appeared as normal text content.\n"); } while(0);
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(const Lexer_Buffer* buffer)
    {
        uint32_t* End = buffer->_memory._back;

        if( buffer->_memory._front == 0x0 && buffer->_memory._back == 0x0 ) return;
        if( buffer->_memory._end_of_file_p != 0x0 ) End = buffer->_memory._end_of_file_p;
        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(buffer->_memory._front + 1, End);
    }

}


namespace max {

    inline size_t
    Lexer_BufferFillerUser_Plain_insert(Lexer_BufferFiller* me,
                                             uint32_t** insertion_p,
                                             uint32_t* BufferEnd,
                                             void* ContentBegin,
                                             void* ContentEnd)
    {
        size_t CopiedByteN = 0;

        (void)me;

        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE((uint32_t*)ContentBegin, (uint32_t*)ContentEnd);
        CopiedByteN = Lexer_MemoryManager_insert((uint8_t*)*insertion_p,
                                                      (uint8_t*)BufferEnd,
                                                      (uint8_t*)ContentBegin,
                                                      (uint8_t*)ContentEnd);

        *insertion_p += (CopiedByteN / sizeof(uint32_t));

        return CopiedByteN;
    }


    inline void*
    Lexer_buffer_fill_region_append_core(::max::Lexer* me,
                                              void* ContentBegin,
                                              void* ContentEnd,
                                              size_t (*insert)(Lexer_BufferFiller* me,
                                                               uint32_t** insertion_p,
                                                               uint32_t* BufferEnd,
                                                               void* ContentBegin,
                                                               void* ContentEnd))




    {
        uint32_t* insertion_p = 0x0;
        size_t CopiedByteN = 0;


        ((me->buffer._content_character_index_begin == 0) ? static_cast<void> (0) : __assert_fail ("me->buffer._content_character_index_begin == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 53, __PRETTY_FUNCTION__));
        ((me->buffer._memory._end_of_file_p != 0x0) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 54, __PRETTY_FUNCTION__));
        ((ContentEnd > ContentBegin) ? static_cast<void> (0) : __assert_fail ("ContentEnd > ContentBegin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 55, __PRETTY_FUNCTION__));
        QUEX_BUFFER_ASSERT_CONSISTENCY(&me->buffer);


        Lexer_Buffer_move_away_passed_content(&me->buffer);


        insertion_p = me->buffer._memory._end_of_file_p;

        CopiedByteN = insert(me->buffer.filler, &insertion_p,
                             me->buffer._memory._back + 1,
                             ContentBegin, ContentEnd);


        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p, insertion_p);


        Lexer_Buffer_end_of_file_set(&me->buffer, insertion_p);





        QUEX_BUFFER_ASSERT_CONSISTENCY(&me->buffer);
        return (uint8_t*)ContentBegin + CopiedByteN;
    }

    inline void*
    Lexer_buffer_fill_region_append(::max::Lexer* me,
                                         void* ContentBegin,
                                         void* ContentEnd)
    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Plain_insert);
    }

    inline void
    Lexer_buffer_fill_region_prepare(::max::Lexer* me)
    {

        Lexer_Buffer_move_away_passed_content(&me->buffer);
    }

    inline uint32_t*
    Lexer_buffer_fill_region_begin(::max::Lexer* me)
    {
        return Lexer_Buffer_text_end(&me->buffer);
    }

    inline uint32_t*
    Lexer_buffer_fill_region_end(::max::Lexer* me)
    {
        return Lexer_Buffer_content_back(&me->buffer) + 1;
    }

    inline size_t
    Lexer_buffer_fill_region_size(::max::Lexer* me)
    {
        ((Lexer_buffer_fill_region_end(me) >= Lexer_buffer_fill_region_begin(me)) ? static_cast<void> (0) : __assert_fail ("Lexer_buffer_fill_region_end(me) >= Lexer_buffer_fill_region_begin(me)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i"
        ,
 115
        , __PRETTY_FUNCTION__))
                                                                 ;

        return (size_t)( Lexer_buffer_fill_region_end(me)
                        - Lexer_buffer_fill_region_begin(me));
    }

    inline void
    Lexer_buffer_fill_region_finish(::max::Lexer* me,
                                         const size_t CharacterN)
    {
        ((me->buffer._memory._end_of_file_p != 0x0) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 125, __PRETTY_FUNCTION__));
        ((me->buffer._memory._end_of_file_p + CharacterN <= me->buffer._memory._back) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p + CharacterN <= me->buffer._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 126, __PRETTY_FUNCTION__));



        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p,
                                                 me->buffer._memory._end_of_file_p + CharacterN);

        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(me->buffer._memory._end_of_file_p,
                                                me->buffer._memory._end_of_file_p + CharacterN);


        Lexer_Buffer_end_of_file_set(&me->buffer,
                                          me->buffer._memory._end_of_file_p + CharacterN);
    }

    inline uint32_t*
    Lexer_buffer_lexeme_start_pointer_get(::max::Lexer* me)
    { return me->buffer._lexeme_start_p; }

    inline void
    Lexer_buffer_input_pointer_set(::max::Lexer* me, uint32_t* Adr)
    { me->buffer._input_p = Adr; }



    inline size_t
    Lexer_BufferFillerUser_Converter_insert(Lexer_BufferFiller* alter_ego,
                                                 uint32_t** insertion_p,
                                                 uint32_t* BufferEnd,
                                                 void* ContentBegin,
                                                 void* ContentEnd)



    {
        size_t CopiedByteN = 0;



        Lexer_BufferFiller_Converter<void>* me = (Lexer_BufferFiller_Converter<void>*)alter_ego;






        Lexer_BufferFiller_Converter_move_away_passed_content(me);

        CopiedByteN = Lexer_MemoryManager_insert(me->raw_buffer.end,
                                                      me->raw_buffer.memory_end,
                                                      (uint8_t*)ContentBegin,
                                                      (uint8_t*)ContentEnd);

        me->raw_buffer.end += CopiedByteN;




        me->converter->convert(me->converter,
                                   &me->raw_buffer.iterator, me->raw_buffer.end,
                                   insertion_p, BufferEnd);

        return CopiedByteN;
    }

    inline size_t
    Lexer_BufferFillerUser_Converter_insert_direct(Lexer_BufferFiller* alter_ego,
                                                        uint32_t** insertion_p,
                                                        uint32_t* BufferEnd,
                                                        void* ContentBegin,
                                                        void* ContentEnd)




    {


        Lexer_BufferFiller_Converter<void>* me = (Lexer_BufferFiller_Converter<void>*)alter_ego;



        uint8_t* read_iterator = (uint8_t*)ContentBegin;

        me->converter->convert(me->converter,
                               &read_iterator, (uint8_t*)ContentEnd,
                               insertion_p, BufferEnd);



        return (size_t)(read_iterator - (uint8_t*)ContentBegin);
    }

    inline void*
    Lexer_buffer_fill_region_append_conversion(::max::Lexer* me,
                                                    void* ContentBegin,
                                                    void* ContentEnd)



    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Converter_insert);
    }

    inline void*
    Lexer_buffer_fill_region_append_conversion_direct(::max::Lexer* me,
                                                           void* ContentBegin,
                                                           void* ContentEnd)




    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Converter_insert_direct);
    }

    inline void
    Lexer_buffer_conversion_fill_region_prepare(::max::Lexer* me)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;






        Lexer_BufferFiller_Converter_move_away_passed_content(filler);
    }

    inline uint8_t*
    Lexer_buffer_conversion_fill_region_begin(::max::Lexer* me)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;



        return filler->raw_buffer.end;
    }

    inline uint8_t*
    Lexer_buffer_conversion_fill_region_end(::max::Lexer* me)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;




        return filler->raw_buffer.memory_end;
    }

    inline size_t
    Lexer_buffer_conversion_fill_region_size(::max::Lexer* me)
    {
        ((Lexer_buffer_conversion_fill_region_end(me) >= Lexer_buffer_conversion_fill_region_begin(me)) ? static_cast<void> (0) : __assert_fail ("Lexer_buffer_conversion_fill_region_end(me) >= Lexer_buffer_conversion_fill_region_begin(me)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i"
        ,
 289
        , __PRETTY_FUNCTION__))
                                                                            ;

        return (size_t)( Lexer_buffer_conversion_fill_region_end(me)
                        - Lexer_buffer_conversion_fill_region_begin(me));
    }

    inline void
    Lexer_buffer_conversion_fill_region_finish(::max::Lexer* me,
                                                    const size_t ByteN)
    {


        Lexer_BufferFiller_Converter<void>* filler = (Lexer_BufferFiller_Converter<void>*)me->buffer.filler;



        uint32_t* insertion_p = 0x0;

        filler->raw_buffer.end += ByteN;


        Lexer_Buffer_move_away_passed_content(&me->buffer);


        insertion_p = me->buffer._memory._end_of_file_p;
        filler->converter->convert(filler->converter,
                                   &filler->raw_buffer.iterator, filler->raw_buffer.end,
                                   &insertion_p, Lexer_Buffer_content_back(&me->buffer) + 1);

        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p, insertion_p);




        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(me->buffer._memory._end_of_file_p, insertion_p);

        Lexer_Buffer_end_of_file_set(&me->buffer, insertion_p);
    }



    inline void*
    Lexer::buffer_fill_region_append(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append(this, ContentBegin, ContentEnd); }

    inline void
    Lexer::buffer_fill_region_prepare()
    { Lexer_buffer_fill_region_prepare(this); }

    inline uint32_t*
    Lexer::buffer_fill_region_begin()
    { return Lexer_buffer_fill_region_begin(this); }

    inline uint32_t*
    Lexer::buffer_fill_region_end()
    { return Lexer_buffer_fill_region_end(this); }

    inline size_t
    Lexer::buffer_fill_region_size()
    { return Lexer_buffer_fill_region_size(this); }

    inline void
    Lexer::buffer_fill_region_finish(const size_t CharacterN)
    { Lexer_buffer_fill_region_finish(this, CharacterN); }

    inline uint32_t*
    Lexer::buffer_lexeme_start_pointer_get()
    { return Lexer_buffer_lexeme_start_pointer_get(this); }

    inline void
    Lexer::buffer_input_pointer_set(uint32_t* Adr)
    { Lexer_buffer_input_pointer_set(this, Adr); }


    inline void*
    Lexer::buffer_fill_region_append_conversion(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append_conversion(this, ContentBegin, ContentEnd); }

    inline void*
    Lexer::buffer_fill_region_append_conversion_direct(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append_conversion_direct(this, ContentBegin, ContentEnd); }

    inline void
    Lexer::buffer_conversion_fill_region_prepare()
    { Lexer_buffer_fill_region_prepare(this); }

    inline uint8_t*
    Lexer::buffer_conversion_fill_region_begin()
    { return Lexer_buffer_conversion_fill_region_begin(this); }

    inline uint8_t*
    Lexer::buffer_conversion_fill_region_end()
    { return Lexer_buffer_conversion_fill_region_end(this); }

    inline size_t
    Lexer::buffer_conversion_fill_region_size()
    { return Lexer_buffer_conversion_fill_region_size(this); }

    inline void
    Lexer::buffer_conversion_fill_region_finish(const size_t ByteN)
    { Lexer_buffer_conversion_fill_region_finish(this, ByteN); }




}

namespace max {

inline void
Lexer_set_callback_on_buffer_content_change(::max::Lexer* me,
                                                 void (*callback)(uint32_t*,
                                                                                uint32_t*))
{ me->buffer.on_buffer_content_change = callback; }

inline ::max::Token*
Lexer_token_p(::max::Lexer* me)
{

    return ((*(Lexer*)me).token);

}
inline const char*
Lexer_version(::max::Lexer* me)
{
    (void)me;
    return "QUEX_TYPE_ANALYZER"
           ": Version " "0.0.0-pre-release"
           ". Date " "Thu Mar 29 07:48:50 2012"
           "Generated by Quex " "0.62.2" ".";
}

inline bool
Lexer_byte_order_reversion(::max::Lexer* me)
{ return me->buffer._byte_order_reversion_active_f; }

inline void
Lexer_byte_order_reversion_set(::max::Lexer* me, bool Value)
{ me->buffer._byte_order_reversion_active_f = Value; }


inline void
Lexer_print_this(::max::Lexer* me)
{
    Lexer_Mode** iterator = 0x0;

    std::printf("   CurrentMode = %s;\n",
                      me->__current_mode_p == 0x0 ? "0x0" : me->__current_mode_p->name);

    Lexer_Buffer_print_this(&me->buffer);


    Lexer_Accumulator_print_this(&me->accumulator);


    Lexer_Counter_print_this(&me->counter);





    std::printf("   Mode Stack (%i/%i) = [",
                      (int)(me->_mode_stack.end - me->_mode_stack.begin),
                      (int)(me->_mode_stack.memory_end - me->_mode_stack.begin));
    for(iterator=me->_mode_stack.end-1; iterator >= me->_mode_stack.begin; --iterator)
        std::printf("%s, ", (*iterator)->name);

    std::printf("]\n");
    std::printf("   ByteOrderInversion = %s;\n",
                      Lexer_byte_order_reversion(me) ? "true" : "false");
}


inline void
Lexer::set_callback_on_buffer_content_change(void (*callback)(uint32_t*,
                                                            uint32_t*))
{ Lexer_set_callback_on_buffer_content_change(this, callback); }

inline ::max::Token*
Lexer::token_p()
{ return Lexer_token_p(this); }
inline const char*
Lexer::version() const
{ return Lexer_version((::max::Lexer*)this); }

inline void
Lexer::print_this()
{ Lexer_print_this(this); }

inline bool
Lexer::byte_order_reversion()
{ return Lexer_byte_order_reversion(this); }

inline void
Lexer::byte_order_reversion_set(bool Value)
{ Lexer_byte_order_reversion_set(this, Value); }


}
namespace max {

inline size_t
Lexer_tell(::max::Lexer* me)
{

    return (size_t)Lexer_Buffer_tell(&me->buffer);
}

inline void
Lexer_seek(::max::Lexer* me, const size_t CharacterIndex)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint32_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint32_t)'\0'; };
    Lexer_Buffer_seek(&me->buffer, (ptrdiff_t)CharacterIndex);
}

inline void
Lexer_seek_forward(::max::Lexer* me, const size_t CharacterN)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint32_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint32_t)'\0'; };
    Lexer_Buffer_move_forward(&me->buffer, (ptrdiff_t)CharacterN);
}

inline void
Lexer_seek_backward(::max::Lexer* me, const size_t CharacterN)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint32_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint32_t)'\0'; };
    Lexer_Buffer_move_backward(&me->buffer, (ptrdiff_t)CharacterN);
}

inline void
Lexer_undo(::max::Lexer* me)
{
    me->counter._line_number_at_end = me->counter._line_number_at_begin;
    me->counter._column_number_at_end = me->counter._column_number_at_begin;

    if( (&me->buffer)->_character_at_lexeme_start != (uint32_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint32_t)'\0'; };

    me->buffer._input_p = me->buffer._lexeme_start_p;

    (&me->buffer)->_character_at_lexeme_start = *((&me->buffer)->_input_p); *((&me->buffer)->_input_p) = '\0';;
}

inline void
Lexer_undo_n(::max::Lexer* me, size_t DeltaN_Backward)
{
    me->counter._line_number_at_end = me->counter._line_number_at_begin;
    me->counter._column_number_at_end = me->counter._column_number_at_begin;

    if( (&me->buffer)->_character_at_lexeme_start != (uint32_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint32_t)'\0'; };

    me->buffer._input_p -= (ptrdiff_t)DeltaN_Backward;

    (&me->buffer)->_character_at_lexeme_start = *((&me->buffer)->_input_p); *((&me->buffer)->_input_p) = '\0';;

    ((me->buffer._input_p >= me->buffer._lexeme_start_p) ? static_cast<void> (0) : __assert_fail ("me->buffer._input_p >= me->buffer._lexeme_start_p", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/navigation.i", 64, __PRETTY_FUNCTION__));
}



inline size_t
Lexer::tell()
{ return Lexer_tell(this); }

inline void
Lexer::seek(const size_t CharacterIndex)
{ Lexer_seek(this, CharacterIndex); }

inline void
Lexer::seek_forward(const size_t CharacterN)
{ Lexer_seek_forward(this, CharacterN); }

inline void
Lexer::seek_backward(const size_t CharacterN)
{ Lexer_seek_backward(this, CharacterN); }

inline void
Lexer::undo()
{ return Lexer_undo(this); }

inline void
Lexer::undo(size_t DeltaN_Backward)
{ return Lexer_undo_n(this, DeltaN_Backward); }



}















namespace max {

    inline void Lexer_Buffer_x_show_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_brief_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_content(Lexer_Buffer*);

    inline void
    Lexer_Buffer_show_brief_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_x_show_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_content_intern(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_byte_content(Lexer_Buffer* buffer, const int IndentationN);

}


namespace max {

    inline void Lexer_Buffer_x_show_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_brief_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_content(Lexer_Buffer*);

    inline void
    Lexer_Buffer_show_brief_content(Lexer_Buffer* buffer)
    {
        Lexer_BufferFiller* me = buffer->filler;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 25, __PRETTY_FUNCTION__));
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 26, __PRETTY_FUNCTION__));

        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        std::printf("Begin of Buffer Character Index: %i\n", (int)buffer->_content_character_index_begin);
        std::printf("End   of Buffer Character Index: %i\n", (int)me->tell_character_index(me));
        if( buffer->_memory._end_of_file_p == 0x0 )
            std::printf("_memory._memory._end_of_file_p (offset)  = <0x0>\n");
        else
            std::printf("_memory._end_of_file_p (offset)  = %08X\n",
                              (int)(buffer->_memory._end_of_file_p - buffer->_memory._front));
        std::printf("_input_p (offset)        = %08X\n", (int)(buffer->_input_p - buffer->_memory._front));
        std::printf("_lexeme_start_p (offset) = %08X\n", (int)(buffer->_lexeme_start_p - buffer->_memory._front));
        std::printf("_back (offset)           = %08X\n", (int)(buffer->_memory._back - buffer->_memory._front));
    }

    inline void
    Lexer_Buffer_x_show_content(Lexer_Buffer* buffer)
    {
        Lexer_Buffer_show_content_intern(buffer);
        Lexer_Buffer_show_brief_content(buffer);
    }

    inline uint32_t
    Lexer___Buffer_get_border_char(Lexer_Buffer* buffer, const uint32_t* C)
    {
        if ( *C != ((uint32_t)0x0) )
            return (uint32_t)'?';
        else if( buffer->_memory._end_of_file_p == C )
            return (uint32_t)']';
        else if( buffer->_content_character_index_begin == 0 && buffer->_memory._front == C )
            return (uint32_t)'[';
        else
            return (uint32_t)'|';
    }

    inline void
    Lexer_Buffer_show_content_intern(Lexer_Buffer* buffer)
    {
        size_t i = 0;
        size_t length = 0;

        uint32_t EmptyChar = (uint32_t)(-1);
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint32_t* BufferFront = buffer->_memory._front;
        uint32_t* BufferBack = buffer->_memory._back;
        uint32_t* iterator = 0x0;
        uint32_t* end_p = buffer->_memory._end_of_file_p != 0x0 ? buffer->_memory._end_of_file_p
                                         : buffer->_memory._back;

        std::printf("|%c", (int)Lexer___Buffer_get_border_char(buffer, BufferFront));
        for(iterator = ContentFront; iterator != end_p; ++iterator) {
            std::printf("%c", *iterator == EmptyChar ? (int)'~' : (int)*iterator);
        }
        std::printf("%c", (int)Lexer___Buffer_get_border_char(buffer, end_p));

        length = (buffer->_memory._end_of_file_p == 0x0) ? 0 : (size_t)(BufferBack - buffer->_memory._end_of_file_p);
        for(i=0; i < length; ++i) std::printf("|");

        std::printf("|");
    }

    inline void
    Lexer_Buffer_show_content(Lexer_Buffer* buffer)
    {




        size_t i = 0;
        char* tmp = 0;
        const size_t ContentSize = Lexer_Buffer_content_size(buffer);
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint32_t* BufferFront = buffer->_memory._front;
        uint32_t* BufferBack = buffer->_memory._back;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 101, __PRETTY_FUNCTION__));

        tmp = (char*)std::malloc(ContentSize + 4);






        for(i=2; i<ContentSize + 2 ; ++i) tmp[i] = ' ';
        tmp[ContentSize+4] = '\0';
        tmp[ContentSize+3] = '|';
        tmp[ContentSize+2] = (char)Lexer___Buffer_get_border_char(buffer, BufferBack);
        tmp[1] = (char)Lexer___Buffer_get_border_char(buffer, BufferFront);
        tmp[0] = '|';

        tmp[buffer->_input_p - ContentFront + 2] = 'C';
        if( buffer->_lexeme_start_p >= ContentFront && buffer->_lexeme_start_p <= BufferBack )
            tmp[(int)(buffer->_lexeme_start_p - ContentFront) + 2] = 'S';

        if ( buffer->_input_p == ContentFront - 2 ) {
            std::printf("%s", tmp);
            std::printf(" <out>");
        } else {
            std::printf(" ");
            if( *buffer->_input_p == ((uint32_t)0x0) )
                std::printf("BLC");
            else
                std::printf("'%c'", (char)(*buffer->_input_p));
        }

        std::printf("\n");
        Lexer_Buffer_show_content_intern(buffer);
        std::free(tmp);
    }

    inline void
    Lexer_Buffer_show_byte_content(Lexer_Buffer* buffer, const int IndentationN)
    {
        Lexer_BufferMemory* memory = &buffer->_memory;

        int i = 0, j = 0;
        uint8_t* byte_p = (uint8_t*)memory->_front;
        uint8_t* next_byte_p = (uint8_t*)memory->_front + 1;
        uint8_t* End = (uint8_t*)(memory->_back + 1);

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 147, __PRETTY_FUNCTION__));
        ((memory != 0x0) ? static_cast<void> (0) : __assert_fail ("memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 148, __PRETTY_FUNCTION__));

        for(j=0; j<IndentationN; ++j) fprintf(stdout, " ");
        for(; byte_p != End; ++byte_p, ++next_byte_p, ++i) {
            fprintf(stdout, "%02X", (int)*byte_p);
            if ( next_byte_p == (uint8_t*)buffer->_memory._end_of_file_p )
                fprintf(stdout, "[");
            else if( byte_p == (uint8_t*)buffer->_memory._end_of_file_p + sizeof(uint32_t)-1)
                fprintf(stdout, "]");
            else
                fprintf(stdout, ".");
            if( (i+1) % 0x8 == 0 ) fprintf(stdout, " ");
            if( (i+1) % 0x10 == 0 ) {
                fprintf(stdout, "\n");
                for(j=0; j<IndentationN; ++j) fprintf(stdout, " ");
            }
        }
        fprintf(stdout, "\n");
    }

    inline void
    Lexer_Buffer_show_debug_print_lines(uint32_t** iterator,
                                             uint32_t* Begin,
                                             uint32_t* TotalEnd,
                                             Lexer_Buffer* buffer)
    {
        int length = 0;
        uint32_t* end = Begin + 5 > TotalEnd ? TotalEnd : Begin + 5;

        if( Begin > *iterator ) {
            *iterator = Begin;
            std::fprintf(stderr, "                                           ...\n");
        } else if( *iterator >= end ) {
            return;
        }

        for(; *iterator < end; ++*iterator) {
            length = 0;
            std::fprintf(stderr, "   ");

            if( *iterator == buffer->_memory._front ) {
                std::fprintf(stderr, "buffer front");
                length += 12;
            }
            if( *iterator == buffer->_lexeme_start_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "lexeme start");
                length += 12;
            }
            if( *iterator == buffer->_input_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "input");
                length += 5;
            }
            if( *iterator == buffer->_memory._end_of_file_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "end of file");
                length += 11;
            }
            if( *iterator == buffer->_memory._back ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "buffer back");
                length += 11;
            }
            if( length ) {
                for(; length < 39; ++length)
                    std::fprintf(stderr, "-");
                std::fprintf(stderr, ">");
            } else {
                std::fprintf(stderr, "                                        ");
            }


            std::fprintf(stderr, "[%04X] 0x%04X\n",
                               (int)(*iterator - buffer->_memory._front),
                               (int)(**iterator));
        }
    }

    inline void
    Lexer_Buffer_show_debug_content(Lexer_Buffer* buffer)
    {
        uint32_t* iterator = buffer->_memory._front;
        uint32_t* total_end = buffer->_memory._back + 1;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 243, __PRETTY_FUNCTION__));
        std::fprintf(stderr, "_________________________________________________________________\n");
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._front, total_end, buffer);
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_lexeme_start_p - 2, total_end, buffer);
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_input_p - 2, total_end, buffer);
        if( buffer->_memory._end_of_file_p != 0x0 ) {
            Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._end_of_file_p - 4, total_end, buffer);
        }
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._back - 4, total_end, buffer);
        std::fprintf(stderr, "_________________________________________________________________\n");
    }

}



namespace max {

    inline void Lexer_Buffer_init(Lexer_Buffer* me,
                                             bool ByteOrderReversionF);
    inline void Lexer_Buffer_init_analyzis(Lexer_Buffer* me,
                                                      bool ByteOrderReversionF);
    inline void
    Lexer_BufferMemory_construct(Lexer_BufferMemory* me,
                                      uint32_t* Memory,
                                      const size_t Size,
                                      uint32_t* EndOfFileP);
    inline void
    Lexer_BufferMemory_init(Lexer_BufferMemory* me,
                                 uint32_t* Memory,
                                 const size_t Size,
                                 uint32_t* EndOfFileP,
                                 bool ExternalOwnerF);
    inline void Lexer_BufferMemory_destruct(Lexer_BufferMemory* me);

    template <class InputHandleT> inline void
    Lexer_Buffer_construct(Lexer_Buffer* me,
                                InputHandleT* input_handle,
                                uint32_t* InputMemory,
                                const size_t MemorySize,
                                uint32_t* EndOfFileP,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize,
                                bool ByteOrderReversionF)







    {

        if( input_handle != 0x0 ) ((InputMemory == 0x0) ? static_cast<void> (0) : __assert_fail ("InputMemory == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 53, __PRETTY_FUNCTION__));
        if( InputMemory != 0x0 ) {
            ((input_handle == 0x0) ? static_cast<void> (0) : __assert_fail ("input_handle == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 55, __PRETTY_FUNCTION__));

            QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(InputMemory + 1, EndOfFileP);
        }




        Lexer_BufferMemory_construct(&(me->_memory),
                                          InputMemory, MemorySize, EndOfFileP);

        me->on_buffer_content_change = 0x0;

        me->filler = Lexer_BufferFiller_new(input_handle, CharacterEncodingName, TranslationBufferMemorySize);


        Lexer_Buffer_init(me, ByteOrderReversionF);

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
        ((me->_input_p == me->_memory._front + 1) ? static_cast<void> (0) : __assert_fail ("me->_input_p == me->_memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 75, __PRETTY_FUNCTION__));
    }

    template <class InputHandleT> inline void
    Lexer_Buffer_reset(Lexer_Buffer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            const size_t TranslationBufferMemorySize)
    {

        if( me->filler != 0x0 ) {


            me->filler->seek_character_index(me->filler, 0);
            me->filler->delete_self(me->filler);
        }
        me->filler = Lexer_BufferFiller_new(input_handle, CharacterEncodingName, TranslationBufferMemorySize);

        Lexer_Buffer_init_analyzis(me, me->_byte_order_reversion_active_f);

        if( me->filler != 0x0 ) {

            Lexer_BufferFiller_initial_load(me);
        } else {
            me->_content_character_index_begin = 0;
            me->_content_character_index_end = 0;
        }

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
        ((me->_input_p == me->_memory._front + 1) ? static_cast<void> (0) : __assert_fail ("me->_input_p == me->_memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 114, __PRETTY_FUNCTION__));
    }

    inline void
    Lexer_Buffer_init(Lexer_Buffer* me, bool ByteOrderReversionF)
    {


        me->_content_character_index_end = 0;
        me->_content_character_index_begin = 0;

        Lexer_Buffer_init_analyzis(me, ByteOrderReversionF);

        if( me->filler != 0x0 ) {

            Lexer_BufferFiller_initial_load(me);
        }

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
    }

    inline void
    Lexer_Buffer_init_analyzis(Lexer_Buffer* me, bool ByteOrderReversionF)
    {
        me->_byte_order_reversion_active_f = ByteOrderReversionF;


        me->_input_p = me->_memory._front + 1;
        me->_lexeme_start_p = me->_memory._front + 1;




        me->_character_at_lexeme_start = '\0';



    }

    inline void
    Lexer_Buffer_destruct(Lexer_Buffer* me)
    {
        if( me->filler != 0x0 ) {
            me->filler->delete_self(me->filler);
            me->filler = 0x0;
        }

        Lexer_BufferMemory_destruct(&me->_memory);
    }

    inline void
    Lexer_Buffer_input_p_add_offset(Lexer_Buffer* buffer, const size_t Offset)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(buffer);
        buffer->_input_p += Offset;
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(buffer);
    }

    inline Lexer_MemoryPositionMimiker
    Lexer_Buffer_tell_memory_adr(Lexer_Buffer* buffer)
    {





        return Lexer_MemoryPositionMimiker(buffer->_input_p, buffer->_content_character_index_begin);



    }

    inline void
    Lexer_Buffer_seek_memory_adr(Lexer_Buffer* buffer, Lexer_MemoryPositionMimiker Position)
    {





        ((Position.buffer_start_position == (size_t)buffer->_content_character_index_begin) ? static_cast<void> (0) : __assert_fail ("Position.buffer_start_position == (size_t)buffer->_content_character_index_begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 195, __PRETTY_FUNCTION__));
        buffer->_input_p = Position.address;



        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
    }

    inline uint32_t
    Lexer_Buffer_input_get_offset(Lexer_Buffer* me, const ptrdiff_t Offset)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(me);
        ((me->_input_p + Offset > me->_memory._front) ? static_cast<void> (0) : __assert_fail ("me->_input_p + Offset > me->_memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 207, __PRETTY_FUNCTION__));
        ((me->_input_p + Offset <= me->_memory._back) ? static_cast<void> (0) : __assert_fail ("me->_input_p + Offset <= me->_memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 208, __PRETTY_FUNCTION__));
        return *(me->_input_p + Offset);
    }

    inline uint32_t*
    Lexer_Buffer_content_front(Lexer_Buffer* me)
    {
        return me->_memory._front + 1;
    }

    inline uint32_t*
    Lexer_Buffer_content_back(Lexer_Buffer* me)
    {
        return me->_memory._back - 1;
    }

    inline size_t
    Lexer_Buffer_content_size(Lexer_Buffer* me)
    {
        return Lexer_BufferMemory_size(&(me->_memory)) - 2;
    }

    inline uint32_t*
    Lexer_Buffer_text_end(Lexer_Buffer* me)
    {

        if( me->_memory._end_of_file_p != 0 ) return me->_memory._end_of_file_p;
        else return me->_memory._back;
    }

    inline ptrdiff_t
    Lexer_Buffer_distance_input_to_text_end(Lexer_Buffer* me)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(me);
        return Lexer_Buffer_text_end(me) - me->_input_p;
    }

    inline void
    Lexer_Buffer_end_of_file_set(Lexer_Buffer* me, uint32_t* Position)
    {


        me->_memory._end_of_file_p = Position;
        *(me->_memory._end_of_file_p) = ((uint32_t)0x0);


    }

    inline void
    Lexer_Buffer_end_of_file_unset(Lexer_Buffer* buffer)
    {



        buffer->_memory._end_of_file_p = 0x0;

    }

    inline bool
    Lexer_Buffer_is_end_of_file(Lexer_Buffer* buffer)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        return buffer->_input_p == buffer->_memory._end_of_file_p;
    }

    inline bool
    Lexer_Buffer_is_begin_of_file(Lexer_Buffer* buffer)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        if ( buffer->_input_p != buffer->_memory._front ) return false;
        else if( buffer->_content_character_index_begin != 0 ) return false;
        return true;
    }

    inline void
    Lexer_Buffer_move_forward(Lexer_Buffer* me, const ptrdiff_t CharacterN)
    {
       QUEX_BUFFER_ASSERT_CONSISTENCY(me);


       if( CharacterN < Lexer_Buffer_distance_input_to_text_end(me) ) {

           me->_input_p += CharacterN;
       }
       else {

           if( me->filler == 0x0 || me->_memory._end_of_file_p != 0x0 ) {
               me->_input_p = Lexer_Buffer_text_end(me);
           } else {

               ptrdiff_t delta = CharacterN;
               ptrdiff_t distance = Lexer_Buffer_distance_input_to_text_end(me);
               do {
                   delta -= distance;

                   me->_input_p = me->_memory._back;
                   me->_lexeme_start_p = me->_input_p;
                   if( Lexer_BufferFiller_load_forward(me) == 0 ) {
                       me->_input_p = Lexer_Buffer_text_end(me);
                       break;
                   }

                   ++(me->_input_p);
                   distance = Lexer_Buffer_distance_input_to_text_end(me);

                   if( delta < distance ) {

                       me->_input_p += delta;
                       break;
                   }
               } while( 1 + 1 == 2 );
           }
       }
       me->_lexeme_start_p = me->_input_p;
       me->_character_at_lexeme_start = *(me->_lexeme_start_p);




       QUEX_BUFFER_ASSERT_CONSISTENCY(me);
    }

    inline void
    Lexer_Buffer_move_backward(Lexer_Buffer* me, const ptrdiff_t CharacterN)
    {
       QUEX_BUFFER_ASSERT_CONSISTENCY(me);


       if( CharacterN < (me->_input_p - Lexer_Buffer_content_front(me)) ) {

           me->_input_p -= CharacterN;
       }
       else {

           if( me->filler == 0x0 || me->_content_character_index_begin == 0 ) {
               me->_input_p = Lexer_Buffer_content_front(me);
           } else {

               ptrdiff_t delta = (ptrdiff_t)CharacterN;
               ptrdiff_t distance = (ptrdiff_t)(me->_input_p - Lexer_Buffer_content_front(me));
               do {
                   delta -= distance;

                   me->_input_p = me->_memory._front;
                   me->_lexeme_start_p = me->_input_p + 1;
                   if( Lexer_BufferFiller_load_backward(me) == 0 ) {
                       me->_input_p = Lexer_Buffer_content_front(me);
                       break;
                   }

                   distance = (ptrdiff_t)(me->_input_p - Lexer_Buffer_content_front(me));

                   if( delta < distance ) {

                       me->_input_p -= delta;
                       break;
                   }
               } while( 1 + 1 == 2 );
           }
       }
       me->_lexeme_start_p = me->_input_p;
       me->_character_at_lexeme_start = *(me->_lexeme_start_p);




       QUEX_BUFFER_ASSERT_CONSISTENCY(me);
    }

    inline ptrdiff_t
    Lexer_Buffer_tell(Lexer_Buffer* me)
    {




        const ptrdiff_t DeltaToBufferBegin = me->_input_p - me->_memory._front - 1;


        if( me->filler == 0x0 )
            return DeltaToBufferBegin;
        else
            return DeltaToBufferBegin + me->_content_character_index_begin;
    }

    inline void
    Lexer_Buffer_seek(Lexer_Buffer* me, const ptrdiff_t CharacterIndex)
    {


        const ptrdiff_t CurrentCharacterIndex = Lexer_Buffer_tell(me);
        if( CharacterIndex > CurrentCharacterIndex )
            Lexer_Buffer_move_forward(me, CharacterIndex - CurrentCharacterIndex);
        else
            Lexer_Buffer_move_backward(me, CurrentCharacterIndex - CharacterIndex);
    }

    inline void
    Lexer_Buffer_move_away_passed_content(Lexer_Buffer* me)
    {
        uint32_t* ContentFront = Lexer_Buffer_content_front(me);
        uint32_t* RemainderBegin = me->_input_p;
        uint32_t* RemainderEnd = me->_memory._end_of_file_p;
        uint32_t* MoveRegionBegin = RemainderBegin - (ptrdiff_t)(256);
        ptrdiff_t MoveRegionSize = (ptrdiff_t)(RemainderEnd - MoveRegionBegin);


        ((me->_content_character_index_begin == 0) ? static_cast<void> (0) : __assert_fail ("me->_content_character_index_begin == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 431, __PRETTY_FUNCTION__));


        if( MoveRegionBegin <= ContentFront ) { return; }

        std::memmove((void*)ContentFront,
                           (void*)MoveRegionBegin,
                           (size_t)MoveRegionSize * sizeof(uint32_t));





        Lexer_Buffer_end_of_file_set(me, ContentFront + MoveRegionSize);




        me->_input_p = ContentFront + (256);



        me->_lexeme_start_p = me->_input_p;
    }

    inline size_t
    Lexer_BufferMemory_size(Lexer_BufferMemory* me)
    { return (size_t)(me->_back - me->_front + 1); }

    inline void
    Lexer_Buffer_reverse_byte_order(uint32_t* Begin, uint32_t* End)
    {
        uint8_t tmp = 0xFF;
        uint32_t* iterator = 0x0;

        switch( sizeof(uint32_t) ) {
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 468, __PRETTY_FUNCTION__));
            break;
        case 1:

            break;
        case 2:
            for(iterator=Begin; iterator != End; ++iterator) {
                tmp = *(((uint8_t*)iterator) + 0);
                *(((uint8_t*)iterator) + 0) = *(((uint8_t*)iterator) + 1);
                *(((uint8_t*)iterator) + 1) = tmp;
            }
            break;
        case 4:
            for(iterator=Begin; iterator != End; ++iterator) {
                tmp = *(((uint8_t*)iterator) + 0);
                *(((uint8_t*)iterator) + 0) = *(((uint8_t*)iterator) + 3);
                *(((uint8_t*)iterator) + 3) = tmp;
                tmp = *(((uint8_t*)iterator) + 1);
                *(((uint8_t*)iterator) + 1) = *(((uint8_t*)iterator) + 2);
                *(((uint8_t*)iterator) + 2) = tmp;
            }
            break;
        }
    }

    inline void
    Lexer_BufferMemory_construct(Lexer_BufferMemory* me,
                                      uint32_t* Memory,
                                      const size_t Size,
                                      uint32_t* EndOfFileP)


    {
        uint32_t* chunk = Memory;
        uint32_t* end_of_file_p = EndOfFileP;
        bool external_f = true;

        if( Memory == 0x0 ) {


            chunk = Lexer_MemoryManager_BufferMemory_allocate(Size * sizeof(uint32_t));
            end_of_file_p = 0x0;
            external_f = false;
        }

        Lexer_BufferMemory_init(me, chunk, Size, end_of_file_p, external_f);
    }

    inline uint32_t*
    Lexer_BufferMemory_reset(Lexer_BufferMemory* me,
                                  uint32_t* Memory,
                                  const size_t Size,
                                  uint32_t* EndOfContentP)

    {
        uint32_t* old_memory = (me->_external_owner_f) ? me->_front : 0x0;

        if( Memory == 0x0 ) return old_memory;


        Lexer_BufferMemory_destruct(me);


        ((Memory != 0x0) ? static_cast<void> (0) : __assert_fail ("Memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 531, __PRETTY_FUNCTION__));


        ((EndOfContentP > Memory) ? static_cast<void> (0) : __assert_fail ("EndOfContentP > Memory", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 534, __PRETTY_FUNCTION__));
        ((EndOfContentP <= Memory + Size) ? static_cast<void> (0) : __assert_fail ("EndOfContentP <= Memory + Size", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 535, __PRETTY_FUNCTION__));

        Lexer_BufferMemory_init(me, Memory, Size, EndOfContentP, true);

        return old_memory;
    }

    inline void
    Lexer_BufferMemory_init(Lexer_BufferMemory* me,
                                 uint32_t* Memory,
                                 const size_t Size,
                                 uint32_t* EndOfFileP,
                                 bool ExternalOwnerF)
    {


        ((Memory != 0x0) ? static_cast<void> (0) : __assert_fail ("Memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 551, __PRETTY_FUNCTION__));
        ((Size != 0) ? static_cast<void> (0) : __assert_fail ("Size != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 552, __PRETTY_FUNCTION__));

        if( Size <= (256) + 2) {
            do { throw std::runtime_error("Error: Tried to initialize buffer memory with a size less or equal\n" "Error: to QUEX_SETTING_BUFFER_MIN_FALLBACK_N + 2. Maybe, define\n" "Error: -DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=0, if no pre-contexts\n" "Error: are involved."); } while(0)


                                                   ;
        }
        else if( EndOfFileP != 0x0 ) {
            ((EndOfFileP > Memory) ? static_cast<void> (0) : __assert_fail ("EndOfFileP > Memory", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 561, __PRETTY_FUNCTION__));
            ((EndOfFileP <= Memory + Size) ? static_cast<void> (0) : __assert_fail ("EndOfFileP <= Memory + Size", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 562, __PRETTY_FUNCTION__));
        }


        me->_front = Memory;
        me->_end_of_file_p = EndOfFileP;
        me->_back = Memory + (Size - 1);
        me->_external_owner_f = ExternalOwnerF;
        *(me->_front) = ((uint32_t)0x0);
        *(me->_back) = ((uint32_t)0x0);
        if( me->_end_of_file_p != 0x0 ) {
            *(me->_end_of_file_p) = ((uint32_t)0x0);
        }


        if( EndOfFileP != 0x0 ) {
           if( EndOfFileP < me->_back - 1 ) {
               std::memset(EndOfFileP + 1, 0xFF, (size_t)((me->_back - EndOfFileP) - (ptrdiff_t)(1)));
            }
        }

    }

    inline void
    Lexer_BufferMemory_destruct(Lexer_BufferMemory* me)
    {
        if( me->_external_owner_f == false && me->_front != (uint32_t*)0x0 ) {
            Lexer_MemoryManager_BufferMemory_free(me->_front);

        }

        me->_front = me->_back = (uint32_t*)0x0;
    }

    inline void
    Lexer_Buffer_print_this(Lexer_Buffer* me)
    {
        uint32_t* Offset = me->_memory._front;

        std::printf("   Buffer:\n");
        std::printf("      Memory:\n");
        std::printf("      _front         =  0;\n");
        std::printf("      _back          = +0x%X;\n", (int)(me->_memory._back - Offset));
        if( me->_memory._end_of_file_p != 0x0 )
            std::printf("      _end_of_file_p = +0x%X;\n", (int)(me->_memory._end_of_file_p - Offset));
        else
            std::printf("      _end_of_file_p = <void>;\n");


        std::printf("      _external_owner_f = %s;\n", me->_memory._external_owner_f ? "true" : "false");

        std::printf("   _input_p        = +0x%X;\n", (int)(me->_input_p - Offset));
        std::printf("   _lexeme_start_p = +0x%X;\n", (int)(me->_lexeme_start_p - Offset));

        std::printf("   _character_at_lexeme_start = %X;\n", (int)me->_character_at_lexeme_start);



        std::printf("   _content_character_index_begin = %i;\n", (int)me->_content_character_index_begin);
        std::printf("   _content_character_index_end   = %i;\n", (int)me->_content_character_index_end);
        std::printf("   _byte_order_reversion_active_f = %s;\n", me->_byte_order_reversion_active_f ? "true" : "false");
    }

}




namespace max {

    inline uint8_t*
    Lexer_MemoryManager_Default_allocate(const size_t ByteN)
    {
         uint8_t* result = (uint8_t*)std::malloc((size_t)ByteN);

         std::memset((void*)result, 0xFF, ByteN);

         return result;
    }

    inline void
    Lexer_MemoryManager_Default_free(void* Obj)
    { std::free(Obj); }

    struct __QuexBufferFiller_tag;
    inline uint32_t*
    Lexer_MemoryManager_BufferMemory_allocate(const size_t ByteN)
    { return (uint32_t*)Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferMemory_free(uint32_t* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }

    inline void*
    Lexer_MemoryManager_BufferFiller_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferFiller_free(void* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }

    inline uint8_t*
    Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free(memory); }


    inline void*
    Lexer_MemoryManager_Converter_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_Converter_free(void* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }



    inline uint32_t*
    Lexer_MemoryManager_Text_allocate(const size_t ByteN)
    { return (uint32_t*)Lexer_MemoryManager_Default_allocate(ByteN); }

    extern uint32_t Lexer_LexemeNullObject;

    inline void
    Lexer_MemoryManager_Text_free(uint32_t* memory)
    {

        ((memory != &(Lexer_LexemeNullObject)) ? static_cast<void> (0) : __assert_fail ("memory != &(Lexer_LexemeNullObject)", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 92, __PRETTY_FUNCTION__));

        if( memory != 0x0 ) {
            Lexer_MemoryManager_Default_free((void*)memory);
        }
    }
    inline size_t
    Lexer_MemoryManager_insert(uint8_t* drain_begin_p, uint8_t* drain_end_p,
                                    uint8_t* source_begin_p, uint8_t* source_end_p)





    {

        const size_t DrainSize = (size_t)(drain_end_p - drain_begin_p);
        size_t size = (size_t)(source_end_p - source_begin_p);
        ((drain_end_p >= drain_begin_p) ? static_cast<void> (0) : __assert_fail ("drain_end_p >= drain_begin_p", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 137, __PRETTY_FUNCTION__));
        ((source_end_p >= source_begin_p) ? static_cast<void> (0) : __assert_fail ("source_end_p >= source_begin_p", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 138, __PRETTY_FUNCTION__));

        if( DrainSize < size ) size = DrainSize;



        if( drain_begin_p > source_begin_p ) ((drain_begin_p >= source_begin_p + size) ? static_cast<void> (0) : __assert_fail ("drain_begin_p >= source_begin_p + size", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 144, __PRETTY_FUNCTION__));
        else ((drain_begin_p <= source_begin_p - size) ? static_cast<void> (0) : __assert_fail ("drain_begin_p <= source_begin_p - size", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 145, __PRETTY_FUNCTION__));

        std::memcpy(drain_begin_p, source_begin_p, size);

        return size;
    }
    inline Lexer_Memento*
    Lexer_MemoryManager_Memento_allocate()
    {
        const size_t MemorySize = sizeof(Lexer_Memento);
        return (Lexer_Memento*)Lexer_MemoryManager_Default_allocate(MemorySize);
    }

    inline void
    Lexer_MemoryManager_Memento_free(struct Lexer_Memento_tag* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }


}



namespace max {

inline void
Lexer_construct_memory(::max::Lexer* me,
                            uint32_t* BufferMemoryBegin,
                            size_t BufferMemorySize,
                            uint32_t* BufferEndOfContentP,
                            const char* CharacterEncodingName ,
                            bool ByteOrderReversionF )
{
    size_t memory_size = BufferMemoryBegin != 0 ? BufferMemorySize
                          : 65536;

    uint32_t* iterator = 0x0;

    ((memory_size == 0 || memory_size > 2) ? static_cast<void> (0) : __assert_fail ("memory_size == 0 || memory_size > 2", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 26, __PRETTY_FUNCTION__));
    if( BufferMemoryBegin != 0x0 ) {


        if( BufferMemorySize <= (256) + 2) {
            do { throw std::runtime_error("\nConstructor: Provided memory size must be more than 2 greater than\n" "Constructor: QUEX_SETTING_BUFFER_MIN_FALLBACK_N. If in doubt, specify\n" "Constructor: -DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=0 as compile option.\n"); } while(0)

                                                                                                       ;
        }
        if( BufferEndOfContentP < BufferMemoryBegin
            || BufferEndOfContentP > (BufferMemoryBegin + BufferMemorySize - 1)) {
            do { throw std::runtime_error("\nConstructor: Argument 'BufferEndOfContentP' must be inside the provided memory\n" "Constructor: buffer (speficied by 'BufferMemoryBegin' and 'BufferMemorySize').\n" "Constructor: Note, that the last element of the buffer is to be filled with\n" "Constructor: the buffer limit code character.\n"); } while(0)


                                                                              ;
        }
    }
    if( BufferEndOfContentP != 0x0 ) {
        ((BufferEndOfContentP > BufferMemoryBegin) ? static_cast<void> (0) : __assert_fail ("BufferEndOfContentP > BufferMemoryBegin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 44, __PRETTY_FUNCTION__));
        ((BufferEndOfContentP <= BufferMemoryBegin + memory_size - 1) ? static_cast<void> (0) : __assert_fail ("BufferEndOfContentP <= BufferMemoryBegin + memory_size - 1", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 45, __PRETTY_FUNCTION__));



        for(iterator = BufferMemoryBegin + 1; iterator != BufferEndOfContentP; ++iterator) {
            if( *iterator == ((uint32_t)0x0)
                || *iterator == ((uint32_t)0x1) ) {
                do { throw std::runtime_error("\nConstructor: Buffer limit code and/or path termination code appeared in buffer\n" "Constructor: when pointed to user memory. Note, that the memory pointed to must\n" "Constructor: be initialized! You might redefine QUEX_SETTING_PATH_TERMINATION_CODE\n" "Constructor: and/or QUEX_SETTING_PATH_TERMINATION_CODE; or use command line arguments\n" "Constructor: '--buffer-limit' and '--path-termination'."); } while(0)



                                                                                          ;
            }
        }
    }


    Lexer_constructor_core(me,



                                (void*)0x0,

                                CharacterEncodingName, ByteOrderReversionF,
                                BufferMemoryBegin, memory_size, BufferEndOfContentP);
}

inline void
Lexer_construct_file_name(::max::Lexer* me,
                               const char* Filename,
                               const char* CharacterEncodingName ,
                               bool ByteOrderReversionF )
{



    std::FILE* fh = std::fopen(Filename, "rb");

    Lexer_construct_FILE(me, fh, CharacterEncodingName, ByteOrderReversionF);


    me->__file_handle_allocated_by_constructor = fh;
}

inline void
Lexer_construct_FILE(::max::Lexer* me,
                          std::FILE* fh,
                          const char* CharacterEncodingName ,
                          bool ByteOrderReversionF )
{
    if( fh == __null ) do { throw std::runtime_error("Error: received NULL as a file handle."); } while(0);
    setbuf(fh, 0);

    Lexer_constructor_core(me, fh,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}


inline void
Lexer_construct_istream(::max::Lexer* me,
                             std::istream* p_input_stream,
                             const char* CharacterEncodingName ,
                             bool ByteOrderReversionF )
{
    if( p_input_stream == __null ) do { throw std::runtime_error("Error: received NULL as pointer to input stream."); } while(0);
    if( p_input_stream == std::cin ) do { throw std::runtime_error("Error: Quex engine constructor has received a standard input handle!\n" "Error: Standard input has to be treated like buffered input. Please,\n" "Error: consult the documentation or the example 'stdinlexer.cpp' in\n" "Error: directory $QUEX_PATH/demo/010 (> make stdinlexer.exe). Please,\n" "Error: review the other (non-stdin) examples in this directory to\n" "Error: conclude how to read encoded data via stdin.\n"); } while(0);
    Lexer_constructor_core(me, p_input_stream,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}




inline void
Lexer_construct_wistream(::max::Lexer* me,
                              std::wistream* p_input_stream,
                              const char* CharacterEncodingName ,
                              bool ByteOrderReversionF )
{
    if( p_input_stream == __null )
        do { throw std::runtime_error("Error: received NULL as pointer to input stream.\n"); } while(0);
    Lexer_constructor_core(me, p_input_stream,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}


inline void
Lexer_destruct(::max::Lexer* me)
{
    Lexer_destruct_basic(me);
}

template <class InputHandleT> inline void
Lexer_reset(::max::Lexer* me,
                 InputHandleT* input_handle,
                 const char* CharacterEncodingName )
{
    Lexer_reset_basic(me, input_handle, CharacterEncodingName,
                           ((size_t)65536));
    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));
}

inline uint32_t*
Lexer_reset_buffer(::max::Lexer* me,
                        uint32_t* BufferMemoryBegin,
                        size_t BufferMemorySize,
                        uint32_t* BufferEndOfContentP,
                        const char* CharacterEncodingName )
{
    uint32_t* old_memory = 0x0;


    if( BufferEndOfContentP < BufferMemoryBegin
        || BufferEndOfContentP > (BufferMemoryBegin + BufferMemorySize - 1)) {
        do { throw std::runtime_error("\nreset_buffer: Argument 'BufferEndOfContentP' must be inside the provided memory\n" "reset_buffer: buffer (speficied by 'BufferMemoryBegin' and 'BufferMemorySize').\n" "reset_buffer: Note, that the last element of the buffer is to be filled with\n" "reset_buffer: the buffer limit code character.\n"); } while(0)


                                                                           ;
    }




    old_memory = Lexer_BufferMemory_reset(&me->buffer._memory,
                                               BufferMemoryBegin, BufferMemorySize,
                                               BufferEndOfContentP);

    if( BufferMemoryBegin == 0x0 ) return old_memory;

    Lexer_reset_basic(me, (FILE*)0x0, CharacterEncodingName,
                           ((size_t)65536));

    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));

    return old_memory;
}

inline void
Lexer_reset_plain(::max::Lexer* me,
                       const char* CharacterEncodingName )
{ Lexer_reset(me, (FILE*)0x0, CharacterEncodingName); }


inline
Lexer::Lexer(uint32_t* BufferMemoryBegin,
                                 size_t BufferMemorySize,
                                 uint32_t* BufferEndOfFileP,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfFileP,
                              CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(const std::string& Filename,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_file_name(this, Filename.c_str(), CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(std::FILE* fh,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_FILE(this, fh, CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(std::istream* p_input_stream,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_istream(this, p_input_stream, CharacterEncodingName, ByteOrderReversionF); }


inline
Lexer::Lexer(std::wistream* p_input_stream,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_wistream(this, p_input_stream, CharacterEncodingName, ByteOrderReversionF); }
inline
Lexer::~Lexer()
{ Lexer_destruct(this); }

template<class InputHandleT> void
Lexer::reset(InputHandleT* input_handle, const char* CharacterEncodingName )
{ Lexer_reset(this, input_handle, CharacterEncodingName); }

inline uint32_t*
Lexer::reset_buffer(uint32_t* BufferMemoryBegin,
                          size_t BufferMemorySize,
                          uint32_t* BufferEndOfContentP,
                          const char* CharacterEncodingName )
{ return Lexer_reset_buffer(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP, CharacterEncodingName); }


}



namespace max {
    struct Lexer_Mode_tag;

    template <class InputHandleT> inline void
    Lexer_construct_basic(::max::Lexer* me,
                               InputHandleT* input_handle,
                               uint32_t* BufferMemory,
                               const size_t BufferMemorySize,
                               uint32_t* EndOfFileP,
                               const char* CharacterEncodingName,
                               const size_t TranslationBufferMemorySize,
                               bool ByteOrderReversionF)
    {





        if( ((uint32_t)0x0) == ((uint32_t)0x1) ) {
            do { throw std::runtime_error("Path termination code (PTC) and buffer limit code (BLC) must be different.\n"); } while(0);
        }
            me->token = &me->__memory_token;






        Lexer_Counter_construct(&me->counter);


        Lexer_Accumulator_construct(&me->accumulator, (::max::Lexer*)me);



        me->_parent_memento = 0x0;






        me->_mode_stack.end = me->_mode_stack.begin;
        me->_mode_stack.memory_end = me->_mode_stack.begin + (size_t)8;




        std::memset((uint8_t*)&me->buffer, 0xFF, sizeof(me->buffer));


        Lexer_Buffer_construct(&me->buffer, input_handle,
                                    BufferMemory, BufferMemorySize, EndOfFileP,
                                    CharacterEncodingName, TranslationBufferMemorySize,
                                    ByteOrderReversionF);

        if( input_handle == 0x0 ) {



            if( BufferMemory == 0x0 ) {

                Lexer_Buffer_end_of_file_set(&me->buffer, me->buffer._memory._front + 1);
            }


            ((me->buffer._memory._end_of_file_p > me->buffer._memory._front) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p > me->buffer._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 108, __PRETTY_FUNCTION__));
            ((me->buffer._memory._end_of_file_p <= me->buffer._memory._back) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p <= me->buffer._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 109, __PRETTY_FUNCTION__));
        }

        me->__file_handle_allocated_by_constructor = 0x0;
    }

    template <class InputHandleT> inline void
    Lexer_reset_basic(::max::Lexer* me,
                           InputHandleT* input_handle,
                           const char* CharacterEncodingName,
                           const size_t TranslationBufferMemorySize)

    {
        Lexer_Counter_reset(&me->counter);






        Lexer_include_stack_delete((::max::Lexer*)me);





        Lexer_Accumulator_clear(&me->accumulator);






        me->_mode_stack.end = me->_mode_stack.begin;
        me->_mode_stack.memory_end = me->_mode_stack.begin + (size_t)8;

        Lexer_Buffer_reset(&me->buffer, input_handle, CharacterEncodingName, TranslationBufferMemorySize);
    }


    inline void
    Lexer_destruct_basic(::max::Lexer* me)
    {





        Lexer_include_stack_delete((::max::Lexer*)me);





        Lexer_Accumulator_destruct(&me->accumulator);






        Lexer_Buffer_destruct(&me->buffer);

        if( me->__file_handle_allocated_by_constructor != 0x0 ) {
            std::fclose(me->__file_handle_allocated_by_constructor);
        }
    }





    inline void
    Lexer_buffer_reload_backward(Lexer_Buffer* buffer)
    {
        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 184, __PRETTY_FUNCTION__));
        ((buffer->filler != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->filler != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 185, __PRETTY_FUNCTION__));

        if( buffer->on_buffer_content_change != 0x0 ) {


            buffer->on_buffer_content_change(buffer->_memory._front,
                                             Lexer_Buffer_text_end(buffer));
        }

        (void)Lexer_BufferFiller_load_backward(buffer);
    }

    inline size_t
    Lexer___buffer_reload_forward_core(Lexer_Buffer* buffer)
    {
        size_t loaded_character_n = (size_t)-1;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 212, __PRETTY_FUNCTION__));
        ((buffer->filler != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->filler != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 213, __PRETTY_FUNCTION__));
        ((buffer->_memory._end_of_file_p == 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 214, __PRETTY_FUNCTION__));

        if( buffer->_memory._end_of_file_p != 0x0 ) {
            return 0;
        }

        if( buffer->on_buffer_content_change != 0x0 ) {



            buffer->on_buffer_content_change(buffer->_memory._front,
                                             buffer->_memory._back);
        }

        loaded_character_n = Lexer_BufferFiller_load_forward(buffer);
        return loaded_character_n;
    }

    inline void
    Lexer_buffer_reload_forward(Lexer_Buffer* buffer,
                                     Lexer_MemoryPositionMimiker* position_register,
                                     const size_t PositionRegisterN)
    {
        Lexer_MemoryPositionMimiker* iterator = 0x0;
        Lexer_MemoryPositionMimiker* End = position_register + (ptrdiff_t)PositionRegisterN;
        size_t loaded_character_n = (size_t)-1;

        loaded_character_n = Lexer___buffer_reload_forward_core(buffer);

        for(iterator = position_register; iterator != End; ++iterator) {


            *iterator -= (ptrdiff_t)loaded_character_n;
        }
    }


}


namespace max {

    inline uint32_t
    Lexer_Mode_uncallable_analyzer_function(::max::Lexer* me)
    {
        ((0) ? static_cast<void> (0) : __assert_fail ("0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Mode.i", 15, __PRETTY_FUNCTION__));
        (void)me;



        return (uint32_t)0;

    }


    inline void
    Lexer_Mode_on_indentation_null_function(::max::Lexer* me,
                                                 uint32_t* LexemeBegin,
                                                 uint32_t* LexemeEnd)
    { (void)me; (void)LexemeBegin; (void)LexemeEnd; }


    inline void
    Lexer_Mode_on_entry_exit_null_function(::max::Lexer* me,
                                                const Lexer_Mode* TheMode)
    { (void)me; (void)TheMode; }

}



namespace max {

    inline ptrdiff_t Lexer___BufferFiller_forward_compute_fallback_region(Lexer_Buffer* buffer,
                                                                                     const ptrdiff_t Distance_LexemeStart_to_InputP);
    inline ptrdiff_t Lexer___BufferFiller_backward_compute_backward_distance(Lexer_Buffer* buffer);

    inline void Lexer___BufferFiller_forward_copy_fallback_region(Lexer_Buffer*,
                                                                                  const ptrdiff_t FallBackN);
    inline void Lexer___BufferFiller_forward_adapt_pointers(Lexer_Buffer*,
                                                                            const ptrdiff_t DesiredLoadN,
                                                                            const size_t LoadedN,
                                                                            const ptrdiff_t FallBackN,
                                                                            const ptrdiff_t Distance_LexemeStart_to_InputP);
    inline void Lexer___BufferFiller_backward_copy_backup_region(Lexer_Buffer*,
                                                                                 const ptrdiff_t BackwardDistance);
    inline void Lexer___BufferFiller_backward_adapt_pointers(Lexer_Buffer*,
                                                                             const ptrdiff_t BackwardDistance);
    inline void Lexer___BufferFiller_on_overflow(Lexer_Buffer*, bool ForwardF);

    inline size_t Lexer___BufferFiller_read_characters(Lexer_Buffer*, uint32_t*,
                                                                     const ptrdiff_t);



    inline Lexer_Converter* Lexer___Converter_EMPTY_new() { return 0x0; }

    template <class InputHandleT> inline Lexer_BufferFiller*
    Lexer_BufferFiller_new(InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize)



    {
        (void)TranslationBufferMemorySize;

        if( CharacterEncodingName == 0x0 ) {

            std::printf("Warning: No character encoding name specified, while this\n"
                              "Warning: analyzer was generated for use with a converter.\n"
                              "Warning: Please, consult the documentation about the constructor\n"
                              "Warning: or the reset function. If it is desired to do a plain\n"
                              "Warning: buffer filler with this setup, you might want to disable\n"
                              "Warning: this warning with the macro:\n"
                              "Warning:     QUEX_OPTION_WARNING_ON_PLAIN_FILLER_DISABLED\n");

            return (Lexer_BufferFiller*)0x0;
        }

        if( Lexer_Converter_IConv_new == Lexer___Converter_EMPTY_new ) {
            do { throw std::runtime_error("Use of buffer filler type 'CharacterEncodingName' while " "'QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW' has not\n" "been defined (use --iconv, --icu, --converter-new to specify converter).\n"); } while(0)

                                                                                                         ;
        }





        return (Lexer_BufferFiller*)Lexer_BufferFiller_Converter_new(input_handle,
                                                                               Lexer_Converter_IConv_new(),
                                                                               CharacterEncodingName,
                                                                                                             0x0,
                                                                               TranslationBufferMemorySize);
    }
    inline void
    Lexer_BufferFiller_delete_self(Lexer_BufferFiller* me)
    {
        if( me->delete_self == 0x0 ) do { throw std::runtime_error("BufferFiller object did not specify 'delete_self()'\n"); } while(0);
        else me->delete_self(me);
    }

    inline void
    Lexer_BufferFiller_setup_functions(Lexer_BufferFiller* me,
                                            ptrdiff_t (*tell_character_index)(Lexer_BufferFiller*),
                                            void (*seek_character_index)(Lexer_BufferFiller*,
                                                                                 const ptrdiff_t),
                                            size_t (*read_characters)(Lexer_BufferFiller*,
                                                                            uint32_t*, const size_t),
                                            void (*delete_self)(Lexer_BufferFiller*))
    {
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 121, __PRETTY_FUNCTION__));
        ((tell_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("tell_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 122, __PRETTY_FUNCTION__));
        ((seek_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("seek_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 123, __PRETTY_FUNCTION__));
        ((read_characters != 0x0) ? static_cast<void> (0) : __assert_fail ("read_characters != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 124, __PRETTY_FUNCTION__));
        ((delete_self != 0x0) ? static_cast<void> (0) : __assert_fail ("delete_self != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 125, __PRETTY_FUNCTION__));


        me->tell_character_index = tell_character_index;
        me->seek_character_index = seek_character_index;
        me->read_characters = read_characters;
        me->_on_overflow = 0x0;
        me->delete_self = delete_self;
    }

    inline void
    Lexer_BufferFiller_initial_load(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);
        Lexer_BufferFiller* me = buffer->filler;
        size_t LoadedN = 0;


        ((buffer->_input_p == ContentFront) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == ContentFront", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 144, __PRETTY_FUNCTION__));
        ((buffer->_lexeme_start_p == ContentFront) ? static_cast<void> (0) : __assert_fail ("buffer->_lexeme_start_p == ContentFront", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 145, __PRETTY_FUNCTION__));







        me->seek_character_index(me, 0);

        LoadedN = Lexer___BufferFiller_read_characters(buffer, ContentFront, ContentSize);

        buffer->_content_character_index_begin = 0;
        buffer->_content_character_index_end = me->tell_character_index(buffer->filler);

        if( me->tell_character_index(me) != (ptrdiff_t)LoadedN )
            do { throw std::runtime_error("\nThe provided input stream behaves strangely. Number of read\n" "characters is not proportional to the stream position increase.\n" "The buffer filler type which you are using might be able to\n" "deal with those cases. Try compile option:\n" "\n" "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" "\n" "However, those mechanisms imply a trade-off in terms of speed.\n" "Please, consider using a 'binary' for your input stream, or use\n" "a different implementation of the standard I/O library (e.g.\n" "not Microsoft(tm)).\n"); } while(0);


        if( LoadedN != (size_t)ContentSize ) Lexer_Buffer_end_of_file_set(buffer, ContentFront + LoadedN);
        else Lexer_Buffer_end_of_file_unset(buffer);

        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);
    }

    inline size_t
    Lexer_BufferFiller_load_forward(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);
        ptrdiff_t Distance_LexemeStart_to_InputP = (ptrdiff_t)-1;
        ptrdiff_t FallBackN = (ptrdiff_t)-1;
        ptrdiff_t DesiredLoadN = (ptrdiff_t)-1;
        uint32_t* new_content_begin = 0x0;
        size_t LoadedN = (size_t)-1;
        Lexer_BufferFiller* me = buffer->filler;
        if( me == 0x0 ) return 0;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 211, __PRETTY_FUNCTION__));
        ((me->tell_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 212, __PRETTY_FUNCTION__));
        ((me->seek_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("me->seek_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 213, __PRETTY_FUNCTION__));
        ((me->read_characters != 0x0) ? static_cast<void> (0) : __assert_fail ("me->read_characters != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 214, __PRETTY_FUNCTION__));



        Distance_LexemeStart_to_InputP = buffer->_input_p - buffer->_lexeme_start_p;
        if( Distance_LexemeStart_to_InputP >= ContentSize ) {
            Lexer___BufferFiller_on_overflow(buffer, true);
            return 0;
        }
        ;


        if ( buffer->_input_p == buffer->_memory._front ) { return 0; }
        else if( buffer->_input_p == buffer->_memory._end_of_file_p ) { return 0; }
        else if( buffer->_input_p != buffer->_memory._back ) {
            do { throw std::runtime_error("Call to 'load_forward() but '_input_p' not on buffer border.\n" "(Check character encoding)"); } while(0)
                                                         ;
        }
        else if( buffer->_memory._end_of_file_p != 0x0 ) {

            return 0;
        }





        FallBackN = Lexer___BufferFiller_forward_compute_fallback_region(buffer,
                                                                                 Distance_LexemeStart_to_InputP);
        ((FallBackN < ContentSize) ? static_cast<void> (0) : __assert_fail ("FallBackN < ContentSize", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 243, __PRETTY_FUNCTION__));
        DesiredLoadN = ContentSize - FallBackN;

        Lexer___BufferFiller_forward_copy_fallback_region(buffer, FallBackN);





        me->seek_character_index(me, buffer->_content_character_index_end);
        buffer->_content_character_index_begin = buffer->_content_character_index_end - FallBackN;

        new_content_begin = ContentFront + FallBackN;
        LoadedN = Lexer___BufferFiller_read_characters(buffer,
                                                                       new_content_begin,
                                                                       DesiredLoadN);



        Lexer___BufferFiller_forward_adapt_pointers(buffer,
                                                         DesiredLoadN, LoadedN, FallBackN,
                                                         Distance_LexemeStart_to_InputP);

        buffer->_content_character_index_end = buffer->_content_character_index_begin
                                                 + (Lexer_Buffer_text_end(buffer) - ContentFront);




        if( (me->tell_character_index(me) - buffer->_content_character_index_begin - FallBackN) != (ptrdiff_t)LoadedN )
            do { throw std::runtime_error("\nThe provided input stream behaves strangely. Number of read\n" "characters is not proportional to the stream position increase.\n" "The buffer filler type which you are using might be able to\n" "deal with those cases. Try compile option:\n" "\n" "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" "\n" "However, those mechanisms imply a trade-off in terms of speed.\n" "Please, consider using a 'binary' for your input stream, or use\n" "a different implementation of the standard I/O library (e.g.\n" "not Microsoft(tm)).\n"); } while(0);

        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);


        return (size_t)DesiredLoadN;
    }

    inline ptrdiff_t
    Lexer___BufferFiller_forward_compute_fallback_region(Lexer_Buffer* buffer,
                                                              const ptrdiff_t Distance_LexemeStart_to_InputP)
    {
        ptrdiff_t FallBackN = (ptrdiff_t)-1;

        (void)buffer;
        ((buffer->_memory._end_of_file_p == 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 307, __PRETTY_FUNCTION__));
        ((buffer->_input_p == buffer->_memory._back) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == buffer->_memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 308, __PRETTY_FUNCTION__));
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        ((Distance_LexemeStart_to_InputP == buffer->_input_p - buffer->_lexeme_start_p) ? static_cast<void> (0) : __assert_fail ("Distance_LexemeStart_to_InputP == buffer->_input_p - buffer->_lexeme_start_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 310, __PRETTY_FUNCTION__));
        ((Distance_LexemeStart_to_InputP < (ptrdiff_t)Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("Distance_LexemeStart_to_InputP < (ptrdiff_t)Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 311, __PRETTY_FUNCTION__));


        FallBackN = (ptrdiff_t)(256) > Distance_LexemeStart_to_InputP
                    ? (ptrdiff_t)(256)
                    : Distance_LexemeStart_to_InputP;
        return FallBackN;
    }

    inline void
    Lexer___BufferFiller_forward_copy_fallback_region(Lexer_Buffer* buffer, const ptrdiff_t FallBackN)
    {



        uint32_t* source = Lexer_Buffer_content_back(buffer) - FallBackN + 1;
        uint32_t* drain = Lexer_Buffer_content_front(buffer);


        if( drain + FallBackN >= source ) {
            std::memmove((uint8_t*)drain, (uint8_t*)source, (size_t)FallBackN * sizeof(uint32_t));
        } else {
            std::memcpy((uint8_t*)drain, (uint8_t*)source, (size_t)FallBackN * sizeof(uint32_t));
        }



        std::memset((uint8_t*)(drain + FallBackN), (uint8_t)(0xFF),
                          (Lexer_Buffer_content_size(buffer) - (size_t)FallBackN)*sizeof(uint32_t));


        (((size_t)FallBackN < Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("(size_t)FallBackN < Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 342, __PRETTY_FUNCTION__));
    }

    inline void
    Lexer___BufferFiller_forward_adapt_pointers(Lexer_Buffer* buffer,
                                                     const ptrdiff_t DesiredLoadN,
                                                     const size_t LoadedN,
                                                     const ptrdiff_t FallBackN,
                                                     const ptrdiff_t Distance_LexemeStart_to_InputP)
    {
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);

        ((buffer->_memory._end_of_file_p == 0x0 || (LoadedN + (size_t)FallBackN) == Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0 || (LoadedN + (size_t)FallBackN) == Lexer_Buffer_content_size(buffer)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i"
        ,
 355
        , __PRETTY_FUNCTION__))
                                                                                                   ;
        ((DesiredLoadN != 0) ? static_cast<void> (0) : __assert_fail ("DesiredLoadN != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 356, __PRETTY_FUNCTION__));


        if( LoadedN != (size_t)DesiredLoadN )
            Lexer_Buffer_end_of_file_set(buffer, ContentFront + FallBackN + (ptrdiff_t)LoadedN);
        else
            Lexer_Buffer_end_of_file_unset(buffer);




        buffer->_input_p = ContentFront + FallBackN - 1;


        buffer->_lexeme_start_p = (buffer->_input_p + 1) - Distance_LexemeStart_to_InputP;


        ((buffer->_memory._end_of_file_p == 0x0 || ((ptrdiff_t)LoadedN + FallBackN) == buffer->_memory._end_of_file_p - buffer->_memory._front - 1) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0 || ((ptrdiff_t)LoadedN + FallBackN) == buffer->_memory._end_of_file_p - buffer->_memory._front - 1",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i"
        ,
 374
        , __PRETTY_FUNCTION__))
                                                                                                                         ;

    }


    inline size_t
    Lexer_BufferFiller_load_backward(Lexer_Buffer* buffer)
    {
        Lexer_BufferFiller* me = buffer->filler;
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint32_t* ContentBack = Lexer_Buffer_content_back(buffer);
        ptrdiff_t BackwardDistance = (ptrdiff_t)-1;
        ptrdiff_t NewContentCharacterIndexBegin = (ptrdiff_t)-1;

        size_t LoadedN = (size_t)-1;





        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);

        if( me == 0x0 ) return 0;
        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 433, __PRETTY_FUNCTION__));
        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);


        if ( buffer->_input_p == buffer->_memory._back ) { return 0; }
        else if( buffer->_input_p == buffer->_memory._end_of_file_p ) { return 0; }
        else if( buffer->_input_p != buffer->_memory._front ) {
            do { throw std::runtime_error("Call to 'load_backward() but '_input_p' not on buffer border.\n" "(Check character encoding)"); } while(0)
                                                         ;
        }
        else if( buffer->_content_character_index_begin == 0 ) { return 0; }





        if( buffer->_lexeme_start_p == ContentBack ) {
            Lexer___BufferFiller_on_overflow(buffer, false);
            return 0;
        }



        BackwardDistance = Lexer___BufferFiller_backward_compute_backward_distance(buffer);






        NewContentCharacterIndexBegin = buffer->_content_character_index_begin - BackwardDistance;
        ((BackwardDistance != 0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 465, __PRETTY_FUNCTION__));
        me->seek_character_index(me, NewContentCharacterIndexBegin);



        buffer->_content_character_index_begin = NewContentCharacterIndexBegin;
        Lexer___BufferFiller_backward_copy_backup_region(buffer, BackwardDistance);






        LoadedN =



        Lexer___BufferFiller_read_characters(buffer, ContentFront, BackwardDistance);
        ((LoadedN == (size_t)BackwardDistance) ? static_cast<void> (0) : __assert_fail ("LoadedN == (size_t)BackwardDistance", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 483, __PRETTY_FUNCTION__));



        Lexer___BufferFiller_backward_adapt_pointers(buffer, BackwardDistance);

        buffer->_content_character_index_end = buffer->_content_character_index_begin
                                               + (Lexer_Buffer_text_end(buffer) - ContentFront);



        (((size_t)(me->tell_character_index(me) - buffer->_content_character_index_begin) == LoadedN) ? static_cast<void> (0) : __assert_fail ("(size_t)(me->tell_character_index(me) - buffer->_content_character_index_begin) == LoadedN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 494, __PRETTY_FUNCTION__));

        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);

        return (size_t)BackwardDistance;
    }


    inline ptrdiff_t
    Lexer___BufferFiller_backward_compute_backward_distance(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        ptrdiff_t IntendedBackwardDistance = (ptrdiff_t)-1;
        ptrdiff_t Distance_InputP_to_LexemeStart = (ptrdiff_t)-1;
        ptrdiff_t LimitBackwardDist_1 = -1;
        ptrdiff_t LimitBackwardDist_2 = -1;
        ptrdiff_t Limit_1_and_2 = -1;
        ptrdiff_t BackwardDistance = -1;

        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);


        ((buffer->_input_p == buffer->_memory._front) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == buffer->_memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 518, __PRETTY_FUNCTION__));


        ((buffer->_content_character_index_begin != 0) ? static_cast<void> (0) : __assert_fail ("buffer->_content_character_index_begin != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 521, __PRETTY_FUNCTION__));




        ((buffer->_lexeme_start_p > buffer->_input_p) ? static_cast<void> (0) : __assert_fail ("buffer->_lexeme_start_p > buffer->_input_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 526, __PRETTY_FUNCTION__));
        (((size_t)(buffer->_lexeme_start_p - buffer->_input_p) < Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->_lexeme_start_p - buffer->_input_p) < Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 527, __PRETTY_FUNCTION__));

        IntendedBackwardDistance = ContentSize > (ptrdiff_t)3 ? (ptrdiff_t)(ContentSize / 3)
                                   : (ptrdiff_t)1;
        Distance_InputP_to_LexemeStart = buffer->_lexeme_start_p - buffer->_input_p;
        LimitBackwardDist_1 = ContentSize - Distance_InputP_to_LexemeStart;




        LimitBackwardDist_2 = buffer->_content_character_index_begin;




        Limit_1_and_2 = LimitBackwardDist_1 < LimitBackwardDist_2 ? LimitBackwardDist_1
                        : LimitBackwardDist_2;

        BackwardDistance = IntendedBackwardDistance < Limit_1_and_2 ? IntendedBackwardDistance
                           : Limit_1_and_2;

        ((BackwardDistance > (ptrdiff_t)0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance > (ptrdiff_t)0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 564, __PRETTY_FUNCTION__));
        return (ptrdiff_t)BackwardDistance;
    }

    inline void
    Lexer___BufferFiller_backward_copy_backup_region(Lexer_Buffer* buffer,
                                                          const ptrdiff_t BackwardDistance)
    {
        const size_t ContentSize = Lexer_Buffer_content_size(buffer);
        uint32_t* ContentFront = Lexer_Buffer_content_front(buffer);

        ((BackwardDistance >= (ptrdiff_t)0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance >= (ptrdiff_t)0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 575, __PRETTY_FUNCTION__));
        (((size_t)BackwardDistance < ContentSize) ? static_cast<void> (0) : __assert_fail ("(size_t)BackwardDistance < ContentSize", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 576, __PRETTY_FUNCTION__));



        std::memmove(ContentFront + BackwardDistance, ContentFront,
                           (size_t)(ContentSize - (size_t)BackwardDistance)*sizeof(uint32_t));



        std::memset((uint8_t*)ContentFront, (uint8_t)(0xFF),
                          (size_t)BackwardDistance * sizeof(uint32_t));

    }

    inline void
    Lexer___BufferFiller_backward_adapt_pointers(Lexer_Buffer* buffer,
                                                      const ptrdiff_t BackwardDistance)
    {

        if( buffer->_memory._end_of_file_p ) {
            uint32_t* NewEndOfFileP = buffer->_memory._end_of_file_p + BackwardDistance;
            if( NewEndOfFileP <= buffer->_memory._back )
                Lexer_Buffer_end_of_file_set(buffer, NewEndOfFileP);
            else
                Lexer_Buffer_end_of_file_unset(buffer);
        }

        buffer->_input_p += BackwardDistance + 1;
        buffer->_lexeme_start_p += BackwardDistance;
    }

    inline void
    Lexer___BufferFiller_on_overflow(Lexer_Buffer* buffer, bool ForwardF)
    {
        Lexer_BufferFiller* me = buffer->filler;
        if( me->_on_overflow == 0x0
            || me->_on_overflow(buffer, ForwardF) == false ) {
            do { throw std::runtime_error("Distance between lexeme start and current pointer exceeds buffer size.\n" "(tried to load buffer forward). Please, compile with option\n\n" "    QUEX_OPTION_INFORMATIVE_BUFFER_OVERFLOW_MESSAGE\n\n" "in order to get a more informative output. Most likely, one of your patterns\n" "eats longer as you inteded it. Alternatively you might want to set the buffer\n" "size to a greate value or use skippers (<skip: [ \\n\\t]> for example).\n"); } while(0)




                                                                                                        ;

        }
    }

    inline void
    Lexer_BufferFiller_step_forward_n_characters(Lexer_BufferFiller* me,
                                                      const ptrdiff_t ForwardN)
    {
        const ptrdiff_t TargetIndex = me->tell_character_index(me) + ForwardN;





        size_t remaining_character_n = (size_t)ForwardN;
        const size_t ChunkSize = (512);
        uint32_t chunk[(512)];

        (((512) >= 1) ? static_cast<void> (0) : __assert_fail ("(512) >= 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 679, __PRETTY_FUNCTION__));






        for(; remaining_character_n > ChunkSize; remaining_character_n -= ChunkSize )
            if( me->read_characters(me, (uint32_t*)chunk, ChunkSize) < ChunkSize ) {
                ((me->tell_character_index(me) <= TargetIndex) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index(me) <= TargetIndex", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 688, __PRETTY_FUNCTION__));
                return;
            }
        if( remaining_character_n )
            me->read_characters(me, (uint32_t*)chunk, remaining_character_n);

        ((me->tell_character_index(me) <= TargetIndex) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index(me) <= TargetIndex", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 694, __PRETTY_FUNCTION__));
    }

    inline size_t
    Lexer___BufferFiller_read_characters(Lexer_Buffer* buffer,
                                              uint32_t* memory,
                                              const ptrdiff_t CharacterNToRead)
    {
        const size_t LoadedN = buffer->filler->read_characters(buffer->filler, memory, (size_t)CharacterNToRead);

        if( buffer->_byte_order_reversion_active_f ) {
            Lexer_Buffer_reverse_byte_order(memory, memory + LoadedN);
        }
        return LoadedN;
    }

}




namespace max {
    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_construct(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                                InputHandleT* input_handle,
                                                Lexer_Converter* converter,
                                                const char* FromCoding,
                                                const char* ToCoding,
                                                size_t RawBufferSize);
    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_init(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                           InputHandleT* input_handle,
                                           Lexer_Converter* converter,
                                           const char* FromCoding,
                                           const char* ToCoding,
                                           size_t RawBufferSize);
    template <class InputHandleT> inline ptrdiff_t
    Lexer_BufferFiller_Converter_tell_character_index(Lexer_BufferFiller* alter_ego);

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_seek_character_index(Lexer_BufferFiller* alter_ego,
                                                           const ptrdiff_t CharacterIndex);
    template <class InputHandleT> inline size_t
    Lexer_BufferFiller_Converter_read_characters(Lexer_BufferFiller* alter_ego,
                                                      uint32_t* start_of_buffer,
                                                      const size_t N);
    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_delete_self(Lexer_BufferFiller* alter_ego);

    template <class InputHandleT> inline size_t
    Lexer___BufferFiller_Converter_fill_raw_buffer(Lexer_BufferFiller_Converter<InputHandleT>* me);

    template <class InputHandleT> inline void
    Lexer_RawBuffer_init(Lexer_RawBuffer<InputHandleT>* me,
                              uint8_t* Begin, size_t SizeInBytes,
                              typename InputPolicy<InputHandleT*>::stream_position StartPosition);

    template <class InputHandleT> inline Lexer_BufferFiller_Converter<InputHandleT>*
    Lexer_BufferFiller_Converter_new(InputHandleT* input_handle,
                                          Lexer_Converter* converter,
                                          const char* FromCoding,
                                          const char* ToCoding,
                                          size_t RawBufferSize)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)0x0;
        ((RawBufferSize >= 6) ? static_cast<void> (0) : __assert_fail ("RawBufferSize >= 6", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 63, __PRETTY_FUNCTION__));

        me = (Lexer_BufferFiller_Converter<InputHandleT>*)
 Lexer_MemoryManager_BufferFiller_allocate(sizeof(Lexer_BufferFiller_Converter<InputHandleT>));
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 67, __PRETTY_FUNCTION__));

        Lexer_BufferFiller_Converter_construct(me, input_handle, converter, FromCoding, ToCoding, RawBufferSize);

        return me;

    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_construct(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                                InputHandleT* input_handle,
                                                Lexer_Converter* converter,
                                                const char* FromCoding,
                                                const char* ToCoding,
                                                size_t RawBufferSize)
    {
        Lexer_BufferFiller_setup_functions(&me->base,
                                                Lexer_BufferFiller_Converter_tell_character_index<InputHandleT>,
                                                Lexer_BufferFiller_Converter_seek_character_index<InputHandleT>,
                                                Lexer_BufferFiller_Converter_read_characters<InputHandleT>,
                                                Lexer_BufferFiller_Converter_delete_self<InputHandleT>);

        Lexer_BufferFiller_Converter_init(me, input_handle, converter, FromCoding, ToCoding, RawBufferSize);
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_init(Lexer_BufferFiller_Converter<InputHandleT>* me,
                                           InputHandleT* input_handle,
                                           Lexer_Converter* converter,
                                           const char* FromCoding,
                                           const char* ToCoding,
                                           size_t RawBufferSize)
    {
        uint8_t* raw_buffer_p = 0x0;

        me->ih = input_handle;


        me->converter = converter;
        me->converter->open(me->converter, FromCoding, ToCoding);



        if( me->ih != 0x0 ) {
            me->start_position = InputPolicy<InputHandleT*>::tell((me->ih));
        } else {
            me->start_position = 0;
        }



        raw_buffer_p = Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(RawBufferSize);
        Lexer_RawBuffer_init(&me->raw_buffer, raw_buffer_p, RawBufferSize,
                                  me->start_position);


        me->hint_begin_character_index = (ptrdiff_t)-1;


        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 126, __PRETTY_FUNCTION__));;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_reset(Lexer_BufferFiller_Converter<InputHandleT>* me, InputHandleT* input_handle)
    {
        (void)me;
        (void)input_handle;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_delete_self(Lexer_BufferFiller* alter_ego)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 140, __PRETTY_FUNCTION__));;

        me->converter->delete_self(me->converter);

        Lexer_MemoryManager_BufferFiller_RawBuffer_free(me->raw_buffer.begin);

        Lexer_MemoryManager_BufferFiller_free((void*)me);
    }


    template <class InputHandleT> inline size_t
    Lexer_BufferFiller_Converter_read_characters(Lexer_BufferFiller* alter_ego,
                                                      uint32_t* user_memory_p,
                                                      const size_t N)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        uint32_t* user_buffer_iterator = user_memory_p;
        const uint32_t* UserBufferEnd = user_memory_p + N;
        const ptrdiff_t StartCharacterIndex = me->raw_buffer.iterators_character_index;
        ptrdiff_t ConvertedCharN = 0;

        ((me->converter != 0x0) ? static_cast<void> (0) : __assert_fail ("me->converter != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 186, __PRETTY_FUNCTION__));
        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 187, __PRETTY_FUNCTION__));
        ((user_memory_p != 0x0) ? static_cast<void> (0) : __assert_fail ("user_memory_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 188, __PRETTY_FUNCTION__));
        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 189, __PRETTY_FUNCTION__));;

        std::memset((uint8_t*)user_memory_p, 0xFF, N * sizeof(uint32_t));


        while( ! me->converter->convert(me->converter,
                                        &me->raw_buffer.iterator, me->raw_buffer.end,
                                        &user_buffer_iterator, UserBufferEnd) ) {

            ((user_buffer_iterator < UserBufferEnd) ? static_cast<void> (0) : __assert_fail ("user_buffer_iterator < UserBufferEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 198, __PRETTY_FUNCTION__));
            ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 199, __PRETTY_FUNCTION__));;


            me->raw_buffer.iterators_character_index = StartCharacterIndex
                                                       + (user_buffer_iterator - user_memory_p);

            if( Lexer___BufferFiller_Converter_fill_raw_buffer(me) == 0 ) {

                if( me->raw_buffer.end != me->raw_buffer.begin )

                    do { throw std::runtime_error("Error. At end of file, byte sequence not interpreted as character."); } while(0);
                break;
            }
        }

        ConvertedCharN = user_buffer_iterator - user_memory_p;
        me->raw_buffer.iterators_character_index = StartCharacterIndex + ConvertedCharN;

        if( ConvertedCharN != (ptrdiff_t)N ) {


            ((UserBufferEnd >= user_buffer_iterator) ? static_cast<void> (0) : __assert_fail ("UserBufferEnd >= user_buffer_iterator", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 220, __PRETTY_FUNCTION__));

            std::memset((uint8_t*)(user_buffer_iterator), (uint8_t)0xFF,
                              (size_t)(UserBufferEnd - user_buffer_iterator) * sizeof(uint32_t));

        }
        return (size_t)ConvertedCharN;
    }

    template <class InputHandleT> inline ptrdiff_t
    Lexer_BufferFiller_Converter_tell_character_index(Lexer_BufferFiller* alter_ego)
    {
        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 233, __PRETTY_FUNCTION__));
        ((me->converter != 0x0) ? static_cast<void> (0) : __assert_fail ("me->converter != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 234, __PRETTY_FUNCTION__));



        return me->raw_buffer.iterators_character_index;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_seek_character_index(Lexer_BufferFiller* alter_ego,
                                                           const ptrdiff_t Index)
    {







        Lexer_BufferFiller_Converter<InputHandleT>* me = (Lexer_BufferFiller_Converter<InputHandleT>*)alter_ego;
        Lexer_RawBuffer<InputHandleT>* buffer = &me->raw_buffer;

        const ptrdiff_t Hint_Index = me->hint_begin_character_index;
        uint8_t* Hint_Pointer = buffer->begin;
        ptrdiff_t ContentSize = 0;
        ptrdiff_t EndIndex = 0;
        uint8_t* new_iterator = 0;

        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 261, __PRETTY_FUNCTION__));
        ((me->converter != 0x0) ? static_cast<void> (0) : __assert_fail ("me->converter != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 262, __PRETTY_FUNCTION__));







        if( Index == buffer->iterators_character_index ) {
            return;
        }



        if( me->converter->on_conversion_discontinuity != 0x0 )
            me->converter->on_conversion_discontinuity(me->converter);
        if( me->converter->dynamic_character_size_f == false ) {

            ((buffer->end >= buffer->begin) ? static_cast<void> (0) : __assert_fail ("buffer->end >= buffer->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 290, __PRETTY_FUNCTION__));
            ContentSize = buffer->end - buffer->begin;
            EndIndex = Hint_Index + (ContentSize / (ptrdiff_t)sizeof(uint32_t));

            if( Index >= Hint_Index && Index < EndIndex && Hint_Index != (ptrdiff_t)-1 ) {
                new_iterator = buffer->begin + (Index - Hint_Index) * (ptrdiff_t)sizeof(uint32_t);
                buffer->iterator = new_iterator;
                buffer->iterators_character_index = Index;
            }
            else {
                typename InputPolicy<InputHandleT*>::stream_position avoid_tmp_arg =
                    (typename InputPolicy<InputHandleT*>::stream_position)((size_t)Index * sizeof(uint32_t))
                    + me->start_position;

                if( me->ih != 0x0 ) {
                    InputPolicy<InputHandleT*>::seek((me->ih), (avoid_tmp_arg));
                }
                buffer->end_stream_position = avoid_tmp_arg;

                buffer->iterator = buffer->end;
                buffer->iterators_character_index = Index;
            }
        }
        else {




            if( Index == Hint_Index && Hint_Index != (ptrdiff_t)-1 ) {



                buffer->iterators_character_index = Index;
                buffer->iterator = Hint_Pointer;
            }
            else if( Index > Hint_Index && Hint_Index != (ptrdiff_t)-1 ) {



                buffer->iterators_character_index = Hint_Index;
                buffer->iterator = Hint_Pointer;
                Lexer_BufferFiller_step_forward_n_characters((Lexer_BufferFiller*)me,
                                                                  Index - Hint_Index);

            }
            else {





                if( me->ih != 0x0 ) {
                    InputPolicy<InputHandleT*>::seek((me->ih), (me->start_position));
                }
                buffer->end_stream_position = me->start_position;

                buffer->end = buffer->begin;

                buffer->iterator = buffer->end;
                buffer->iterators_character_index = 0;
                Lexer_BufferFiller_step_forward_n_characters((Lexer_BufferFiller*)me, Index);

                ((buffer->iterators_character_index == Index) ? static_cast<void> (0) : __assert_fail ("buffer->iterators_character_index == Index", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 352, __PRETTY_FUNCTION__));
            }
        }
        ((&me->raw_buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("&me->raw_buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->iterator <= (&me->raw_buffer)->end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->iterator <= (&me->raw_buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end >= (&me->raw_buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end >= (&me->raw_buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__)); (((&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(&me->raw_buffer)->end <= (&me->raw_buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 355, __PRETTY_FUNCTION__));;
    }

    template <class InputHandleT> inline size_t
    Lexer___BufferFiller_Converter_fill_raw_buffer(Lexer_BufferFiller_Converter<InputHandleT>* me)
    {



       Lexer_RawBuffer<InputHandleT>* buffer = &me->raw_buffer;
       const size_t RemainingBytesN = (size_t)(buffer->end - buffer->iterator);
       uint8_t* FillStartPosition = 0;
       size_t FillSize = 0;
       size_t LoadedByteN = 0;

       ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 370, __PRETTY_FUNCTION__));;
       (((size_t)(buffer->end - buffer->begin) >= RemainingBytesN) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->end - buffer->begin) >= RemainingBytesN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 371, __PRETTY_FUNCTION__));

       if( me->ih != 0x0 ) {
           ((buffer->end_stream_position == InputPolicy<InputHandleT*>::tell((me->ih))) ? static_cast<void> (0) : __assert_fail ("buffer->end_stream_position == InputPolicy<InputHandleT*>::tell((me->ih))", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 374, __PRETTY_FUNCTION__));
       }
       if( me->converter->on_conversion_discontinuity == 0x0 )
           me->hint_begin_character_index = buffer->iterators_character_index;




       if( RemainingBytesN != 0 ) {



           std::memmove((uint8_t*)(buffer->begin), (uint8_t*)(buffer->iterator), RemainingBytesN);
       }

       FillStartPosition = buffer->begin + RemainingBytesN;
       FillSize = (size_t)(buffer->memory_end - buffer->begin) - RemainingBytesN;

       if( me->ih != 0x0 ) {
           LoadedByteN = InputPolicy<InputHandleT*>::load_bytes((me->ih), (uint8_t*)(FillStartPosition), (FillSize))
                                                                                  ;
       }



       if( me->ih != 0x0 ) {
           buffer->end_stream_position = InputPolicy<InputHandleT*>::tell((me->ih));
       }



       buffer->iterator = buffer->begin;
       buffer->end = buffer->begin + LoadedByteN + RemainingBytesN;


       ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 426, __PRETTY_FUNCTION__));;

       return LoadedByteN;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Converter_move_away_passed_content(Lexer_BufferFiller_Converter<InputHandleT>* me)

    {
        Lexer_RawBuffer<InputHandleT>* buffer = &me->raw_buffer;
        const size_t RemainingBytesN = (size_t)(buffer->end - buffer->iterator);

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 438, __PRETTY_FUNCTION__));;
        (((size_t)(buffer->end - buffer->begin) >= RemainingBytesN) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->end - buffer->begin) >= RemainingBytesN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 439, __PRETTY_FUNCTION__));




        if( RemainingBytesN != 0 ) {



            std::memmove((uint8_t*)(buffer->begin), (uint8_t*)(buffer->iterator), RemainingBytesN);
        }


        buffer->iterator = buffer->begin;
        buffer->end = buffer->begin + RemainingBytesN;

        (((size_t)(buffer->memory_end - buffer->begin) >= RemainingBytesN) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->memory_end - buffer->begin) >= RemainingBytesN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 455, __PRETTY_FUNCTION__));
        std::memset((uint8_t*)(buffer->begin) + RemainingBytesN, 0xFF,
                          (size_t)(buffer->memory_end - buffer->begin) - RemainingBytesN);


        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->iterator >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->iterator <= (buffer)->end) ? static_cast<void> (0) : __assert_fail ("(buffer)->iterator <= (buffer)->end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->end >= (buffer)->begin) ? static_cast<void> (0) : __assert_fail ("(buffer)->end >= (buffer)->begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__)); (((buffer)->end <= (buffer)->memory_end) ? static_cast<void> (0) : __assert_fail ("(buffer)->end <= (buffer)->memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/BufferFiller_Converter.i", 460, __PRETTY_FUNCTION__));;
    }

    template <class InputHandleT> inline void
    Lexer_RawBuffer_init(Lexer_RawBuffer<InputHandleT>* me,
                              uint8_t* Begin, size_t SizeInBytes,
                              typename InputPolicy<InputHandleT*>::stream_position StartPosition)
    {
        me->begin = Begin;

        me->end = Begin;
        me->end_stream_position = StartPosition;

        me->memory_end = Begin + (ptrdiff_t)SizeInBytes;

        me->iterator = me->end;
        me->iterators_character_index = 0;



        std::memset((uint8_t*)Begin, (uint8_t)0xFF, SizeInBytes);

    }

}











extern "C" {


}

namespace max {

    inline void
    Lexer_Converter_IConv_open(Lexer_Converter_IConv* me,
                                    const char* FromCoding, const char* ToCoding)
    {

        me->base.dynamic_character_size_f = true;


        if( ToCoding == 0 ) {
            switch( sizeof(uint32_t) ) {
            default: ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/iconv/Converter_IConv.i", 36, __PRETTY_FUNCTION__)); return;

            case 4: me->handle = iconv_open("UCS-4LE", FromCoding); break;
            case 2: me->handle = iconv_open("UCS-2LE", FromCoding); break;







            case 1: me->handle = iconv_open("ASCII", FromCoding); break;
            }
        } else {
            me->handle = iconv_open(ToCoding, FromCoding);
        }

        if( me->handle == (iconv_t)-1 ) {


            do { throw std::runtime_error("<<IConv conversion: source or target character encoding name unknown.>>"); } while(0);
        }
    }

    inline bool
    Lexer_Converter_IConv_convert(Lexer_Converter_IConv* me,
                                       uint8_t** source, const uint8_t* SourceEnd,
                                       uint32_t** drain, const uint32_t* DrainEnd)
    {
        size_t source_bytes_left_n = (size_t)(SourceEnd - *source);
        size_t drain_bytes_left_n = (size_t)(DrainEnd - *drain)*sizeof(uint32_t);

        size_t report = iconv(me->handle,
                              (__Adapter_FuncIconv_SecondArgument(source)), &source_bytes_left_n,
                              (char**)drain, &drain_bytes_left_n);

        if( report != (size_t)-1 ) {
            ((source_bytes_left_n == 0) ? static_cast<void> (0) : __assert_fail ("source_bytes_left_n == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/iconv/Converter_IConv.i", 89, __PRETTY_FUNCTION__));


            if( drain_bytes_left_n == 0 ) {
                ((*drain == DrainEnd) ? static_cast<void> (0) : __assert_fail ("*drain == DrainEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/converter/iconv/Converter_IConv.i", 93, __PRETTY_FUNCTION__));
                return true;
            }





            if( *source != SourceEnd ) {

                return true;
            }
            else {


                return false;
            }
        }

        switch( (*__errno_location ()) ) {
        default:
            do { throw std::runtime_error("Unexpected setting of 'errno' after call to GNU's iconv()."); } while(0);

        case 84:
            do { throw std::runtime_error("Invalid byte sequence encountered for given character coding."); } while(0);

        case 22:






            if( *drain == DrainEnd ) return true;
            else return false;

        case 7:


            return true;
        }
    }

    inline void
    Lexer_Converter_IConv_delete_self(Lexer_Converter_IConv* me)
    {
        iconv_close(me->handle);
        Lexer_MemoryManager_Converter_free(me);
    }

    inline Lexer_Converter*
    Lexer_Converter_IConv_new()
    {
        Lexer_Converter_IConv* me =
           (Lexer_Converter_IConv*)Lexer_MemoryManager_Converter_allocate(sizeof(Lexer_Converter_IConv));

        me->base.open = (Lexer_ConverterFunctionP_open)Lexer_Converter_IConv_open;
        me->base.convert = (Lexer_ConverterFunctionP_convert)Lexer_Converter_IConv_convert;
        me->base.delete_self = (Lexer_ConverterFunctionP_delete_self)Lexer_Converter_IConv_delete_self;
        me->base.on_conversion_discontinuity = 0x0;

        me->handle = (iconv_t)-1;

        return (Lexer_Converter*)me;
    }

}













namespace max {

    inline void
    Lexer_Counter_init(Lexer_Counter* me)
    {
        me->_line_number_at_begin = (size_t)0;
        me->_line_number_at_end = (size_t)1;
        me->_column_number_at_begin = (size_t)0;
        me->_column_number_at_end = (size_t)1;
        ;
    }

    inline void
    Lexer_Counter_construct(Lexer_Counter* me)
    {

        memset((void*)me, 0xFF, sizeof(Lexer_Counter));

        Lexer_Counter_init((Lexer_Counter*)me);
    }

    inline void
    Lexer_Counter_reset(Lexer_Counter* me)
    {
        Lexer_Counter_init((Lexer_Counter*)me);
    }

    inline void
    Lexer_Counter_count(Lexer_Counter* me,
                             uint32_t* Begin, uint32_t* End)






    {


        uint32_t* it = Lexer_Counter_count_chars_to_newline_backwards(me, Begin, End);
        if( *it == '\n' ) ++(me->_line_number_at_end);






        ((it >= Begin) ? static_cast<void> (0) : __assert_fail ("it >= Begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 55, __PRETTY_FUNCTION__));


        while( it != Begin ) {
            --it;
            if( *it == '\n' ) ++(me->_line_number_at_end);
        }



    }

    inline void
    Lexer_Counter_count_FixNewlineN(Lexer_Counter* me,
                                                   uint32_t* Lexeme,
                                                   uint32_t* LexemeEnd,
                                                   const int LineNIncrement)
    {
        ((LexemeEnd > Lexeme) ? static_cast<void> (0) : __assert_fail ("LexemeEnd > Lexeme", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 73, __PRETTY_FUNCTION__));


        Lexer_Counter_count_chars_to_newline_backwards(me, (uint32_t*)Lexeme,
                                                            (uint32_t*)(LexemeEnd));

        me->_line_number_at_end += (size_t)LineNIncrement;
    }


    inline uint32_t*
    Lexer_Counter_count_chars_to_newline_backwards(Lexer_Counter* me,
                                                        uint32_t* Begin,
                                                        uint32_t* End)
    {
        uint32_t* it = 0x0;

        ((Begin < End) ? static_cast<void> (0) : __assert_fail ("Begin < End", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 103, __PRETTY_FUNCTION__));
        for(it = End - 1; *it != '\n' ; --it) {
            if( it == Begin ) {




                me->_column_number_at_end += (size_t)(End - Begin);
                return it;
            }
        }

        ((End >= it) ? static_cast<void> (0) : __assert_fail ("End >= it", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 123, __PRETTY_FUNCTION__));


        me->_column_number_at_end = (size_t)(End - it);

        return it;
    }

    inline void
    Lexer_Counter_print_this(Lexer_Counter* me)
    {
        ;

        std::printf("   Counter:\n");

        std::printf("   _line_number_at_begin = %i;\n", (int)me->_line_number_at_begin);
        std::printf("   _line_number_at_end   = %i;\n", (int)me->_line_number_at_end);


        std::printf("   _column_number_at_begin = %i;\n", (int)me->_column_number_at_begin);
        std::printf("   _column_number_at_end   = %i;\n", (int)me->_column_number_at_end);
    }
}



namespace max {

    template <class InputHandleT> inline void
    Lexer_include_push(::max::Lexer* me,
                            InputHandleT* Optional_InputHandle,
                            uint32_t* Optional_InputName,
                            const Lexer_Mode* Mode,
                            const char* CharacterCodecName )
    {



        InputHandleT* input_handle = Optional_InputHandle;

        Lexer_Memento* m = Lexer_memento_pack<InputHandleT>(me, Optional_InputName, &input_handle);




        if( input_handle == 0x0 ) {
            do { throw std::runtime_error("Segment 'memento_pack' segment did not set the input_handle."); } while(0);
        }




        Lexer_Buffer_construct(&me->buffer, input_handle,
                                    0x0, 65536, 0x0,
                                    CharacterCodecName, ((size_t)65536),
                                    me->buffer._byte_order_reversion_active_f);


        if( Mode != 0x0 ) Lexer_set_mode_brutally(me, (Lexer_Mode*)Mode);
        Lexer_Counter_construct(&me->counter);



        Lexer_Accumulator_construct(&me->accumulator, me);




        me->__file_handle_allocated_by_constructor = 0x0;


        me->_parent_memento = m;
    }

    template <class InputHandleT> inline void
    Lexer_include_push_input_name(::max::Lexer* me,
                                       uint32_t* InputName,
                                       const Lexer_Mode* mode,
                                       const char* CharacterCodecName )
    {



        Lexer_include_push<InputHandleT>(me, 0x0, InputName, mode, CharacterCodecName);



    }

    template <class InputHandleT> inline void
    Lexer_include_push_input_handle(::max::Lexer* me,
                                         InputHandleT* sh,
                                         const Lexer_Mode* mode,
                                         const char* CharacterCodecName )
    {


        Lexer_include_push<InputHandleT>(me, sh, 0x0, mode, CharacterCodecName);



    }

    inline bool
    Lexer_include_pop(::max::Lexer* me)
    {

        if( me->_parent_memento == 0x0 ) return false;



        Lexer_Buffer_destruct(&me->buffer);
        Lexer_Accumulator_destruct(&me->accumulator);







        Lexer_memento_unpack(me, me->_parent_memento);


        return true;
    }

    inline void
    Lexer_include_stack_delete(::max::Lexer* me)
    {
        while( me->_parent_memento != 0x0 ) {
            if( Lexer_include_pop(me) == false ) {
                do { throw std::runtime_error("Error during deletion of include stack."); } while(0);
            }
        }
    }


    template <class InputHandleT> inline void
    Lexer::include_push(InputHandleT* sh,
                              const Lexer_Mode* Mode,
                              const char* CharacterCodecName )
    { Lexer_include_push_input_handle<InputHandleT>(this, sh, Mode, CharacterCodecName); }

    template <class InputHandleT> inline void
    Lexer::include_push(uint32_t* InputName,
                              const Lexer_Mode* Mode,
                              const char* CharacterCodecName )
    { Lexer_include_push_input_name<InputHandleT>(this, InputName, Mode, CharacterCodecName); }

    inline bool
    Lexer::include_pop()
    { return Lexer_include_pop(this); }

    inline void
    Lexer::include_stack_delete()
    { Lexer_include_stack_delete(this); }


}




namespace max {

inline void
Lexer_Accumulator_construct(Lexer_Accumulator* me,
                                 ::max::Lexer* lexer)
{
    me->the_lexer = lexer;
    Lexer_Accumulator_init_memory(me);
    me->_begin_line = 0;
    me->_begin_column = 0;
}


inline void
Lexer_Accumulator_destruct(Lexer_Accumulator* me)
{
    if( me->text.begin != 0x0 ) {
        Lexer_MemoryManager_Text_free(me->text.begin);
    }
    me->the_lexer = 0x0;
    me->text.begin = 0x0;
    me->text.end = 0x0;
    me->text.memory_end = 0x0;
}

inline void
Lexer_Accumulator_init_memory(Lexer_Accumulator* me)
{
    if( (256) == 0 ) {
        me->text.begin = 0x0;
    } else {
        me->text.begin =
 Lexer_MemoryManager_Text_allocate(
                      (256) * sizeof(uint32_t));
        if( me->text.begin == 0x0 ) {
            do { throw std::runtime_error("Quex engine: out of memory--cannot allocate Accumulator."); } while(0);
        }
    }
    me->text.end = me->text.begin;
    me->text.memory_end = me->text.begin + (256);
}

inline bool
Lexer_Accumulator_extend(Lexer_Accumulator* me, size_t MinAddSize)
{
    const size_t OldContentSize = (size_t)(me->text.end - me->text.begin);
    const size_t Size = (size_t)(me->text.memory_end - me->text.begin);
    const size_t AddSize = (size_t)((float)Size * (float)(0.8));
    const size_t NewSize = Size + (AddSize < MinAddSize ? MinAddSize : AddSize);

    uint32_t* chunk =
 Lexer_MemoryManager_Text_allocate(NewSize*sizeof(uint32_t));

    if( chunk == 0x0 ) return false;

    ((me->text.end >= me->text.begin) ? static_cast<void> (0) : __assert_fail ("me->text.end >= me->text.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 71, __PRETTY_FUNCTION__));
    ((me->text.memory_end >= me->text.begin) ? static_cast<void> (0) : __assert_fail ("me->text.memory_end >= me->text.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 72, __PRETTY_FUNCTION__));

    std::memcpy(chunk, me->text.begin, sizeof(uint32_t) * Size);

    Lexer_MemoryManager_Text_free(me->text.begin);

    me->text.begin = chunk;
    me->text.end = chunk + OldContentSize;
    me->text.memory_end = chunk + NewSize;
    return true;
}

inline void
Lexer_Accumulator_clear(Lexer_Accumulator* me)
{

    if( me->text.begin == me->text.end ) return;
    me->text.end = me->text.begin;
}

inline void
Lexer_Accumulator_add(Lexer_Accumulator* me,
                           const uint32_t* Begin, const uint32_t* End)
{
    const size_t L = (size_t)(End - Begin);
    ((End > Begin) ? static_cast<void> (0) : __assert_fail ("End > Begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 97, __PRETTY_FUNCTION__));



    if( me->text.begin == me->text.end ) {
        me->_begin_column = me->the_lexer->counter._column_number_at_begin;
        me->_begin_line = me->the_lexer->counter._line_number_at_begin;
    }




    if( me->text.memory_end <= me->text.end + L ) {

        if( Lexer_Accumulator_extend(me, L + 1) == false ) {
            do { throw std::runtime_error("Quex Engine: Out of Memory. Accumulator could not be further extended.\n"); } while(0);
        }
    }

    std::memcpy(me->text.end, Begin, L * sizeof(uint32_t));
    me->text.end += L;
}


inline void
Lexer_Accumulator_add_character(Lexer_Accumulator* me,
                                     const uint32_t Character)
{


    if( me->text.begin == me->text.end ) {
        me->_begin_column = me->the_lexer->counter._column_number_at_begin;
        me->_begin_line = me->the_lexer->counter._line_number_at_begin;
    }




    if( me->text.memory_end <= me->text.end + 1 ) {

        if( Lexer_Accumulator_extend(me, 2) == false ) {
            do { throw std::runtime_error("Quex Engine: Out of Memory. Accumulator could not be further extended.\n"); } while(0);
        }
    }

    *(me->text.end) = Character;
    ++(me->text.end);
}
inline void
Lexer_Accumulator_print_this(Lexer_Accumulator* me)
{

    ((me->text.end < me->text.memory_end) ? static_cast<void> (0) : __assert_fail ("me->text.end < me->text.memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 181, __PRETTY_FUNCTION__));

    *(me->text.end) = (uint32_t)0;

    std::printf("   Accumulator = '%s'\n", (const char*)me->text.begin);
}

}


namespace max {
}








namespace boeck {
    struct Lexer_Engine_tag;
    struct Lexer_Memento_tag;

    class Lexer;
    typedef uint32_t (*Lexer_AnalyzerFunctionP)(::boeck::Lexer*);
}



namespace boeck {
    class Token;
}






       


namespace boeck {




inline void
utf8_to_utf8_character(const uint8_t** input_pp,
                                           uint8_t** output_pp);
inline void
utf8_to_utf16_character(const uint8_t** input_pp,
                                            uint16_t** output_pp);
inline void
utf8_to_utf32_character(const uint8_t** input_pp,
                                            uint32_t** output_pp);
inline void
utf8_to_char_character(const uint8_t** input_pp,
                                           char** output_pp);

inline void
utf8_to_wchar_character(const uint8_t** input_pp,
                                            wchar_t** output_pp);



inline void
utf8_to_utf8(const uint8_t** source_pp,
                                             const uint8_t* SourceEnd,
                                             uint8_t** drain_pp,
                                             const uint8_t* DrainEnd);
inline void
utf8_to_utf16(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              uint16_t** drain_pp,
                                              const uint16_t* DrainEnd);
inline void
utf8_to_utf32(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              uint32_t** drain_pp,
                                              const uint32_t* DrainEnd);
inline void
utf8_to_char(const uint8_t** source_pp,
                                             const uint8_t* SourceEnd,
                                             char** drain_pp,
                                             const char* DrainEnd);


inline void
utf8_to_wchar(const uint8_t** source_pp,
                                              const uint8_t* SourceEnd,
                                              wchar_t** drain_pp,
                                              const wchar_t* DrainEnd);



    inline std::basic_string<uint8_t>
    utf8_to_utf8(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<uint16_t>
    utf8_to_utf16(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<uint32_t>
    utf8_to_utf32(const std::basic_string<uint8_t>& Source);
    inline std::basic_string<char>
    utf8_to_char(const std::basic_string<uint8_t>& Source);

    inline std::basic_string<wchar_t>
    utf8_to_wchar(const std::basic_string<uint8_t>& Source);

}







namespace boeck {

inline size_t
Lexer_strlen(const uint8_t* Str);


inline size_t
Lexer_strcmp(const uint8_t* it0,
                  const uint8_t* it1);

}














namespace boeck {
    struct Lexer_MemoryPositionMimiker {

        typedef size_t character_index;







        Lexer_MemoryPositionMimiker(uint8_t* Adr=0x0, character_index Pos=0)
            : address(Adr), buffer_start_position(Pos) {}

        uint8_t* address;
        character_index buffer_start_position;

        bool operator==(const Lexer_MemoryPositionMimiker& That)
        {
          ((this->buffer_start_position == That.buffer_start_position) ? static_cast<void> (0) : __assert_fail ("this->buffer_start_position == That.buffer_start_position", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/MemoryPositionMimiker", 63, __PRETTY_FUNCTION__));
          return this->address == That.address;
        }
        bool operator!=(const Lexer_MemoryPositionMimiker& That)
        { return ! (this->operator==(That)); }

        bool operator==(const uint8_t* ThatAdr) { return this->address == ThatAdr; }
        bool operator!=(const uint8_t* ThatAdr) { return this->address != ThatAdr; }




        void operator+=(const ptrdiff_t Value) { address += Value; buffer_start_position -= (character_index)Value; }
        void operator-=(const ptrdiff_t Value) { address -= Value; buffer_start_position += (character_index)Value; }



        operator uint8_t*() { return address; }
    };

}



namespace boeck {

    typedef struct {






        uint8_t* _front;
        uint8_t* _back;




        uint8_t* _end_of_file_p;


        bool _external_owner_f;
    } Lexer_BufferMemory;

    inline size_t Lexer_BufferMemory_size(Lexer_BufferMemory*);

    typedef struct {
        Lexer_BufferMemory _memory;


        uint8_t* _input_p;
        uint8_t* _lexeme_start_p;
        uint8_t _character_at_lexeme_start;






        ptrdiff_t _content_character_index_begin;





        ptrdiff_t _content_character_index_end;



        bool _byte_order_reversion_active_f;

        struct Lexer_BufferFiller_tag* filler;

        void (*on_buffer_content_change)(uint8_t* BeginOfContent,
                                              uint8_t* EndOfContent);
    } Lexer_Buffer;

    template <class InputHandleT> inline void Lexer_Buffer_construct(Lexer_Buffer* me,
                                                                  InputHandleT* input_handle,
                                                                  uint8_t* InputMemory,
                                                                  const size_t BufferMemorySize,
                                                                  uint8_t* EndOfFileP,
                                                                  const char* CharacterEncodingName,
                                                                  const size_t TranslationBufferMemorySize,
                                                                  bool ByteOrderReversionF);

    template <class InputHandleT> inline void Lexer_Buffer_reset(Lexer_Buffer* me,
                                                              InputHandleT* input_handle,
                                                              const char* CharacterEncodingName,
                                                              const size_t TranslationBufferMemorySize);

    inline void Lexer_Buffer_destruct(Lexer_Buffer* me);

    inline uint8_t* Lexer_Buffer_content_front(Lexer_Buffer*);
    inline uint8_t* Lexer_Buffer_content_back(Lexer_Buffer*);
    inline uint8_t* Lexer_Buffer_text_end(Lexer_Buffer*);
    inline size_t Lexer_Buffer_content_size(Lexer_Buffer*);

    inline Lexer_MemoryPositionMimiker Lexer_Buffer_tell_memory_adr(Lexer_Buffer*);
    inline void Lexer_Buffer_seek_memory_adr(Lexer_Buffer*,
                                                                                Lexer_MemoryPositionMimiker);

    inline void Lexer_Buffer_move_forward(Lexer_Buffer*, const ptrdiff_t CharacterN);
    inline void Lexer_Buffer_move_backward(Lexer_Buffer*, const ptrdiff_t CharacterN);
    inline ptrdiff_t Lexer_Buffer_tell(Lexer_Buffer*);
    inline void Lexer_Buffer_seek(Lexer_Buffer*, const ptrdiff_t CharacterIndex);
    inline void Lexer_Buffer_move_away_passed_content(Lexer_Buffer* me);

    inline void Lexer_Buffer_end_of_file_set(Lexer_Buffer*, uint8_t* Position);
    inline void Lexer_Buffer_end_of_file_unset(Lexer_Buffer*);
    inline bool Lexer_Buffer_is_end_of_file(Lexer_Buffer*);
    inline bool Lexer_Buffer_is_begin_of_file(Lexer_Buffer*);

    inline void Lexer_Buffer_reverse_byte_order(uint8_t* Begin,
                                                             uint8_t* End);

    inline void Lexer_Buffer_print_this(Lexer_Buffer*);

    inline uint8_t* Lexer_BufferMemory_reset(Lexer_BufferMemory* me,
                                                                      uint8_t* Memory,
                                                                      const size_t Size,
                                                                      uint8_t* EndOfContentP);

}

namespace boeck {

    inline uint8_t* Lexer_access_Lexeme(const char* FileName, size_t LineN, Lexer_Buffer*);
    inline size_t Lexer_access_LexemeL(const char* FileName, size_t LineN, Lexer_Buffer*);
    inline uint8_t* Lexer_access_LexemeEnd(const char* FileName, size_t LineN, Lexer_Buffer*);

}








namespace boeck {

     typedef struct Lexer_BufferFiller_tag {
        ptrdiff_t (*tell_character_index)(struct Lexer_BufferFiller_tag*);





        void (*seek_character_index)(struct Lexer_BufferFiller_tag*,
                                            const ptrdiff_t Index);


        size_t (*read_characters)(struct Lexer_BufferFiller_tag*,
                                       uint8_t* memory, const size_t N);



        bool (*_on_overflow)(Lexer_Buffer*, bool ForwardF);



        void (*delete_self)(struct Lexer_BufferFiller_tag*);

    } Lexer_BufferFiller;

    inline void
    Lexer_BufferFiller_setup_functions(Lexer_BufferFiller* me,
                                            ptrdiff_t (*tell_character_index)(Lexer_BufferFiller*),
                                            void (*seek_character_index)(Lexer_BufferFiller*,
                                                                                 const ptrdiff_t),
                                            size_t (*read_characters)(Lexer_BufferFiller*,
                                                                            uint8_t*, const size_t),
                                            void (*delete_self)(Lexer_BufferFiller*));
    template <class InputHandleT> inline Lexer_BufferFiller*
    Lexer_BufferFiller_new(InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize);
    inline void Lexer_BufferFiller_delete_self(Lexer_BufferFiller*);

    inline void Lexer_BufferFiller_initial_load(Lexer_Buffer*);
    inline size_t Lexer_BufferFiller_load_forward(Lexer_Buffer*);
    inline size_t Lexer_BufferFiller_load_backward(Lexer_Buffer*);



    inline void Lexer_BufferFiller_step_forward_n_characters(Lexer_BufferFiller* me,
                                                                          const ptrdiff_t ForwardN);

}





       










       



namespace boeck {
    template <class InputHandleT> struct InputPolicy;

    template <>
    struct InputPolicy<void*> {
        typedef long stream_position;
        typedef long stream_offset;



        static long tell(void* me) { (void)me; return -1L; }
        static void seek(void* me, long& Pos) { (void)me; (void)Pos; ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 30, __PRETTY_FUNCTION__)); }
        static size_t load_bytes(void*, void*, const size_t) { return (size_t)0; }
    };

    template <>
    struct InputPolicy<std::FILE*> {
        typedef long stream_position;
        typedef long stream_offset;

        static long tell(std::FILE* me) { return std::ftell(me); }
        static void seek(std::FILE* me, long& Pos) { std::fseek(me, Pos, 0); }

        static size_t load_bytes(std::FILE* ih, void* buffer_position, const size_t ByteNToRead)
        {
            return fread(buffer_position, 1, ByteNToRead, ih);
        }
    };

    template <class StdStreamType>
    struct InputPolicy<StdStreamType*> {
        typedef typename StdStreamType::pos_type stream_position;
        typedef typename StdStreamType::off_type stream_offset;

        typedef typename StdStreamType::char_type character_type;
        static const size_t CharacterSize = sizeof(typename StdStreamType::char_type);

        static stream_position tell(StdStreamType* me) {
            return me->tellg() * CharacterSize;
        }
        static void seek(StdStreamType* me, const stream_position& Pos) {
            ((Pos % CharacterSize == 0) ? static_cast<void> (0) : __assert_fail ("Pos % CharacterSize == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 74, __PRETTY_FUNCTION__));
            me->seekg(Pos / CharacterSize);
        }

        static size_t load_bytes(StdStreamType* me, void* buffer_position, const size_t ByteNToRead)
        {
            ((CharacterSize != 0) ? static_cast<void> (0) : __assert_fail ("CharacterSize != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/InputPolicy", 80, __PRETTY_FUNCTION__));
            const stream_position position_before = me->tellg();



            me->read((character_type*)buffer_position, ByteNToRead / CharacterSize);

            const size_t Result = (size_t)(me->gcount());

            if( me->eof() && ! me->bad() ) {
                me->clear();


                if( position_before != (stream_position)-1 ) {
                    me->seekg(position_before + (stream_offset)(Result));
                }
            } else if( me->fail() ) {
                throw std::runtime_error("Fatal error during stream reading.");
            }


            return Result * CharacterSize;
        }
    };







}




namespace boeck {

    template <class InputHandleT> struct Lexer_BufferFiller_Plain {


        Lexer_BufferFiller base;

        InputHandleT* ih;


        typename InputPolicy<InputHandleT*>::stream_position start_position;

        typename InputPolicy<InputHandleT*>::stream_position _last_stream_position;




    } ;

    template <class InputHandleT> inline Lexer_BufferFiller_Plain<InputHandleT>*
    Lexer_BufferFiller_Plain_new(InputHandleT* input_handle);





}



namespace boeck {

inline uint8_t*
Lexer_MemoryManager_BufferMemory_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferMemory_free(uint8_t* memory);

inline void*
Lexer_MemoryManager_BufferFiller_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferFiller_free(void* memory);

inline uint8_t*
Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN);

inline void
Lexer_MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory);


inline uint8_t*
Lexer_MemoryManager_Text_allocate(const size_t ByteN);
inline void
Lexer_MemoryManager_Text_free(uint8_t* memory);


inline void* Lexer_MemoryManager_Converter_allocate(const size_t ByteN);
inline void Lexer_MemoryManager_Converter_free(void* memory);






inline size_t
Lexer_MemoryManager_insert(uint8_t* drain_begin_p, uint8_t* drain_end_p,
                                uint8_t* source_begin_p, uint8_t* source_end_p);
inline struct Lexer_Memento_tag*
Lexer_MemoryManager_Memento_allocate();

inline void
Lexer_MemoryManager_Memento_free(struct Lexer_Memento_tag* memory);


}








namespace boeck {




    class Lexer;


    typedef struct Lexer_Mode_tag {
        int id;
        const char* name;
        ::boeck::Lexer* the_lexer;

        Lexer_AnalyzerFunctionP analyzer_function;






        void (*on_entry)(::boeck::Lexer*, const struct Lexer_Mode_tag* FromMode);
        void (*on_exit)(::boeck::Lexer*, const struct Lexer_Mode_tag* ToMode);

        bool (*has_base)(const struct Lexer_Mode_tag* Mode);
        bool (*has_entry_from)(const struct Lexer_Mode_tag* Mode);
        bool (*has_exit_to)(const struct Lexer_Mode_tag* Mode);

    } Lexer_Mode;

    inline uint32_t
    Lexer_Mode_uncallable_analyzer_function(::boeck::Lexer*);


    inline void
    Lexer_Mode_on_indentation_null_function(::boeck::Lexer*,
                                                 uint8_t* LexemeBegin,
                                                 uint8_t* LexemeEnd);


    inline void
    Lexer_Mode_on_entry_exit_null_function(::boeck::Lexer*, const Lexer_Mode*);

}









       







namespace boeck {
    typedef struct {

        size_t _line_number_at_begin;
        size_t _line_number_at_end;


        size_t _column_number_at_begin;
        size_t _column_number_at_end;





    } Lexer_Counter;


    inline void Lexer_Counter_construct(Lexer_Counter* me);
    inline void Lexer_Counter_init(Lexer_Counter* me);
    inline void Lexer_Counter_reset(Lexer_Counter* me);
    inline void Lexer_Counter_copy_construct(Lexer_Counter* me,
                                                       const Lexer_Counter* That);

    inline void Lexer_Counter_count(Lexer_Counter* me,
                                                         uint8_t* Lexeme,
                                                         uint8_t* LexemeEnd);
    inline uint8_t*
    Lexer_Counter_count_chars_to_newline_backwards(Lexer_Counter* me,
                                                        uint8_t* Begin,
                                                        uint8_t* End);

    inline void Lexer_Counter_print_this(Lexer_Counter* me);

}









namespace boeck {

    struct Lexer_Memento_tag;







    template <class InputHandleT> inline



    Lexer_Memento_tag*
    Lexer_memento_pack(::boeck::Lexer* me,
                            uint8_t* InputName,
                            InputHandleT** input_handle);


    inline

                            void
    Lexer_memento_unpack(::boeck::Lexer* me,
                              struct Lexer_Memento_tag* memento);

    template <class InputHandleT> inline void
    Lexer_include_push(::boeck::Lexer* me,
                            InputHandleT* Optional_InputHandle,
                            uint8_t* Optional_InputName,
                            const Lexer_Mode* Mode,
                            const char* CharacterCodecName );

    template <class InputHandleT> inline void
    Lexer_include_push_input_name(::boeck::Lexer* me,
                                       uint8_t* InputName ,
                                       const Lexer_Mode* mode ,
                                       const char* CharacterCodecName );

    template <class InputHandleT> inline void
    Lexer_include_push_input_handle(::boeck::Lexer* me,
                                         InputHandleT* sh ,
                                         const Lexer_Mode* mode ,
                                         const char* CharacterCodecName );

    inline bool Lexer_include_pop(::boeck::Lexer* me);

    inline void Lexer_include_stack_delete(::boeck::Lexer* me);


}


namespace boeck {




    class Lexer;



    typedef struct {

        size_t _begin_line;


        size_t _begin_column;


        struct {
            uint8_t* begin;
            uint8_t* end;
            uint8_t* memory_end;
        } text;
        ::boeck::Lexer* the_lexer;

    } Lexer_Accumulator;

    inline void
    Lexer_Accumulator_init_memory(Lexer_Accumulator* me);

    inline void
    Lexer_Accumulator_construct(Lexer_Accumulator*, ::boeck::Lexer*);

    inline void
    Lexer_Accumulator_destruct(Lexer_Accumulator* me);

    inline bool
    Lexer_Accumulator_extend(Lexer_Accumulator* me, size_t MinAddSize);

    inline void
    Lexer_Accumulator_clear(Lexer_Accumulator* me);

    inline void
    Lexer_Accumulator_add(Lexer_Accumulator* me,
                               const uint8_t* Begin, const uint8_t* End);

    inline void
    Lexer_Accumulator_add_character(Lexer_Accumulator* me,
                                         const uint8_t Character);

    inline void
    Lexer_Accumulator_print_this(Lexer_Accumulator* me);

}

namespace boeck {

    template <class InputHandleT> inline void
    Lexer_construct_basic(::boeck::Lexer* me,
                               InputHandleT* input_handle,
                               uint8_t* BufferMemory,
                               const size_t BufferMemorySize,
                               uint8_t* EndOfFileP,
                               const char* CharacterEncodingName,
                               const size_t TranslationBufferMemorySize,
                               bool ByteOrderReversionF);

    inline void
    Lexer_destruct_basic(::boeck::Lexer* me);

    template <class InputHandleT> inline void
    Lexer_reset_basic(::boeck::Lexer* me,
                           InputHandleT* input_handle,
                           const char* CharacterEncodingName,
                           const size_t TranslationBufferMemorySize);

    inline void Lexer_buffer_reload_backward(Lexer_Buffer* buffer);
    inline void Lexer_buffer_reload_forward(Lexer_Buffer* buffer,
                                                           Lexer_MemoryPositionMimiker* post_context_start_position,
                                                           const size_t PostContextN);

}



namespace boeck {




template <class InputHandleT> inline

void
Lexer_constructor_core(::boeck::Lexer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            bool ByteOrderReversionF,
                            uint8_t* BufferMemory,
                            size_t BufferMemorySize,
                            uint8_t* BufferEndOfFileP);

inline void
Lexer_construct_memory(::boeck::Lexer* me,
                            uint8_t* BufferMemoryBegin,
                            size_t BufferMemorySize,
                            uint8_t* BufferEndOfFileP,
                            const char* CharacterEncodingName ,
                            bool ByteOrderReversionF );

inline void
Lexer_construct_file_name(::boeck::Lexer* me,
                               const char* Filename,
                               const char* CharacterEncodingName ,
                               bool ByteOrderReversionF );

inline void
Lexer_construct_FILE(::boeck::Lexer* me,
                          std::FILE* fh,
                          const char* CharacterEncodingName ,
                          bool ByteOrderReversionF );


inline void
Lexer_construct_istream(::boeck::Lexer* me,
                             std::istream* p_input_stream,
                             const char* CharacterEncodingName ,
                             bool ByteOrderReversionF );




inline void
Lexer_construct_wistream(::boeck::Lexer* me,
                              std::wistream* p_input_stream,
                              const char* CharacterEncodingName ,
                              bool ByteOrderReversionF );


inline void
Lexer_destruct(::boeck::Lexer* me);

template <class InputHandleT> inline void
Lexer_reset(::boeck::Lexer* me,
                 InputHandleT* input_handle,
                 const char* CharacterEncodingName );

inline uint8_t*
Lexer_reset_buffer(::boeck::Lexer* me,
                        uint8_t* BufferMemoryBegin,
                        size_t BufferMemorySize,
                        uint8_t* BufferEndOfContentP,
                        const char* CharacterEncodingName );

inline void
Lexer_reset_plain(::boeck::Lexer* me,
                       const char* CharacterEncodingName );

}

namespace boeck {


inline void* Lexer_buffer_fill_region_append(::boeck::Lexer* me,
                                                                        void* ContentBegin,
                                                                        void* ContentEnd);
inline void Lexer_buffer_fill_region_prepare(::boeck::Lexer* me);
inline uint8_t* Lexer_buffer_fill_region_begin(::boeck::Lexer* me);
inline uint8_t* Lexer_buffer_fill_region_end(::boeck::Lexer* me);
inline size_t Lexer_buffer_fill_region_size(::boeck::Lexer* me);
inline void Lexer_buffer_fill_region_finish(::boeck::Lexer* me,
                                                                        const size_t LoadedN);

inline uint8_t* Lexer_buffer_lexeme_start_pointer_get(::boeck::Lexer* me);
inline void Lexer_buffer_input_pointer_set(::boeck::Lexer* me,
                                                                       uint8_t*);
}
namespace boeck {


inline void
Lexer_set_callback_on_buffer_content_change(::boeck::Lexer* me,
                                                 void (*callback)(uint8_t*,
                                                                                uint8_t*));


inline bool Lexer_byte_order_reversion(::boeck::Lexer* me);
inline void Lexer_byte_order_reversion_set(::boeck::Lexer* me,
                                                          bool Value);

inline const char* Lexer_version(::boeck::Lexer* me);


inline ::boeck::Token* Lexer_token_p(::boeck::Lexer* me);
inline void Lexer_print_this(::boeck::Lexer* me);

}
namespace boeck {


inline size_t Lexer_tell(::boeck::Lexer* me);
inline void Lexer_seek(::boeck::Lexer* me, const size_t);
inline void Lexer_seek_forward(::boeck::Lexer* me, const size_t);
inline void Lexer_seek_backward(::boeck::Lexer* me, const size_t);
inline void Lexer_undo(::boeck::Lexer* me);
inline void Lexer_undo_n(::boeck::Lexer* me, size_t DeltaN_Backward);

}
namespace boeck {


inline Lexer_Mode* Lexer_mode(::boeck::Lexer* me);
inline int Lexer_mode_id(::boeck::Lexer* me);
inline const char* Lexer_mode_name(::boeck::Lexer* me);


inline Lexer_Mode* Lexer_map_mode_id_to_mode(::boeck::Lexer* me,
                                                              const int ModeID);
inline int Lexer_map_mode_to_mode_id(const ::boeck::Lexer* me,
                                                              const Lexer_Mode* Mode);


inline void Lexer_set_mode_brutally_by_id(::boeck::Lexer* me,
                                                           const int LexerMode);
inline void Lexer_set_mode_brutally(::boeck::Lexer* me,
                                                     Lexer_Mode* Mode);
inline void Lexer_enter_mode(::boeck::Lexer* me,
                                                             Lexer_Mode* TargetMode);


inline void Lexer_pop_mode(::boeck::Lexer* me);
inline void Lexer_pop_drop_mode(::boeck::Lexer* me);
inline void Lexer_push_mode(::boeck::Lexer* me, Lexer_Mode* new_mode);

}
namespace boeck {
    inline uint32_t
    Lexer_receive(::boeck::Lexer* me);





}







namespace boeck {
}

       
namespace boeck {
extern uint8_t Lexer_LexemeNullObject;
}






namespace boeck {


class Token;



extern const char* Token_map_id_to_name(const uint32_t);

inline void Token_construct(Token* __this);
inline void Token_destruct(Token* __this);
inline void Token_copy(Token* me, const Token* That);
inline bool Token_take_text(Token* __this,
                                          ::boeck::Lexer* analyzer,
                                          const uint8_t* Begin,
                                          const uint8_t* End);






class Token {
public:
    Token();
    Token(const Token& That);


    Token& operator=(const Token& That)
    { Token_copy(this, &That); return *this; }
    virtual ~Token();
    std::basic_string<uint8_t> text;
    size_t number;


public:
    std::basic_string<uint8_t> get_text() const { return text; }
    void set_text(std::basic_string<uint8_t>& Value) { text = Value; }
    size_t get_number() const { return number; }
    void set_number(size_t Value) { number = Value; }

    void set(const uint32_t ID) { _id = ID; }
    void set(const uint32_t ID, const std::basic_string<uint8_t>& Value0)
    { _id = ID; text = Value0; }
    void set(const uint32_t ID, const size_t& Value0)
    { _id = ID; number = Value0; }
    void set(const uint32_t ID, const std::basic_string<uint8_t>& Value0, const size_t& Value1)
    { _id = ID; text = Value0; number = Value1; }


    public:




        uint32_t _id;
        uint32_t type_id() const { return _id; }
        const char* map_id_to_name(uint32_t ID) const { return Token_map_id_to_name(ID); }
        const std::string type_id_name() const { return map_id_to_name(_id); }



    public:
        size_t _line_n;
        size_t line_number() const { return _line_n; }
        void set_line_number(const size_t Value) { _line_n = Value; }


    public:
        size_t _column_n;
        size_t column_number() const { return _column_n; }
        void set_column_number(const size_t Value) { _column_n = Value; }


    public:

        typedef std::basic_string<uint8_t> __string;

        operator
        const std::string() const
        { return get_string(); }

        const std::string
        get_string() const
        {
            std::string tmp;

            tmp = map_id_to_name((*this)._id);

            tmp += " '" + pretty_char_text() + "' ";

            return tmp;
        }

        const std::string
        pretty_char_text() const
        {
            std::string tmp = ::boeck:: utf8_to_char((*this).text);
            std::string::size_type pos = 0;

            while( (pos = tmp.find("\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\n");
            while( (pos = tmp.find("\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\t");
            while( (pos = tmp.find("\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, "\\r");

            return tmp;
        }


        const std::wstring
        pretty_wchar_text() const
        {
            std::wstring tmp = ::boeck:: utf8_to_wchar((*this).text);
            std::wstring::size_type pos = 0;

            while( (pos = tmp.find(L"\n") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\n");
            while( (pos = tmp.find(L"\t") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\t");
            while( (pos = tmp.find(L"\r") ) != __string::npos ) tmp.replace(pos, (size_t)1, L"\\r");

            return tmp;
        }



    private:
        friend void Token_copy(Token* me, const Token* That);
        friend bool Token_take_text(Token* __this,
                                               ::boeck::Lexer* analyzer,
                                               const uint8_t* Begin,
                                               const uint8_t* End);
};

}

        namespace boeck {

        inline std::ostream&
        operator<<(std::ostream& ostr, const Token& Tok)
        { ostr << std::string(Tok); return ostr; }
        }






namespace boeck {



inline void

utf8_to_utf8_character(const uint8_t** input_pp, uint8_t** output_pp)
{

    if( (**input_pp & (uint8_t)0x80) == (uint8_t)0 ) {
        *((*output_pp)++) = *(*input_pp)++;
    }
    else if( **input_pp < (uint8_t)0xE0 ) {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
    else if( **input_pp < (uint8_t)0xF0 ) {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
    else {
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
        *((*output_pp)++) = *(*input_pp)++;
    }
}

inline void

utf8_to_utf16_character(const uint8_t** input_pp, uint16_t** output_pp)
{
    const uint8_t* iterator = *input_pp;
    uint32_t tmp = 0;

    if( (*iterator & (uint8_t)0x80) == (uint8_t)0 ) {

        **output_pp = (uint16_t)*(iterator++);

        ++(*output_pp);
    }
    else if( *iterator < (uint8_t)0xE0 ) {


        **output_pp = (uint16_t)(( ((uint16_t)*(iterator++)) & (uint16_t)0x1F ) << 6);
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F )));

        ++(*output_pp);
    }
    else if( *iterator < (uint8_t)0xF0 ) {


        **output_pp = (uint16_t)(( ((uint16_t)*(iterator++)) & (uint16_t)0x0F ) << 12);
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F ) << 6));
        **output_pp = (uint16_t)((**output_pp) | (( ((uint16_t)*(iterator++)) & (uint16_t)0x3F )));

        ++(*output_pp);
    }
    else {
        tmp = (uint32_t)( (((uint32_t)*(iterator++)) & (uint32_t)0x07 ) << 18);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 12);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        tmp = (uint32_t)(tmp | (((uint32_t)*(iterator++)) & (uint32_t)0x3F ));

        tmp = (uint32_t)(tmp - (uint32_t)0x10000);
        *((*output_pp)++) = (uint16_t)((tmp >> 10) | (uint32_t)0xD800);
        *((*output_pp)++) = (uint16_t)((tmp & (uint32_t)0x3FF) | (uint32_t)0xDC00);
    }
    *input_pp = iterator;
}

inline void

utf8_to_utf32_character(const uint8_t** input_pp, uint32_t** output_pp)
{
    const uint8_t* iterator = *input_pp;

    if( (*iterator & (uint8_t)0x80) == (uint8_t)0 ) {

        **output_pp = (uint32_t)*(iterator++);
    }
    else if( *iterator < (uint8_t)0xE0 ) {


        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x1F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    else if( *iterator < (uint8_t)0xF0 ) {


        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x0F ) << 12);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    else {






        **output_pp = ( ( ((uint32_t)*(iterator++)) & (uint32_t)0x07 ) << 18);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 12);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ) << 6);
        **output_pp = (uint32_t)((**output_pp) | ( ((uint32_t)*(iterator++)) & (uint32_t)0x3F ));
    }
    ++(*output_pp);
    *input_pp = iterator;
}




inline void
utf8_to_char_character(const uint8_t** source_pp,
                                         char** drain_pp)
{
    switch( sizeof(char) )
    {
    case 1:
        ::boeck:: utf8_to_utf8_character(source_pp, (uint8_t**)drain_pp);
        break;
    case 2:
        ::boeck:: utf8_to_utf16_character(source_pp, (uint16_t**)drain_pp);
        break;
    case 4:
        ::boeck:: utf8_to_utf32_character(source_pp, (uint32_t**)drain_pp);
        break;
    default:
        ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 46, __PRETTY_FUNCTION__));
    }
}


    inline void
    utf8_to_wchar_character(const uint8_t** source_pp,
                                                wchar_t** drain_pp)
    {
        switch( sizeof(wchar_t) )
        {
        case 1:
            ::boeck:: utf8_to_utf8_character(source_pp, (uint8_t**)drain_pp);
            break;
        case 2:
            ::boeck:: utf8_to_utf16_character(source_pp, (uint16_t**)drain_pp);
            break;
        case 4:
            ::boeck:: utf8_to_utf32_character(source_pp, (uint32_t**)drain_pp);
            break;
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/character-converter-to-char-wchar_t.gi", 67, __PRETTY_FUNCTION__));
        }
    }



inline void
utf8_to_utf8(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint8_t** drain_pp,
                                                  const uint8_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint8_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::boeck:: utf8_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint8_t>
utf8_to_utf8(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint8_t drain[4 + 1];
    uint8_t* drain_iterator = 0;
    std::basic_string<uint8_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::boeck:: utf8_to_utf8_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint8_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_utf16(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint16_t** drain_pp,
                                                  const uint16_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint16_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)2 ) break;
        ::boeck:: utf8_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint16_t>
utf8_to_utf16(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint16_t drain[2 + 1];
    uint16_t* drain_iterator = 0;
    std::basic_string<uint16_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::boeck:: utf8_to_utf16_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint16_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_utf32(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  uint32_t** drain_pp,
                                                  const uint32_t* DrainEnd)
{
    const uint8_t* source_iterator;
    uint32_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)1 ) break;
        ::boeck:: utf8_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<uint32_t>
utf8_to_utf32(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    uint32_t drain[1 + 1];
    uint32_t* drain_iterator = 0;
    std::basic_string<uint32_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::boeck:: utf8_to_utf32_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((uint32_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}


inline void
utf8_to_char(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  char** drain_pp,
                                                  const char* DrainEnd)
{
    const uint8_t* source_iterator;
    char* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::boeck:: utf8_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<char>
utf8_to_char(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    char drain[4 + 1];
    char* drain_iterator = 0;
    std::basic_string<char> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::boeck:: utf8_to_char_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((char*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}




inline void
utf8_to_wchar(const uint8_t** source_pp,
                                                  const uint8_t* SourceEnd,
                                                  wchar_t** drain_pp,
                                                  const wchar_t* DrainEnd)
{
    const uint8_t* source_iterator;
    wchar_t* drain_iterator;

    ((source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 64, __PRETTY_FUNCTION__));
    ((*source_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*source_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 65, __PRETTY_FUNCTION__));
    ((drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 66, __PRETTY_FUNCTION__));
    ((*drain_pp != 0x0) ? static_cast<void> (0) : __assert_fail ("*drain_pp != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 67, __PRETTY_FUNCTION__));

    drain_iterator = *drain_pp;
    source_iterator = *source_pp;

    while( 1 + 1 == 2 ) {
        if( source_iterator == SourceEnd ) break;
        if( DrainEnd - drain_iterator < (ptrdiff_t)4 ) break;
        ::boeck:: utf8_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > *source_pp) ? static_cast<void> (0) : __assert_fail ("source_iterator > *source_pp", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 76, __PRETTY_FUNCTION__));
        ((source_iterator <= SourceEnd) ? static_cast<void> (0) : __assert_fail ("source_iterator <= SourceEnd", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 77, __PRETTY_FUNCTION__));
    }

    *drain_pp = drain_iterator;
    *source_pp = source_iterator;
}


inline std::basic_string<wchar_t>
utf8_to_wchar(const std::basic_string<uint8_t>& Source)
{
    const uint8_t* source_iterator = (uint8_t*)Source.c_str();
    const uint8_t* source_end = source_iterator + Source.length();
    wchar_t drain[4 + 1];
    wchar_t* drain_iterator = 0;
    std::basic_string<wchar_t> result;

    while( source_iterator != source_end ) {
        drain_iterator = drain;
        ::boeck:: utf8_to_wchar_character(&source_iterator, &drain_iterator);
        ((source_iterator > (uint8_t*)Source.c_str()) ? static_cast<void> (0) : __assert_fail ("source_iterator > (uint8_t*)Source.c_str()", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 97, __PRETTY_FUNCTION__));
        ((source_iterator <= source_end) ? static_cast<void> (0) : __assert_fail ("source_iterator <= source_end", "/home/fschaef/prj/quex/trunk/quex/code_base/converter_helper/generator/string-converter.gi", 98, __PRETTY_FUNCTION__));
        result.append((wchar_t*)drain, (size_t)(drain_iterator - drain));
    }
    return result;
}

}
namespace boeck {
extern uint8_t Lexer_LexemeNullObject;
}


namespace boeck {


inline
Token::Token()
{



}

inline
Token::Token(const Token& Other)
{
   Token_copy(this, &Other);



}

inline
Token::~Token()
{



}

inline void
Token_construct(Token* __this)
{

    new ((void*)__this) Token;
}

inline void
Token_destruct(Token* __this)
{
    __this->Token::~Token();
}

inline void
Token_copy(Token* __this, const Token* __That)
{


    (void)__this;
    (void)__That;

        (*__this)._id = (*__That)._id;
        (*__this).text = (*__That).text;
        (*__this).number = (*__That).number;


        (*__this)._line_n = (*__That)._line_n;
        (*__this)._column_n = (*__That)._column_n;





   ((__this->_id == __That->_id) ? static_cast<void> (0) : __assert_fail ("__this->_id == __That->_id", "boeck_Lexer-token", 285, __PRETTY_FUNCTION__));


    ((__this->_line_n == __That->_line_n) ? static_cast<void> (0) : __assert_fail ("__this->_line_n == __That->_line_n", "boeck_Lexer-token", 288, __PRETTY_FUNCTION__));
    ((__this->_column_n == __That->_column_n) ? static_cast<void> (0) : __assert_fail ("__this->_column_n == __That->_column_n", "boeck_Lexer-token", 289, __PRETTY_FUNCTION__));


}

inline bool
Token_take_text(Token* __this,
                           ::boeck::Lexer* __analyzer,
                           const uint8_t* Begin,
                           const uint8_t* End)
{


    (void)__this;
    (void)__analyzer;
        (*__this).text.assign(Begin, End-Begin);
        return false;



}
}

const uint32_t TKN_ADVERB____ = ((uint32_t)10000);
const uint32_t TKN_ARTICLE___ = ((uint32_t)10001);
const uint32_t TKN_DEDENT = ((uint32_t)3);
const uint32_t TKN_FILL_WORD_ = ((uint32_t)10002);
const uint32_t TKN_INDENT = ((uint32_t)2);
const uint32_t TKN_MARK______ = ((uint32_t)10003);
const uint32_t TKN_ME________ = ((uint32_t)10004);
const uint32_t TKN_MY_BROTHER = ((uint32_t)10005);
const uint32_t TKN_NEGATION__ = ((uint32_t)10006);
const uint32_t TKN_NODENT = ((uint32_t)4);
const uint32_t TKN_OK = ((uint32_t)10007);
const uint32_t TKN_PREDICATE_ = ((uint32_t)10008);
const uint32_t TKN_SCALLYWAG_ = ((uint32_t)10009);
const uint32_t TKN_SUBJECT___ = ((uint32_t)10010);
const uint32_t TKN_TERMINATION = ((uint32_t)0);
const uint32_t TKN_UKNOWN____ = ((uint32_t)10011);
const uint32_t TKN_UNINITIALIZED = ((uint32_t)1);
const uint32_t TKN_VERB______ = ((uint32_t)10012);


namespace boeck {
extern const char* Token_map_id_to_name(const uint32_t TokenID);
}

namespace boeck {

enum {
    Lexer_ModeID_ANGRY = 0,
    Lexer_ModeID_NORMAL = 1
};

        extern Lexer_Mode Lexer_ANGRY;
        extern Lexer_Mode Lexer_NORMAL;


extern uint32_t Lexer_ANGRY_analyzer_function(::boeck::Lexer*);
extern void Lexer_ANGRY_on_entry(::boeck::Lexer*, const Lexer_Mode*);

extern bool Lexer_ANGRY_has_base(const Lexer_Mode*);
extern bool Lexer_ANGRY_has_entry_from(const Lexer_Mode*);
extern bool Lexer_ANGRY_has_exit_to(const Lexer_Mode*);

extern uint32_t Lexer_NORMAL_analyzer_function(::boeck::Lexer*);

extern bool Lexer_NORMAL_has_base(const Lexer_Mode*);
extern bool Lexer_NORMAL_has_entry_from(const Lexer_Mode*);
extern bool Lexer_NORMAL_has_exit_to(const Lexer_Mode*);




typedef struct Lexer_Memento_tag {




        Lexer_Buffer buffer;

        struct Lexer_Mode_tag* __current_mode_p;
        Lexer_AnalyzerFunctionP current_analyzer_function;



        Lexer_AnalyzerFunctionP DEBUG_analyzer_function_at_entry;



        Lexer_Counter counter;



        Lexer_Accumulator accumulator;







        struct Lexer_Memento_tag* _parent_memento;


        FILE* __file_handle_allocated_by_constructor;

    Lexer_Memento_tag() {}
    ~Lexer_Memento_tag() {}




} Lexer_Memento;

}


namespace boeck {

class Lexer {
public:
        ::boeck::Token* token;

            ::boeck::Token __memory_token;




        Lexer_Buffer buffer;







        Lexer_AnalyzerFunctionP DEBUG_analyzer_function_at_entry;





        Lexer_AnalyzerFunctionP current_analyzer_function;
        struct Lexer_Mode_tag* __current_mode_p;







        struct Lexer_Mode_tag* mode_db[(2)];

        struct {
            struct Lexer_Mode_tag* (begin[(size_t)8]);
            struct Lexer_Mode_tag** end;
            struct Lexer_Mode_tag** memory_end;
        } _mode_stack;
        Lexer_Counter counter;
        Lexer_Accumulator accumulator;
        struct Lexer_Memento_tag* _parent_memento;
        FILE* __file_handle_allocated_by_constructor;

                   Lexer(const Lexer&);
public:
    typedef ::boeck::Token token_type;
    typedef uint32_t token_id_type;
    typedef uint8_t char_type;

    Lexer(uint8_t* BufferMemoryBegin, size_t BufferMemorySize,
          uint8_t* BufferEndOfContentP = 0x0,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);
    Lexer(const std::string& Filename,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);
    Lexer(std::istream* p_input_stream,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);

    Lexer(std::wistream* p_input_stream,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);

    Lexer(std::FILE* input_fh,
          const char* CharacterEncodingName = 0x0,
          bool ByteOrderReversionF = false);







    virtual ~Lexer();


    void* buffer_fill_region_append(void* ContentBegin,
                                                    void* ContentEnd);
    void* buffer_fill_region_append_conversion(void* ContentBegin,
                                                               void* ContentEnd);
    void* buffer_fill_region_append_conversion_direct(void* ContentBegin,
                                                                      void* ContentEnd);
    void buffer_fill_region_prepare();
    uint8_t* buffer_fill_region_begin();
    uint8_t* buffer_fill_region_end();
    size_t buffer_fill_region_size();
    void buffer_fill_region_finish(const size_t LoadedN);
    void buffer_conversion_fill_region_prepare();
    uint8_t* buffer_conversion_fill_region_begin();
    uint8_t* buffer_conversion_fill_region_end();
    size_t buffer_conversion_fill_region_size();
    void buffer_conversion_fill_region_finish(const size_t ByteN);
    uint8_t* buffer_lexeme_start_pointer_get();
    void buffer_input_pointer_set(uint8_t*);


    bool byte_order_reversion();
    void byte_order_reversion_set(bool Value);
    uint32_t receive();
    ::boeck::Token* token_p();
    Lexer_Mode& mode();
    int mode_id() const;
    const char* mode_name() const;


    void set_mode_brutally(const int LexerMode);
    void set_mode_brutally(const Lexer_Mode& Mode);

    void operator<<(const int MODE_ID);
    void operator<<( Lexer_Mode& Mode);

    void pop_mode();
    void pop_drop_mode();
    void push_mode(Lexer_Mode& new_mode);

    void enter_mode( Lexer_Mode& TargetMode);


    Lexer_Mode& map_mode_id_to_mode(const int ModeID);
    int map_mode_to_mode_id(const Lexer_Mode& Mode) const;


    void send(const uint32_t TokenID)
    { (void)TokenID; do { throw std::runtime_error("Member functions .send()" " has been deprecated\n" "Please, use " "macros: self_send*()" "."); } while(0); }


    size_t line_number() const { return line_number_at_begin(); }
    size_t line_number_at_begin() const { return counter._line_number_at_begin; }
    size_t line_number_at_end() const { return counter._line_number_at_end; }

    void line_number_set(size_t Y) { counter._line_number_at_end = Y; }


    size_t column_number() const { return column_number_at_begin(); }
    size_t column_number_at_begin() const { return counter._column_number_at_begin; }
    size_t column_number_at_end() const { return counter._column_number_at_end; }

    void column_number_set(size_t X) { counter._column_number_at_end = X; }






    const char* version() const;


    size_t tell();
    void seek(const size_t);
    void seek_forward(const size_t);
    void seek_backward(const size_t);

    void undo();
    void undo(size_t DeltaN_Backward);

    void move_forward(const size_t) { do { throw std::runtime_error("'move_forward()' has been renamed to 'seek_forward()'."); } while(0); }
    void move_backward(const size_t){ do { throw std::runtime_error("'move_backward()' has been renamed to 'seek_backward()'."); } while(0); }

public:

    void set_callback_on_buffer_content_change(void (*callback)(uint8_t*,
                                                                       uint8_t*));

    template <class InputHandleT> void reset(InputHandleT* input_handle,
                                             const char* CharacterEncodingName = 0x0);
    void reset(const char* CharacterEncodingName = 0x0)
    { reset<void>((void*)0x0, CharacterEncodingName); }

    uint8_t* reset_buffer(uint8_t* BufferMemoryBegin,
                                                    size_t BufferMemorySize,
                                                    uint8_t* BufferEndOfContentP,
                                                    const char* CharacterEncodingName = 0x0);


public:
    template<class InputHandleT> void include_push(uint8_t* InputName,
                                                    const Lexer_Mode* Mode = 0x0,
                                                    const char* IANA_CodingName = 0x0);
    template<class InputHandleT> void include_push(InputHandleT* sh,
                                                    const Lexer_Mode* Mode = 0x0,
                                                    const char* IANA_CodingName = 0x0);
    bool include_pop();

protected:
    void include_stack_delete();

private:


public:
    void print_this();

private:

    template <class InputHandleT> inline friend void
    Lexer_constructor_core(::boeck::Lexer* me,
                                InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                bool ByteOrderReversionF,
                                uint8_t* BufferMemory,
                                size_t BufferMemorySize);

    template<class InputHandleT> friend Lexer_Memento*
    Lexer_memento_pack(::boeck::Lexer*, uint8_t*,
                            InputHandleT**);
    friend void
    Lexer_memento_unpack(::boeck::Lexer*, Lexer_Memento*);

    template<class InputHandleT> friend void
    Lexer_reset(::boeck::Lexer*, InputHandleT*, const char*);


    friend uint32_t Lexer_ANGRY_analyzer_function(::boeck::Lexer*);
    friend void Lexer_ANGRY_on_entry(::boeck::Lexer*, const Lexer_Mode*);

    friend bool Lexer_ANGRY_has_base(const Lexer_Mode*);
    friend bool Lexer_ANGRY_has_entry_from(const Lexer_Mode*);
    friend bool Lexer_ANGRY_has_exit_to(const Lexer_Mode*);

    friend uint32_t Lexer_NORMAL_analyzer_function(::boeck::Lexer*);

    friend bool Lexer_NORMAL_has_base(const Lexer_Mode*);
    friend bool Lexer_NORMAL_has_entry_from(const Lexer_Mode*);
    friend bool Lexer_NORMAL_has_exit_to(const Lexer_Mode*);




public:






public:

    void get_token()
    { do { throw std::runtime_error("Member functions .get_token()" " has been deprecated\n" "Please, use " ".receive(...)" "."); } while(0); }
    void get_token(::boeck::Token* result_p) { (void)result_p; get_token(); }
    void get_token(::boeck::Token** result_pp) { (void)result_pp; get_token(); }
};

}


namespace boeck {


template <class InputHandleT> inline

void
Lexer_constructor_core(::boeck::Lexer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            bool ByteOrderReversionF,
                            uint8_t* BufferMemory,
                            size_t BufferMemorySize,
                            uint8_t* BufferEndOfFileP)
{
    ((Lexer_ModeID_ANGRY < 2) ? static_cast<void> (0) : __assert_fail ("Lexer_ModeID_ANGRY < 2", "boeck_Lexer", 382, __PRETTY_FUNCTION__));
    ((Lexer_ModeID_NORMAL < 2) ? static_cast<void> (0) : __assert_fail ("Lexer_ModeID_NORMAL < 2", "boeck_Lexer", 383, __PRETTY_FUNCTION__));

     Lexer_ANGRY.id = Lexer_ModeID_ANGRY;
     Lexer_ANGRY.name = "ANGRY";
     Lexer_ANGRY.analyzer_function = Lexer_ANGRY_analyzer_function;




     Lexer_ANGRY.on_entry = Lexer_ANGRY_on_entry;
     Lexer_ANGRY.on_exit = Lexer_Mode_on_entry_exit_null_function;

     Lexer_ANGRY.has_base = Lexer_ANGRY_has_base;
     Lexer_ANGRY.has_entry_from = Lexer_ANGRY_has_entry_from;
     Lexer_ANGRY.has_exit_to = Lexer_ANGRY_has_exit_to;


     Lexer_NORMAL.id = Lexer_ModeID_NORMAL;
     Lexer_NORMAL.name = "NORMAL";
     Lexer_NORMAL.analyzer_function = Lexer_NORMAL_analyzer_function;




     Lexer_NORMAL.on_entry = Lexer_Mode_on_entry_exit_null_function;
     Lexer_NORMAL.on_exit = Lexer_Mode_on_entry_exit_null_function;

     Lexer_NORMAL.has_base = Lexer_NORMAL_has_base;
     Lexer_NORMAL.has_entry_from = Lexer_NORMAL_has_entry_from;
     Lexer_NORMAL.has_exit_to = Lexer_NORMAL_has_exit_to;

        me->mode_db[Lexer_ModeID_ANGRY] = &(Lexer_ANGRY);
        me->mode_db[Lexer_ModeID_NORMAL] = &(Lexer_NORMAL);


    Lexer_construct_basic(me, input_handle,
                               BufferMemory, BufferMemorySize, BufferEndOfFileP,
                               CharacterEncodingName,
                               ((size_t)0),
                               ByteOrderReversionF);

    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));






}





template <class InputHandleT> inline

Lexer_Memento*
Lexer_memento_pack(::boeck::Lexer* me,
                        uint8_t* InputName,
                        InputHandleT** input_handle)
{

    Lexer_Memento* memento = Lexer_MemoryManager_Memento_allocate();

    (void)InputName;
    (void)input_handle;




    new ((void*)memento) Lexer_Memento;


    memento->_parent_memento = (*me)._parent_memento;
    memento->buffer = (*me).buffer;
    memento->__current_mode_p = (*me).__current_mode_p;
    memento->current_analyzer_function = (*me).current_analyzer_function;


    memento->DEBUG_analyzer_function_at_entry = (*me).DEBUG_analyzer_function_at_entry;

    memento->counter = (*me).counter;

    memento->accumulator = (*me).accumulator;

    memento->__file_handle_allocated_by_constructor = (*me).__file_handle_allocated_by_constructor;
    return memento;

}


inline

void
Lexer_memento_unpack(::boeck::Lexer* me,
                          Lexer_Memento* memento)
{

    (*me)._parent_memento = memento->_parent_memento;
    (*me).buffer = memento->buffer;
    (*me).__current_mode_p = memento->__current_mode_p;
    (*me).current_analyzer_function = memento->current_analyzer_function;


    (*me).DEBUG_analyzer_function_at_entry = memento->DEBUG_analyzer_function_at_entry;

    (*me).counter = memento->counter;

    (*me).accumulator = memento->accumulator;

    (*me).__file_handle_allocated_by_constructor = memento->__file_handle_allocated_by_constructor;
    memento->~Lexer_Memento_tag();


    Lexer_MemoryManager_Memento_free(memento);

}


}




namespace boeck {

inline size_t
Lexer_strlen(const uint8_t* Str)
{
    const uint8_t* iterator = Str;
    while( *iterator != 0 ) ++iterator;
    return (size_t)(iterator - Str);
}

inline size_t
Lexer_strcmp(const uint8_t* it0,
                  const uint8_t* it1)
{
    for(; *it0 == *it1; ++it0, ++it1) {


        if( *it0 == 0 ) return 0;
    }
    return (size_t)(*it0) - (size_t)(*it1);
}

}

namespace boeck {

inline uint8_t*
Lexer_access_Lexeme(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( *(buffer->_input_p) != (uint8_t)0 ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Tried to access lexeme while terminating zero was not set.\n" "This happens, for example, if navigation commands (undo, seek,\n" "seek_forward, or seek_backward) are used **before** accessing\n" "the lexeme via 'Lexeme' or 'LexemeBegin'.\n"); } while(0); };
    return buffer->_lexeme_start_p;
}

inline uint8_t*
Lexer_access_LexemeBegin(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return buffer->_lexeme_start_p;
}

inline size_t
Lexer_access_LexemeL(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return (size_t)(buffer->_input_p - buffer->_lexeme_start_p);
}

inline uint8_t*
Lexer_access_LexemeEnd(const char* FileName, size_t LineN, Lexer_Buffer* buffer)
{
    if( buffer->_input_p < buffer->_memory._front ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); } else if( buffer->_input_p > buffer->_memory._back ) { std::printf("%s:%i:\n", FileName, (int)LineN); do { throw std::runtime_error("Lexeme out of buffer bounds.\n"); } while(0); };
    return buffer->_input_p;
}

}




namespace boeck {
    inline uint32_t
    Lexer_receive(::boeck::Lexer* me)
    {
        register uint32_t __self_result_token_id = (uint32_t)-1;
        ((me->token != 0x0) ? static_cast<void> (0) : __assert_fail ("me->token != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/token-receiving.i", 103, __PRETTY_FUNCTION__));
        me->token->_id = ((uint32_t)TKN_UNINITIALIZED);
        do {
            __self_result_token_id = me->current_analyzer_function(me);



            if( __self_result_token_id != me->token->_id ) {
                __self_result_token_id = me->token->_id;
            }

        } while( __self_result_token_id == ((uint32_t)TKN_UNINITIALIZED) );
        return __self_result_token_id;
    }







       inline uint32_t Lexer::receive()
       { return Lexer_receive(this); }





}
namespace boeck {

    inline Lexer_Mode*
    Lexer_get_mode(::boeck::Lexer* me)
    { return me->__current_mode_p; }

    inline int
    Lexer_get_mode_id(const ::boeck::Lexer* me)
    { return me->__current_mode_p->id; }

    inline const char*
    Lexer_get_mode_name(const ::boeck::Lexer* me)
    { return me->__current_mode_p->name; }

    inline void
    Lexer_set_mode_brutally(::boeck::Lexer* me, Lexer_Mode* ModeP)
    {
        me->__current_mode_p = ModeP;
        me->current_analyzer_function = ModeP->analyzer_function;
    }

    inline void
    Lexer_set_mode_brutally_by_id(::boeck::Lexer* me, const int ModeID)
    { Lexer_set_mode_brutally(me, me->mode_db[ModeID]); }

    inline void
    Lexer_enter_mode(::boeck::Lexer* me, Lexer_Mode* TargetMode)
    {

        Lexer_Mode* SourceMode = me->__current_mode_p;






        Lexer_set_mode_brutally(me, TargetMode);


        TargetMode->on_entry(me, SourceMode);

    }

    inline Lexer_Mode*
    Lexer_map_mode_id_to_mode(::boeck::Lexer* me, const int ModeID)
    {
        ((ModeID >= 0) ? static_cast<void> (0) : __assert_fail ("ModeID >= 0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 65, __PRETTY_FUNCTION__));
        ((ModeID < (2)) ? static_cast<void> (0) : __assert_fail ("ModeID < (2)", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 66, __PRETTY_FUNCTION__));
        return me->mode_db[ModeID];
    }

    inline int
    Lexer_map_mode_to_mode_id(const ::boeck::Lexer* me, const Lexer_Mode* Mode)
    { (void)me; return Mode->id; }

    inline void
    Lexer_pop_mode(::boeck::Lexer* me)
    {
        ((me->_mode_stack.end != me->_mode_stack.begin) ? static_cast<void> (0) : __assert_fail ("me->_mode_stack.end != me->_mode_stack.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 77, __PRETTY_FUNCTION__));
        --(me->_mode_stack.end);
        Lexer_enter_mode(me, *me->_mode_stack.end);
    }

    inline void
    Lexer_pop_drop_mode(::boeck::Lexer* me)
    {
        ((me->_mode_stack.end != me->_mode_stack.begin) ? static_cast<void> (0) : __assert_fail ("me->_mode_stack.end != me->_mode_stack.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/mode-handling.i", 85, __PRETTY_FUNCTION__));
        --(me->_mode_stack.end);

    }

    inline void
    Lexer_push_mode(::boeck::Lexer* me, Lexer_Mode* new_mode)
    {

        if( me->_mode_stack.end == me->_mode_stack.memory_end )
            do { throw std::runtime_error("Error: Mode stack overflow. Adapt size of mode stack via the macro\n" "Error: QUEX_SETTING_MODE_STACK_SIZE, or review mode transitions.\n" "Error: I.e. check that for every GOSUB (push), there is a correspondent\n" "Error: GOUP (pop)."); } while(0);

        *me->_mode_stack.end = me->__current_mode_p;
        ++(me->_mode_stack.end);
        Lexer_enter_mode(me, new_mode);
    }


    inline Lexer_Mode&
    Lexer::mode()
    { return *Lexer_get_mode(this); }

    inline int
    Lexer::mode_id() const
    { return Lexer_get_mode_id(this); }

    inline const char*
    Lexer::mode_name() const
    { return Lexer_get_mode_name(this); }

    inline void
    Lexer::set_mode_brutally(const int ModeID)
    { Lexer_set_mode_brutally_by_id(this, ModeID); }

    inline void
    Lexer::set_mode_brutally(const Lexer_Mode& TheMode)
    { Lexer_set_mode_brutally(this, ((Lexer_Mode*)&TheMode)); }

    inline void
    Lexer::enter_mode( Lexer_Mode& TargetMode)
    { Lexer_enter_mode(this, &TargetMode); }

    inline Lexer_Mode&
    Lexer::map_mode_id_to_mode(const int ModeID)
    { return *(Lexer_map_mode_id_to_mode(this, ModeID)); }

    inline int
    Lexer::map_mode_to_mode_id(const Lexer_Mode& TheMode) const
    { return Lexer_map_mode_to_mode_id(this, &TheMode); }

    inline void
    Lexer::operator<<(const int ModeID)
    { enter_mode(*(Lexer_map_mode_id_to_mode(this, ModeID))); }

    inline void
    Lexer::operator<<( Lexer_Mode& TheMode)
    { enter_mode(TheMode); }

    inline void
    Lexer::pop_mode()
    { Lexer_pop_mode(this); }

    inline void
    Lexer::pop_drop_mode()
    { Lexer_pop_drop_mode(this); }

    inline void
    Lexer::push_mode(Lexer_Mode& new_mode)
    { Lexer_push_mode(this, &new_mode); }



}






namespace boeck {





    inline void
    QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(Lexer_Buffer* B)
    {
        (((B) != 0x0) ? static_cast<void> (0) : __assert_fail ("(B) != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 25, __PRETTY_FUNCTION__));
        if( (*B)._memory._front != 0x0 || (*B)._memory._back != 0x0 ) {
            (((*B)._memory._front < (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._front < (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 27, __PRETTY_FUNCTION__));
            ((*((*B)._memory._front) == ((uint8_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*((*B)._memory._front) == ((uint8_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 28, __PRETTY_FUNCTION__));
            (((*B)._input_p >= (*B)._memory._front) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p >= (*B)._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 29, __PRETTY_FUNCTION__));
            (((*B)._lexeme_start_p >= (*B)._memory._front) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p >= (*B)._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 30, __PRETTY_FUNCTION__));

            if( (*B)._memory._end_of_file_p == 0x0 ) {
                (((*B)._input_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 33, __PRETTY_FUNCTION__));
                (((*B)._lexeme_start_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 34, __PRETTY_FUNCTION__));
            } else {
                (((*B)._input_p <= (*B)._memory._end_of_file_p) ? static_cast<void> (0) : __assert_fail ("(*B)._input_p <= (*B)._memory._end_of_file_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 36, __PRETTY_FUNCTION__));
                (((*B)._lexeme_start_p <= (*B)._memory._end_of_file_p) ? static_cast<void> (0) : __assert_fail ("(*B)._lexeme_start_p <= (*B)._memory._end_of_file_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 37, __PRETTY_FUNCTION__));

                (((*B)._memory._end_of_file_p >= (*B)._memory._front + 1) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._end_of_file_p >= (*B)._memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 39, __PRETTY_FUNCTION__));
                (((*B)._memory._end_of_file_p <= (*B)._memory._back) ? static_cast<void> (0) : __assert_fail ("(*B)._memory._end_of_file_p <= (*B)._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 40, __PRETTY_FUNCTION__));
            }
            (((*B)._content_character_index_begin <= (*B)._content_character_index_end) ? static_cast<void> (0) : __assert_fail ("(*B)._content_character_index_begin <= (*B)._content_character_index_end",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts"
            ,
 43
            , __PRETTY_FUNCTION__))
                                                                   ;
            if( ! ( (*B)._content_character_index_end == (size_t)0
                      && (*B)._content_character_index_begin == (size_t)0 ) ) {
                (((size_t)( (*B)._content_character_index_end - (*B)._content_character_index_begin) == (size_t)( Lexer_Buffer_text_end(B) - Lexer_Buffer_content_front(B))) ? static_cast<void> (0) : __assert_fail ("(size_t)( (*B)._content_character_index_end - (*B)._content_character_index_begin) == (size_t)( Lexer_Buffer_text_end(B) - Lexer_Buffer_content_front(B))",


 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts"
                ,


 49
                , __PRETTY_FUNCTION__))


                                                                                     ;
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_CONSISTENCY(Lexer_Buffer* B)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(B);





        if( (*B)._memory._front != 0 || (*B)._memory._back != 0x0 ) {
            ((*((*B)._memory._back) == ((uint8_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*((*B)._memory._back) == ((uint8_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 64, __PRETTY_FUNCTION__));
            if( (*B)._memory._end_of_file_p != 0x0 ) {
                ((*(*B)._memory._end_of_file_p == ((uint8_t)0x0)) ? static_cast<void> (0) : __assert_fail ("*(*B)._memory._end_of_file_p == ((uint8_t)0x0)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 66, __PRETTY_FUNCTION__));
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(uint8_t* Begin,
                                            uint8_t* End)
    {
        uint8_t* iterator = 0x0;
        ((Begin <= End) ? static_cast<void> (0) : __assert_fail ("Begin <= End", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/asserts", 76, __PRETTY_FUNCTION__));

        for(iterator = Begin; iterator != End; ++iterator) {
            if( *iterator != ((uint8_t)0x0) ) continue;

            if( iterator == Begin ) {
                do { throw std::runtime_error("Buffer limit code character appeared as first character in buffer.\n" "This is most probably a load failure.\n"); } while(0)
                                                                          ;
            } else {
                do { throw std::runtime_error("Buffer limit code character appeared as normal text content.\n"); } while(0);
            }
        }
    }

    inline void
    QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(const Lexer_Buffer* buffer)
    {
        uint8_t* End = buffer->_memory._back;

        if( buffer->_memory._front == 0x0 && buffer->_memory._back == 0x0 ) return;
        if( buffer->_memory._end_of_file_p != 0x0 ) End = buffer->_memory._end_of_file_p;
        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(buffer->_memory._front + 1, End);
    }

}


namespace boeck {

    inline size_t
    Lexer_BufferFillerUser_Plain_insert(Lexer_BufferFiller* me,
                                             uint8_t** insertion_p,
                                             uint8_t* BufferEnd,
                                             void* ContentBegin,
                                             void* ContentEnd)
    {
        size_t CopiedByteN = 0;

        (void)me;

        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE((uint8_t*)ContentBegin, (uint8_t*)ContentEnd);
        CopiedByteN = Lexer_MemoryManager_insert((uint8_t*)*insertion_p,
                                                      (uint8_t*)BufferEnd,
                                                      (uint8_t*)ContentBegin,
                                                      (uint8_t*)ContentEnd);

        *insertion_p += (CopiedByteN / sizeof(uint8_t));

        return CopiedByteN;
    }


    inline void*
    Lexer_buffer_fill_region_append_core(::boeck::Lexer* me,
                                              void* ContentBegin,
                                              void* ContentEnd,
                                              size_t (*insert)(Lexer_BufferFiller* me,
                                                               uint8_t** insertion_p,
                                                               uint8_t* BufferEnd,
                                                               void* ContentBegin,
                                                               void* ContentEnd))




    {
        uint8_t* insertion_p = 0x0;
        size_t CopiedByteN = 0;


        ((me->buffer._content_character_index_begin == 0) ? static_cast<void> (0) : __assert_fail ("me->buffer._content_character_index_begin == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 53, __PRETTY_FUNCTION__));
        ((me->buffer._memory._end_of_file_p != 0x0) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 54, __PRETTY_FUNCTION__));
        ((ContentEnd > ContentBegin) ? static_cast<void> (0) : __assert_fail ("ContentEnd > ContentBegin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 55, __PRETTY_FUNCTION__));
        QUEX_BUFFER_ASSERT_CONSISTENCY(&me->buffer);


        Lexer_Buffer_move_away_passed_content(&me->buffer);


        insertion_p = me->buffer._memory._end_of_file_p;

        CopiedByteN = insert(me->buffer.filler, &insertion_p,
                             me->buffer._memory._back + 1,
                             ContentBegin, ContentEnd);


        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p, insertion_p);


        Lexer_Buffer_end_of_file_set(&me->buffer, insertion_p);





        QUEX_BUFFER_ASSERT_CONSISTENCY(&me->buffer);
        return (uint8_t*)ContentBegin + CopiedByteN;
    }

    inline void*
    Lexer_buffer_fill_region_append(::boeck::Lexer* me,
                                         void* ContentBegin,
                                         void* ContentEnd)
    {
        return Lexer_buffer_fill_region_append_core(me, ContentBegin, ContentEnd,
                                                         Lexer_BufferFillerUser_Plain_insert);
    }

    inline void
    Lexer_buffer_fill_region_prepare(::boeck::Lexer* me)
    {

        Lexer_Buffer_move_away_passed_content(&me->buffer);
    }

    inline uint8_t*
    Lexer_buffer_fill_region_begin(::boeck::Lexer* me)
    {
        return Lexer_Buffer_text_end(&me->buffer);
    }

    inline uint8_t*
    Lexer_buffer_fill_region_end(::boeck::Lexer* me)
    {
        return Lexer_Buffer_content_back(&me->buffer) + 1;
    }

    inline size_t
    Lexer_buffer_fill_region_size(::boeck::Lexer* me)
    {
        ((Lexer_buffer_fill_region_end(me) >= Lexer_buffer_fill_region_begin(me)) ? static_cast<void> (0) : __assert_fail ("Lexer_buffer_fill_region_end(me) >= Lexer_buffer_fill_region_begin(me)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i"
        ,
 115
        , __PRETTY_FUNCTION__))
                                                                 ;

        return (size_t)( Lexer_buffer_fill_region_end(me)
                        - Lexer_buffer_fill_region_begin(me));
    }

    inline void
    Lexer_buffer_fill_region_finish(::boeck::Lexer* me,
                                         const size_t CharacterN)
    {
        ((me->buffer._memory._end_of_file_p != 0x0) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 125, __PRETTY_FUNCTION__));
        ((me->buffer._memory._end_of_file_p + CharacterN <= me->buffer._memory._back) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p + CharacterN <= me->buffer._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/buffer-access.i", 126, __PRETTY_FUNCTION__));



        if( me->buffer._byte_order_reversion_active_f )
            Lexer_Buffer_reverse_byte_order(me->buffer._memory._end_of_file_p,
                                                 me->buffer._memory._end_of_file_p + CharacterN);

        QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(me->buffer._memory._end_of_file_p,
                                                me->buffer._memory._end_of_file_p + CharacterN);


        Lexer_Buffer_end_of_file_set(&me->buffer,
                                          me->buffer._memory._end_of_file_p + CharacterN);
    }

    inline uint8_t*
    Lexer_buffer_lexeme_start_pointer_get(::boeck::Lexer* me)
    { return me->buffer._lexeme_start_p; }

    inline void
    Lexer_buffer_input_pointer_set(::boeck::Lexer* me, uint8_t* Adr)
    { me->buffer._input_p = Adr; }
    inline void*
    Lexer::buffer_fill_region_append(void* ContentBegin, void* ContentEnd)
    { return Lexer_buffer_fill_region_append(this, ContentBegin, ContentEnd); }

    inline void
    Lexer::buffer_fill_region_prepare()
    { Lexer_buffer_fill_region_prepare(this); }

    inline uint8_t*
    Lexer::buffer_fill_region_begin()
    { return Lexer_buffer_fill_region_begin(this); }

    inline uint8_t*
    Lexer::buffer_fill_region_end()
    { return Lexer_buffer_fill_region_end(this); }

    inline size_t
    Lexer::buffer_fill_region_size()
    { return Lexer_buffer_fill_region_size(this); }

    inline void
    Lexer::buffer_fill_region_finish(const size_t CharacterN)
    { Lexer_buffer_fill_region_finish(this, CharacterN); }

    inline uint8_t*
    Lexer::buffer_lexeme_start_pointer_get()
    { return Lexer_buffer_lexeme_start_pointer_get(this); }

    inline void
    Lexer::buffer_input_pointer_set(uint8_t* Adr)
    { Lexer_buffer_input_pointer_set(this, Adr); }
}

namespace boeck {

inline void
Lexer_set_callback_on_buffer_content_change(::boeck::Lexer* me,
                                                 void (*callback)(uint8_t*,
                                                                                uint8_t*))
{ me->buffer.on_buffer_content_change = callback; }

inline ::boeck::Token*
Lexer_token_p(::boeck::Lexer* me)
{

    return ((*(Lexer*)me).token);

}
inline const char*
Lexer_version(::boeck::Lexer* me)
{
    (void)me;
    return "QUEX_TYPE_ANALYZER"
           ": Version " "0.0.0-pre-release"
           ". Date " "Thu Mar 29 07:48:48 2012"
           "Generated by Quex " "0.62.2" ".";
}

inline bool
Lexer_byte_order_reversion(::boeck::Lexer* me)
{ return me->buffer._byte_order_reversion_active_f; }

inline void
Lexer_byte_order_reversion_set(::boeck::Lexer* me, bool Value)
{ me->buffer._byte_order_reversion_active_f = Value; }


inline void
Lexer_print_this(::boeck::Lexer* me)
{
    Lexer_Mode** iterator = 0x0;

    std::printf("   CurrentMode = %s;\n",
                      me->__current_mode_p == 0x0 ? "0x0" : me->__current_mode_p->name);

    Lexer_Buffer_print_this(&me->buffer);


    Lexer_Accumulator_print_this(&me->accumulator);


    Lexer_Counter_print_this(&me->counter);





    std::printf("   Mode Stack (%i/%i) = [",
                      (int)(me->_mode_stack.end - me->_mode_stack.begin),
                      (int)(me->_mode_stack.memory_end - me->_mode_stack.begin));
    for(iterator=me->_mode_stack.end-1; iterator >= me->_mode_stack.begin; --iterator)
        std::printf("%s, ", (*iterator)->name);

    std::printf("]\n");
    std::printf("   ByteOrderInversion = %s;\n",
                      Lexer_byte_order_reversion(me) ? "true" : "false");
}


inline void
Lexer::set_callback_on_buffer_content_change(void (*callback)(uint8_t*,
                                                            uint8_t*))
{ Lexer_set_callback_on_buffer_content_change(this, callback); }

inline ::boeck::Token*
Lexer::token_p()
{ return Lexer_token_p(this); }
inline const char*
Lexer::version() const
{ return Lexer_version((::boeck::Lexer*)this); }

inline void
Lexer::print_this()
{ Lexer_print_this(this); }

inline bool
Lexer::byte_order_reversion()
{ return Lexer_byte_order_reversion(this); }

inline void
Lexer::byte_order_reversion_set(bool Value)
{ Lexer_byte_order_reversion_set(this, Value); }


}
namespace boeck {

inline size_t
Lexer_tell(::boeck::Lexer* me)
{

    return (size_t)Lexer_Buffer_tell(&me->buffer);
}

inline void
Lexer_seek(::boeck::Lexer* me, const size_t CharacterIndex)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint8_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint8_t)'\0'; };
    Lexer_Buffer_seek(&me->buffer, (ptrdiff_t)CharacterIndex);
}

inline void
Lexer_seek_forward(::boeck::Lexer* me, const size_t CharacterN)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint8_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint8_t)'\0'; };
    Lexer_Buffer_move_forward(&me->buffer, (ptrdiff_t)CharacterN);
}

inline void
Lexer_seek_backward(::boeck::Lexer* me, const size_t CharacterN)
{
    if( (&me->buffer)->_character_at_lexeme_start != (uint8_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint8_t)'\0'; };
    Lexer_Buffer_move_backward(&me->buffer, (ptrdiff_t)CharacterN);
}

inline void
Lexer_undo(::boeck::Lexer* me)
{
    me->counter._line_number_at_end = me->counter._line_number_at_begin;
    me->counter._column_number_at_end = me->counter._column_number_at_begin;

    if( (&me->buffer)->_character_at_lexeme_start != (uint8_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint8_t)'\0'; };

    me->buffer._input_p = me->buffer._lexeme_start_p;

    (&me->buffer)->_character_at_lexeme_start = *((&me->buffer)->_input_p); *((&me->buffer)->_input_p) = '\0';;
}

inline void
Lexer_undo_n(::boeck::Lexer* me, size_t DeltaN_Backward)
{
    me->counter._line_number_at_end = me->counter._line_number_at_begin;
    me->counter._column_number_at_end = me->counter._column_number_at_begin;

    if( (&me->buffer)->_character_at_lexeme_start != (uint8_t)'\0' ) { *((&me->buffer)->_input_p) = (&me->buffer)->_character_at_lexeme_start; (&me->buffer)->_character_at_lexeme_start = (uint8_t)'\0'; };

    me->buffer._input_p -= (ptrdiff_t)DeltaN_Backward;

    (&me->buffer)->_character_at_lexeme_start = *((&me->buffer)->_input_p); *((&me->buffer)->_input_p) = '\0';;

    ((me->buffer._input_p >= me->buffer._lexeme_start_p) ? static_cast<void> (0) : __assert_fail ("me->buffer._input_p >= me->buffer._lexeme_start_p", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/navigation.i", 64, __PRETTY_FUNCTION__));
}



inline size_t
Lexer::tell()
{ return Lexer_tell(this); }

inline void
Lexer::seek(const size_t CharacterIndex)
{ Lexer_seek(this, CharacterIndex); }

inline void
Lexer::seek_forward(const size_t CharacterN)
{ Lexer_seek_forward(this, CharacterN); }

inline void
Lexer::seek_backward(const size_t CharacterN)
{ Lexer_seek_backward(this, CharacterN); }

inline void
Lexer::undo()
{ return Lexer_undo(this); }

inline void
Lexer::undo(size_t DeltaN_Backward)
{ return Lexer_undo_n(this, DeltaN_Backward); }



}















namespace boeck {

    inline void Lexer_Buffer_x_show_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_brief_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_content(Lexer_Buffer*);

    inline void
    Lexer_Buffer_show_brief_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_x_show_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_content_intern(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_content(Lexer_Buffer* buffer);

    inline void
    Lexer_Buffer_show_byte_content(Lexer_Buffer* buffer, const int IndentationN);

}


namespace boeck {

    inline void Lexer_Buffer_x_show_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_brief_content(Lexer_Buffer*);
    inline void Lexer_Buffer_show_content(Lexer_Buffer*);

    inline void
    Lexer_Buffer_show_brief_content(Lexer_Buffer* buffer)
    {
        Lexer_BufferFiller* me = buffer->filler;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 25, __PRETTY_FUNCTION__));
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 26, __PRETTY_FUNCTION__));

        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        std::printf("Begin of Buffer Character Index: %i\n", (int)buffer->_content_character_index_begin);
        std::printf("End   of Buffer Character Index: %i\n", (int)me->tell_character_index(me));
        if( buffer->_memory._end_of_file_p == 0x0 )
            std::printf("_memory._memory._end_of_file_p (offset)  = <0x0>\n");
        else
            std::printf("_memory._end_of_file_p (offset)  = %08X\n",
                              (int)(buffer->_memory._end_of_file_p - buffer->_memory._front));
        std::printf("_input_p (offset)        = %08X\n", (int)(buffer->_input_p - buffer->_memory._front));
        std::printf("_lexeme_start_p (offset) = %08X\n", (int)(buffer->_lexeme_start_p - buffer->_memory._front));
        std::printf("_back (offset)           = %08X\n", (int)(buffer->_memory._back - buffer->_memory._front));
    }

    inline void
    Lexer_Buffer_x_show_content(Lexer_Buffer* buffer)
    {
        Lexer_Buffer_show_content_intern(buffer);
        Lexer_Buffer_show_brief_content(buffer);
    }

    inline uint8_t
    Lexer___Buffer_get_border_char(Lexer_Buffer* buffer, const uint8_t* C)
    {
        if ( *C != ((uint8_t)0x0) )
            return (uint8_t)'?';
        else if( buffer->_memory._end_of_file_p == C )
            return (uint8_t)']';
        else if( buffer->_content_character_index_begin == 0 && buffer->_memory._front == C )
            return (uint8_t)'[';
        else
            return (uint8_t)'|';
    }

    inline void
    Lexer_Buffer_show_content_intern(Lexer_Buffer* buffer)
    {
        size_t i = 0;
        size_t length = 0;

        uint8_t EmptyChar = (uint8_t)(-1);
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint8_t* BufferFront = buffer->_memory._front;
        uint8_t* BufferBack = buffer->_memory._back;
        uint8_t* iterator = 0x0;
        uint8_t* end_p = buffer->_memory._end_of_file_p != 0x0 ? buffer->_memory._end_of_file_p
                                         : buffer->_memory._back;

        std::printf("|%c", (int)Lexer___Buffer_get_border_char(buffer, BufferFront));
        for(iterator = ContentFront; iterator != end_p; ++iterator) {
            std::printf("%c", *iterator == EmptyChar ? (int)'~' : (int)*iterator);
        }
        std::printf("%c", (int)Lexer___Buffer_get_border_char(buffer, end_p));

        length = (buffer->_memory._end_of_file_p == 0x0) ? 0 : (size_t)(BufferBack - buffer->_memory._end_of_file_p);
        for(i=0; i < length; ++i) std::printf("|");

        std::printf("|");
    }

    inline void
    Lexer_Buffer_show_content(Lexer_Buffer* buffer)
    {




        size_t i = 0;
        char* tmp = 0;
        const size_t ContentSize = Lexer_Buffer_content_size(buffer);
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint8_t* BufferFront = buffer->_memory._front;
        uint8_t* BufferBack = buffer->_memory._back;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 101, __PRETTY_FUNCTION__));

        tmp = (char*)std::malloc(ContentSize + 4);






        for(i=2; i<ContentSize + 2 ; ++i) tmp[i] = ' ';
        tmp[ContentSize+4] = '\0';
        tmp[ContentSize+3] = '|';
        tmp[ContentSize+2] = (char)Lexer___Buffer_get_border_char(buffer, BufferBack);
        tmp[1] = (char)Lexer___Buffer_get_border_char(buffer, BufferFront);
        tmp[0] = '|';

        tmp[buffer->_input_p - ContentFront + 2] = 'C';
        if( buffer->_lexeme_start_p >= ContentFront && buffer->_lexeme_start_p <= BufferBack )
            tmp[(int)(buffer->_lexeme_start_p - ContentFront) + 2] = 'S';

        if ( buffer->_input_p == ContentFront - 2 ) {
            std::printf("%s", tmp);
            std::printf(" <out>");
        } else {
            std::printf(" ");
            if( *buffer->_input_p == ((uint8_t)0x0) )
                std::printf("BLC");
            else
                std::printf("'%c'", (char)(*buffer->_input_p));
        }

        std::printf("\n");
        Lexer_Buffer_show_content_intern(buffer);
        std::free(tmp);
    }

    inline void
    Lexer_Buffer_show_byte_content(Lexer_Buffer* buffer, const int IndentationN)
    {
        Lexer_BufferMemory* memory = &buffer->_memory;

        int i = 0, j = 0;
        uint8_t* byte_p = (uint8_t*)memory->_front;
        uint8_t* next_byte_p = (uint8_t*)memory->_front + 1;
        uint8_t* End = (uint8_t*)(memory->_back + 1);

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 147, __PRETTY_FUNCTION__));
        ((memory != 0x0) ? static_cast<void> (0) : __assert_fail ("memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 148, __PRETTY_FUNCTION__));

        for(j=0; j<IndentationN; ++j) fprintf(stdout, " ");
        for(; byte_p != End; ++byte_p, ++next_byte_p, ++i) {
            fprintf(stdout, "%02X", (int)*byte_p);
            if ( next_byte_p == (uint8_t*)buffer->_memory._end_of_file_p )
                fprintf(stdout, "[");
            else if( byte_p == (uint8_t*)buffer->_memory._end_of_file_p + sizeof(uint8_t)-1)
                fprintf(stdout, "]");
            else
                fprintf(stdout, ".");
            if( (i+1) % 0x8 == 0 ) fprintf(stdout, " ");
            if( (i+1) % 0x10 == 0 ) {
                fprintf(stdout, "\n");
                for(j=0; j<IndentationN; ++j) fprintf(stdout, " ");
            }
        }
        fprintf(stdout, "\n");
    }

    inline void
    Lexer_Buffer_show_debug_print_lines(uint8_t** iterator,
                                             uint8_t* Begin,
                                             uint8_t* TotalEnd,
                                             Lexer_Buffer* buffer)
    {
        int length = 0;
        uint8_t* end = Begin + 5 > TotalEnd ? TotalEnd : Begin + 5;

        if( Begin > *iterator ) {
            *iterator = Begin;
            std::fprintf(stderr, "                                           ...\n");
        } else if( *iterator >= end ) {
            return;
        }

        for(; *iterator < end; ++*iterator) {
            length = 0;
            std::fprintf(stderr, "   ");

            if( *iterator == buffer->_memory._front ) {
                std::fprintf(stderr, "buffer front");
                length += 12;
            }
            if( *iterator == buffer->_lexeme_start_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "lexeme start");
                length += 12;
            }
            if( *iterator == buffer->_input_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "input");
                length += 5;
            }
            if( *iterator == buffer->_memory._end_of_file_p ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "end of file");
                length += 11;
            }
            if( *iterator == buffer->_memory._back ) {
                if( length ) { std::fprintf(stderr, ", "); length += 2; }
                std::fprintf(stderr, "buffer back");
                length += 11;
            }
            if( length ) {
                for(; length < 39; ++length)
                    std::fprintf(stderr, "-");
                std::fprintf(stderr, ">");
            } else {
                std::fprintf(stderr, "                                        ");
            }


            std::fprintf(stderr, "[%04X] 0x%04X\n",
                               (int)(*iterator - buffer->_memory._front),
                               (int)(**iterator));
        }
    }

    inline void
    Lexer_Buffer_show_debug_content(Lexer_Buffer* buffer)
    {
        uint8_t* iterator = buffer->_memory._front;
        uint8_t* total_end = buffer->_memory._back + 1;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer_debug.i", 243, __PRETTY_FUNCTION__));
        std::fprintf(stderr, "_________________________________________________________________\n");
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._front, total_end, buffer);
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_lexeme_start_p - 2, total_end, buffer);
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_input_p - 2, total_end, buffer);
        if( buffer->_memory._end_of_file_p != 0x0 ) {
            Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._end_of_file_p - 4, total_end, buffer);
        }
        Lexer_Buffer_show_debug_print_lines(&iterator, buffer->_memory._back - 4, total_end, buffer);
        std::fprintf(stderr, "_________________________________________________________________\n");
    }

}



namespace boeck {

    inline void Lexer_Buffer_init(Lexer_Buffer* me,
                                             bool ByteOrderReversionF);
    inline void Lexer_Buffer_init_analyzis(Lexer_Buffer* me,
                                                      bool ByteOrderReversionF);
    inline void
    Lexer_BufferMemory_construct(Lexer_BufferMemory* me,
                                      uint8_t* Memory,
                                      const size_t Size,
                                      uint8_t* EndOfFileP);
    inline void
    Lexer_BufferMemory_init(Lexer_BufferMemory* me,
                                 uint8_t* Memory,
                                 const size_t Size,
                                 uint8_t* EndOfFileP,
                                 bool ExternalOwnerF);
    inline void Lexer_BufferMemory_destruct(Lexer_BufferMemory* me);

    template <class InputHandleT> inline void
    Lexer_Buffer_construct(Lexer_Buffer* me,
                                InputHandleT* input_handle,
                                uint8_t* InputMemory,
                                const size_t MemorySize,
                                uint8_t* EndOfFileP,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize,
                                bool ByteOrderReversionF)







    {

        if( input_handle != 0x0 ) ((InputMemory == 0x0) ? static_cast<void> (0) : __assert_fail ("InputMemory == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 53, __PRETTY_FUNCTION__));
        if( InputMemory != 0x0 ) {
            ((input_handle == 0x0) ? static_cast<void> (0) : __assert_fail ("input_handle == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 55, __PRETTY_FUNCTION__));

            QUEX_BUFFER_ASSERT_NO_BUFFER_LIMIT_CODE(InputMemory + 1, EndOfFileP);
        }




        Lexer_BufferMemory_construct(&(me->_memory),
                                          InputMemory, MemorySize, EndOfFileP);

        me->on_buffer_content_change = 0x0;

        me->filler = Lexer_BufferFiller_new(input_handle, CharacterEncodingName, TranslationBufferMemorySize);


        Lexer_Buffer_init(me, ByteOrderReversionF);

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
        ((me->_input_p == me->_memory._front + 1) ? static_cast<void> (0) : __assert_fail ("me->_input_p == me->_memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 75, __PRETTY_FUNCTION__));
    }

    template <class InputHandleT> inline void
    Lexer_Buffer_reset(Lexer_Buffer* me,
                            InputHandleT* input_handle,
                            const char* CharacterEncodingName,
                            const size_t TranslationBufferMemorySize)
    {

        if( me->filler != 0x0 ) {


            me->filler->seek_character_index(me->filler, 0);
            me->filler->delete_self(me->filler);
        }
        me->filler = Lexer_BufferFiller_new(input_handle, CharacterEncodingName, TranslationBufferMemorySize);

        Lexer_Buffer_init_analyzis(me, me->_byte_order_reversion_active_f);

        if( me->filler != 0x0 ) {

            Lexer_BufferFiller_initial_load(me);
        } else {
            me->_content_character_index_begin = 0;
            me->_content_character_index_end = 0;
        }

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
        ((me->_input_p == me->_memory._front + 1) ? static_cast<void> (0) : __assert_fail ("me->_input_p == me->_memory._front + 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 114, __PRETTY_FUNCTION__));
    }

    inline void
    Lexer_Buffer_init(Lexer_Buffer* me, bool ByteOrderReversionF)
    {


        me->_content_character_index_end = 0;
        me->_content_character_index_begin = 0;

        Lexer_Buffer_init_analyzis(me, ByteOrderReversionF);

        if( me->filler != 0x0 ) {

            Lexer_BufferFiller_initial_load(me);
        }

        QUEX_BUFFER_ASSERT_CONSISTENCY(me);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(me);
    }

    inline void
    Lexer_Buffer_init_analyzis(Lexer_Buffer* me, bool ByteOrderReversionF)
    {
        me->_byte_order_reversion_active_f = ByteOrderReversionF;


        me->_input_p = me->_memory._front + 1;
        me->_lexeme_start_p = me->_memory._front + 1;




        me->_character_at_lexeme_start = '\0';



    }

    inline void
    Lexer_Buffer_destruct(Lexer_Buffer* me)
    {
        if( me->filler != 0x0 ) {
            me->filler->delete_self(me->filler);
            me->filler = 0x0;
        }

        Lexer_BufferMemory_destruct(&me->_memory);
    }

    inline void
    Lexer_Buffer_input_p_add_offset(Lexer_Buffer* buffer, const size_t Offset)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(buffer);
        buffer->_input_p += Offset;
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(buffer);
    }

    inline Lexer_MemoryPositionMimiker
    Lexer_Buffer_tell_memory_adr(Lexer_Buffer* buffer)
    {





        return Lexer_MemoryPositionMimiker(buffer->_input_p, buffer->_content_character_index_begin);



    }

    inline void
    Lexer_Buffer_seek_memory_adr(Lexer_Buffer* buffer, Lexer_MemoryPositionMimiker Position)
    {





        ((Position.buffer_start_position == (size_t)buffer->_content_character_index_begin) ? static_cast<void> (0) : __assert_fail ("Position.buffer_start_position == (size_t)buffer->_content_character_index_begin", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 195, __PRETTY_FUNCTION__));
        buffer->_input_p = Position.address;



        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
    }

    inline uint8_t
    Lexer_Buffer_input_get_offset(Lexer_Buffer* me, const ptrdiff_t Offset)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(me);
        ((me->_input_p + Offset > me->_memory._front) ? static_cast<void> (0) : __assert_fail ("me->_input_p + Offset > me->_memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 207, __PRETTY_FUNCTION__));
        ((me->_input_p + Offset <= me->_memory._back) ? static_cast<void> (0) : __assert_fail ("me->_input_p + Offset <= me->_memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 208, __PRETTY_FUNCTION__));
        return *(me->_input_p + Offset);
    }

    inline uint8_t*
    Lexer_Buffer_content_front(Lexer_Buffer* me)
    {
        return me->_memory._front + 1;
    }

    inline uint8_t*
    Lexer_Buffer_content_back(Lexer_Buffer* me)
    {
        return me->_memory._back - 1;
    }

    inline size_t
    Lexer_Buffer_content_size(Lexer_Buffer* me)
    {
        return Lexer_BufferMemory_size(&(me->_memory)) - 2;
    }

    inline uint8_t*
    Lexer_Buffer_text_end(Lexer_Buffer* me)
    {

        if( me->_memory._end_of_file_p != 0 ) return me->_memory._end_of_file_p;
        else return me->_memory._back;
    }

    inline ptrdiff_t
    Lexer_Buffer_distance_input_to_text_end(Lexer_Buffer* me)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY_LIGHT(me);
        return Lexer_Buffer_text_end(me) - me->_input_p;
    }

    inline void
    Lexer_Buffer_end_of_file_set(Lexer_Buffer* me, uint8_t* Position)
    {


        me->_memory._end_of_file_p = Position;
        *(me->_memory._end_of_file_p) = ((uint8_t)0x0);


    }

    inline void
    Lexer_Buffer_end_of_file_unset(Lexer_Buffer* buffer)
    {



        buffer->_memory._end_of_file_p = 0x0;

    }

    inline bool
    Lexer_Buffer_is_end_of_file(Lexer_Buffer* buffer)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        return buffer->_input_p == buffer->_memory._end_of_file_p;
    }

    inline bool
    Lexer_Buffer_is_begin_of_file(Lexer_Buffer* buffer)
    {
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        if ( buffer->_input_p != buffer->_memory._front ) return false;
        else if( buffer->_content_character_index_begin != 0 ) return false;
        return true;
    }

    inline void
    Lexer_Buffer_move_forward(Lexer_Buffer* me, const ptrdiff_t CharacterN)
    {
       QUEX_BUFFER_ASSERT_CONSISTENCY(me);


       if( CharacterN < Lexer_Buffer_distance_input_to_text_end(me) ) {

           me->_input_p += CharacterN;
       }
       else {

           if( me->filler == 0x0 || me->_memory._end_of_file_p != 0x0 ) {
               me->_input_p = Lexer_Buffer_text_end(me);
           } else {

               ptrdiff_t delta = CharacterN;
               ptrdiff_t distance = Lexer_Buffer_distance_input_to_text_end(me);
               do {
                   delta -= distance;

                   me->_input_p = me->_memory._back;
                   me->_lexeme_start_p = me->_input_p;
                   if( Lexer_BufferFiller_load_forward(me) == 0 ) {
                       me->_input_p = Lexer_Buffer_text_end(me);
                       break;
                   }

                   ++(me->_input_p);
                   distance = Lexer_Buffer_distance_input_to_text_end(me);

                   if( delta < distance ) {

                       me->_input_p += delta;
                       break;
                   }
               } while( 1 + 1 == 2 );
           }
       }
       me->_lexeme_start_p = me->_input_p;
       me->_character_at_lexeme_start = *(me->_lexeme_start_p);




       QUEX_BUFFER_ASSERT_CONSISTENCY(me);
    }

    inline void
    Lexer_Buffer_move_backward(Lexer_Buffer* me, const ptrdiff_t CharacterN)
    {
       QUEX_BUFFER_ASSERT_CONSISTENCY(me);


       if( CharacterN < (me->_input_p - Lexer_Buffer_content_front(me)) ) {

           me->_input_p -= CharacterN;
       }
       else {

           if( me->filler == 0x0 || me->_content_character_index_begin == 0 ) {
               me->_input_p = Lexer_Buffer_content_front(me);
           } else {

               ptrdiff_t delta = (ptrdiff_t)CharacterN;
               ptrdiff_t distance = (ptrdiff_t)(me->_input_p - Lexer_Buffer_content_front(me));
               do {
                   delta -= distance;

                   me->_input_p = me->_memory._front;
                   me->_lexeme_start_p = me->_input_p + 1;
                   if( Lexer_BufferFiller_load_backward(me) == 0 ) {
                       me->_input_p = Lexer_Buffer_content_front(me);
                       break;
                   }

                   distance = (ptrdiff_t)(me->_input_p - Lexer_Buffer_content_front(me));

                   if( delta < distance ) {

                       me->_input_p -= delta;
                       break;
                   }
               } while( 1 + 1 == 2 );
           }
       }
       me->_lexeme_start_p = me->_input_p;
       me->_character_at_lexeme_start = *(me->_lexeme_start_p);




       QUEX_BUFFER_ASSERT_CONSISTENCY(me);
    }

    inline ptrdiff_t
    Lexer_Buffer_tell(Lexer_Buffer* me)
    {




        const ptrdiff_t DeltaToBufferBegin = me->_input_p - me->_memory._front - 1;


        if( me->filler == 0x0 )
            return DeltaToBufferBegin;
        else
            return DeltaToBufferBegin + me->_content_character_index_begin;
    }

    inline void
    Lexer_Buffer_seek(Lexer_Buffer* me, const ptrdiff_t CharacterIndex)
    {


        const ptrdiff_t CurrentCharacterIndex = Lexer_Buffer_tell(me);
        if( CharacterIndex > CurrentCharacterIndex )
            Lexer_Buffer_move_forward(me, CharacterIndex - CurrentCharacterIndex);
        else
            Lexer_Buffer_move_backward(me, CurrentCharacterIndex - CharacterIndex);
    }

    inline void
    Lexer_Buffer_move_away_passed_content(Lexer_Buffer* me)
    {
        uint8_t* ContentFront = Lexer_Buffer_content_front(me);
        uint8_t* RemainderBegin = me->_input_p;
        uint8_t* RemainderEnd = me->_memory._end_of_file_p;
        uint8_t* MoveRegionBegin = RemainderBegin - (ptrdiff_t)(256);
        ptrdiff_t MoveRegionSize = (ptrdiff_t)(RemainderEnd - MoveRegionBegin);


        ((me->_content_character_index_begin == 0) ? static_cast<void> (0) : __assert_fail ("me->_content_character_index_begin == 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 431, __PRETTY_FUNCTION__));


        if( MoveRegionBegin <= ContentFront ) { return; }

        std::memmove((void*)ContentFront,
                           (void*)MoveRegionBegin,
                           (size_t)MoveRegionSize * sizeof(uint8_t));





        Lexer_Buffer_end_of_file_set(me, ContentFront + MoveRegionSize);




        me->_input_p = ContentFront + (256);



        me->_lexeme_start_p = me->_input_p;
    }

    inline size_t
    Lexer_BufferMemory_size(Lexer_BufferMemory* me)
    { return (size_t)(me->_back - me->_front + 1); }

    inline void
    Lexer_Buffer_reverse_byte_order(uint8_t* Begin, uint8_t* End)
    {
        uint8_t tmp = 0xFF;
        uint8_t* iterator = 0x0;

        switch( sizeof(uint8_t) ) {
        default:
            ((false) ? static_cast<void> (0) : __assert_fail ("false", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 468, __PRETTY_FUNCTION__));
            break;
        case 1:

            break;
        case 2:
            for(iterator=Begin; iterator != End; ++iterator) {
                tmp = *(((uint8_t*)iterator) + 0);
                *(((uint8_t*)iterator) + 0) = *(((uint8_t*)iterator) + 1);
                *(((uint8_t*)iterator) + 1) = tmp;
            }
            break;
        case 4:
            for(iterator=Begin; iterator != End; ++iterator) {
                tmp = *(((uint8_t*)iterator) + 0);
                *(((uint8_t*)iterator) + 0) = *(((uint8_t*)iterator) + 3);
                *(((uint8_t*)iterator) + 3) = tmp;
                tmp = *(((uint8_t*)iterator) + 1);
                *(((uint8_t*)iterator) + 1) = *(((uint8_t*)iterator) + 2);
                *(((uint8_t*)iterator) + 2) = tmp;
            }
            break;
        }
    }

    inline void
    Lexer_BufferMemory_construct(Lexer_BufferMemory* me,
                                      uint8_t* Memory,
                                      const size_t Size,
                                      uint8_t* EndOfFileP)


    {
        uint8_t* chunk = Memory;
        uint8_t* end_of_file_p = EndOfFileP;
        bool external_f = true;

        if( Memory == 0x0 ) {


            chunk = Lexer_MemoryManager_BufferMemory_allocate(Size * sizeof(uint8_t));
            end_of_file_p = 0x0;
            external_f = false;
        }

        Lexer_BufferMemory_init(me, chunk, Size, end_of_file_p, external_f);
    }

    inline uint8_t*
    Lexer_BufferMemory_reset(Lexer_BufferMemory* me,
                                  uint8_t* Memory,
                                  const size_t Size,
                                  uint8_t* EndOfContentP)

    {
        uint8_t* old_memory = (me->_external_owner_f) ? me->_front : 0x0;

        if( Memory == 0x0 ) return old_memory;


        Lexer_BufferMemory_destruct(me);


        ((Memory != 0x0) ? static_cast<void> (0) : __assert_fail ("Memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 531, __PRETTY_FUNCTION__));


        ((EndOfContentP > Memory) ? static_cast<void> (0) : __assert_fail ("EndOfContentP > Memory", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 534, __PRETTY_FUNCTION__));
        ((EndOfContentP <= Memory + Size) ? static_cast<void> (0) : __assert_fail ("EndOfContentP <= Memory + Size", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 535, __PRETTY_FUNCTION__));

        Lexer_BufferMemory_init(me, Memory, Size, EndOfContentP, true);

        return old_memory;
    }

    inline void
    Lexer_BufferMemory_init(Lexer_BufferMemory* me,
                                 uint8_t* Memory,
                                 const size_t Size,
                                 uint8_t* EndOfFileP,
                                 bool ExternalOwnerF)
    {


        ((Memory != 0x0) ? static_cast<void> (0) : __assert_fail ("Memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 551, __PRETTY_FUNCTION__));
        ((Size != 0) ? static_cast<void> (0) : __assert_fail ("Size != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 552, __PRETTY_FUNCTION__));

        if( Size <= (256) + 2) {
            do { throw std::runtime_error("Error: Tried to initialize buffer memory with a size less or equal\n" "Error: to QUEX_SETTING_BUFFER_MIN_FALLBACK_N + 2. Maybe, define\n" "Error: -DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=0, if no pre-contexts\n" "Error: are involved."); } while(0)


                                                   ;
        }
        else if( EndOfFileP != 0x0 ) {
            ((EndOfFileP > Memory) ? static_cast<void> (0) : __assert_fail ("EndOfFileP > Memory", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 561, __PRETTY_FUNCTION__));
            ((EndOfFileP <= Memory + Size) ? static_cast<void> (0) : __assert_fail ("EndOfFileP <= Memory + Size", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/Buffer.i", 562, __PRETTY_FUNCTION__));
        }


        me->_front = Memory;
        me->_end_of_file_p = EndOfFileP;
        me->_back = Memory + (Size - 1);
        me->_external_owner_f = ExternalOwnerF;
        *(me->_front) = ((uint8_t)0x0);
        *(me->_back) = ((uint8_t)0x0);
        if( me->_end_of_file_p != 0x0 ) {
            *(me->_end_of_file_p) = ((uint8_t)0x0);
        }


        if( EndOfFileP != 0x0 ) {
           if( EndOfFileP < me->_back - 1 ) {
               std::memset(EndOfFileP + 1, 0xFF, (size_t)((me->_back - EndOfFileP) - (ptrdiff_t)(1)));
            }
        }

    }

    inline void
    Lexer_BufferMemory_destruct(Lexer_BufferMemory* me)
    {
        if( me->_external_owner_f == false && me->_front != (uint8_t*)0x0 ) {
            Lexer_MemoryManager_BufferMemory_free(me->_front);

        }

        me->_front = me->_back = (uint8_t*)0x0;
    }

    inline void
    Lexer_Buffer_print_this(Lexer_Buffer* me)
    {
        uint8_t* Offset = me->_memory._front;

        std::printf("   Buffer:\n");
        std::printf("      Memory:\n");
        std::printf("      _front         =  0;\n");
        std::printf("      _back          = +0x%X;\n", (int)(me->_memory._back - Offset));
        if( me->_memory._end_of_file_p != 0x0 )
            std::printf("      _end_of_file_p = +0x%X;\n", (int)(me->_memory._end_of_file_p - Offset));
        else
            std::printf("      _end_of_file_p = <void>;\n");


        std::printf("      _external_owner_f = %s;\n", me->_memory._external_owner_f ? "true" : "false");

        std::printf("   _input_p        = +0x%X;\n", (int)(me->_input_p - Offset));
        std::printf("   _lexeme_start_p = +0x%X;\n", (int)(me->_lexeme_start_p - Offset));

        std::printf("   _character_at_lexeme_start = %X;\n", (int)me->_character_at_lexeme_start);



        std::printf("   _content_character_index_begin = %i;\n", (int)me->_content_character_index_begin);
        std::printf("   _content_character_index_end   = %i;\n", (int)me->_content_character_index_end);
        std::printf("   _byte_order_reversion_active_f = %s;\n", me->_byte_order_reversion_active_f ? "true" : "false");
    }

}




namespace boeck {

    inline uint8_t*
    Lexer_MemoryManager_Default_allocate(const size_t ByteN)
    {
         uint8_t* result = (uint8_t*)std::malloc((size_t)ByteN);

         std::memset((void*)result, 0xFF, ByteN);

         return result;
    }

    inline void
    Lexer_MemoryManager_Default_free(void* Obj)
    { std::free(Obj); }

    struct __QuexBufferFiller_tag;
    inline uint8_t*
    Lexer_MemoryManager_BufferMemory_allocate(const size_t ByteN)
    { return (uint8_t*)Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferMemory_free(uint8_t* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }

    inline void*
    Lexer_MemoryManager_BufferFiller_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferFiller_free(void* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }

    inline uint8_t*
    Lexer_MemoryManager_BufferFiller_RawBuffer_allocate(const size_t ByteN)
    { return Lexer_MemoryManager_Default_allocate(ByteN); }

    inline void
    Lexer_MemoryManager_BufferFiller_RawBuffer_free(uint8_t* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free(memory); }
    inline uint8_t*
    Lexer_MemoryManager_Text_allocate(const size_t ByteN)
    { return (uint8_t*)Lexer_MemoryManager_Default_allocate(ByteN); }

    extern uint8_t Lexer_LexemeNullObject;

    inline void
    Lexer_MemoryManager_Text_free(uint8_t* memory)
    {

        ((memory != &(Lexer_LexemeNullObject)) ? static_cast<void> (0) : __assert_fail ("memory != &(Lexer_LexemeNullObject)", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 92, __PRETTY_FUNCTION__));

        if( memory != 0x0 ) {
            Lexer_MemoryManager_Default_free((void*)memory);
        }
    }
    inline size_t
    Lexer_MemoryManager_insert(uint8_t* drain_begin_p, uint8_t* drain_end_p,
                                    uint8_t* source_begin_p, uint8_t* source_end_p)





    {

        const size_t DrainSize = (size_t)(drain_end_p - drain_begin_p);
        size_t size = (size_t)(source_end_p - source_begin_p);
        ((drain_end_p >= drain_begin_p) ? static_cast<void> (0) : __assert_fail ("drain_end_p >= drain_begin_p", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 137, __PRETTY_FUNCTION__));
        ((source_end_p >= source_begin_p) ? static_cast<void> (0) : __assert_fail ("source_end_p >= source_begin_p", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 138, __PRETTY_FUNCTION__));

        if( DrainSize < size ) size = DrainSize;



        if( drain_begin_p > source_begin_p ) ((drain_begin_p >= source_begin_p + size) ? static_cast<void> (0) : __assert_fail ("drain_begin_p >= source_begin_p + size", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 144, __PRETTY_FUNCTION__));
        else ((drain_begin_p <= source_begin_p - size) ? static_cast<void> (0) : __assert_fail ("drain_begin_p <= source_begin_p - size", "/home/fschaef/prj/quex/trunk/quex/code_base/MemoryManager.i", 145, __PRETTY_FUNCTION__));

        std::memcpy(drain_begin_p, source_begin_p, size);

        return size;
    }
    inline Lexer_Memento*
    Lexer_MemoryManager_Memento_allocate()
    {
        const size_t MemorySize = sizeof(Lexer_Memento);
        return (Lexer_Memento*)Lexer_MemoryManager_Default_allocate(MemorySize);
    }

    inline void
    Lexer_MemoryManager_Memento_free(struct Lexer_Memento_tag* memory)
    { if( memory != 0x0 ) Lexer_MemoryManager_Default_free((void*)memory); }


}



namespace boeck {

inline void
Lexer_construct_memory(::boeck::Lexer* me,
                            uint8_t* BufferMemoryBegin,
                            size_t BufferMemorySize,
                            uint8_t* BufferEndOfContentP,
                            const char* CharacterEncodingName ,
                            bool ByteOrderReversionF )
{
    size_t memory_size = BufferMemoryBegin != 0 ? BufferMemorySize
                          : 65536;

    uint8_t* iterator = 0x0;

    ((memory_size == 0 || memory_size > 2) ? static_cast<void> (0) : __assert_fail ("memory_size == 0 || memory_size > 2", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 26, __PRETTY_FUNCTION__));
    if( BufferMemoryBegin != 0x0 ) {


        if( BufferMemorySize <= (256) + 2) {
            do { throw std::runtime_error("\nConstructor: Provided memory size must be more than 2 greater than\n" "Constructor: QUEX_SETTING_BUFFER_MIN_FALLBACK_N. If in doubt, specify\n" "Constructor: -DQUEX_SETTING_BUFFER_MIN_FALLBACK_N=0 as compile option.\n"); } while(0)

                                                                                                       ;
        }
        if( BufferEndOfContentP < BufferMemoryBegin
            || BufferEndOfContentP > (BufferMemoryBegin + BufferMemorySize - 1)) {
            do { throw std::runtime_error("\nConstructor: Argument 'BufferEndOfContentP' must be inside the provided memory\n" "Constructor: buffer (speficied by 'BufferMemoryBegin' and 'BufferMemorySize').\n" "Constructor: Note, that the last element of the buffer is to be filled with\n" "Constructor: the buffer limit code character.\n"); } while(0)


                                                                              ;
        }
    }
    if( BufferEndOfContentP != 0x0 ) {
        ((BufferEndOfContentP > BufferMemoryBegin) ? static_cast<void> (0) : __assert_fail ("BufferEndOfContentP > BufferMemoryBegin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 44, __PRETTY_FUNCTION__));
        ((BufferEndOfContentP <= BufferMemoryBegin + memory_size - 1) ? static_cast<void> (0) : __assert_fail ("BufferEndOfContentP <= BufferMemoryBegin + memory_size - 1", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/constructor.i", 45, __PRETTY_FUNCTION__));



        for(iterator = BufferMemoryBegin + 1; iterator != BufferEndOfContentP; ++iterator) {
            if( *iterator == ((uint8_t)0x0)
                || *iterator == ((uint8_t)0x1) ) {
                do { throw std::runtime_error("\nConstructor: Buffer limit code and/or path termination code appeared in buffer\n" "Constructor: when pointed to user memory. Note, that the memory pointed to must\n" "Constructor: be initialized! You might redefine QUEX_SETTING_PATH_TERMINATION_CODE\n" "Constructor: and/or QUEX_SETTING_PATH_TERMINATION_CODE; or use command line arguments\n" "Constructor: '--buffer-limit' and '--path-termination'."); } while(0)



                                                                                          ;
            }
        }
    }


    Lexer_constructor_core(me,



                                (void*)0x0,

                                CharacterEncodingName, ByteOrderReversionF,
                                BufferMemoryBegin, memory_size, BufferEndOfContentP);
}

inline void
Lexer_construct_file_name(::boeck::Lexer* me,
                               const char* Filename,
                               const char* CharacterEncodingName ,
                               bool ByteOrderReversionF )
{



    std::FILE* fh = std::fopen(Filename, "rb");

    Lexer_construct_FILE(me, fh, CharacterEncodingName, ByteOrderReversionF);


    me->__file_handle_allocated_by_constructor = fh;
}

inline void
Lexer_construct_FILE(::boeck::Lexer* me,
                          std::FILE* fh,
                          const char* CharacterEncodingName ,
                          bool ByteOrderReversionF )
{
    if( fh == __null ) do { throw std::runtime_error("Error: received NULL as a file handle."); } while(0);
    setbuf(fh, 0);

    Lexer_constructor_core(me, fh,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}


inline void
Lexer_construct_istream(::boeck::Lexer* me,
                             std::istream* p_input_stream,
                             const char* CharacterEncodingName ,
                             bool ByteOrderReversionF )
{
    if( p_input_stream == __null ) do { throw std::runtime_error("Error: received NULL as pointer to input stream."); } while(0);
    if( p_input_stream == std::cin ) do { throw std::runtime_error("Error: Quex engine constructor has received a standard input handle!\n" "Error: Standard input has to be treated like buffered input. Please,\n" "Error: consult the documentation or the example 'stdinlexer.cpp' in\n" "Error: directory $QUEX_PATH/demo/010 (> make stdinlexer.exe). Please,\n" "Error: review the other (non-stdin) examples in this directory to\n" "Error: conclude how to read encoded data via stdin.\n"); } while(0);
    Lexer_constructor_core(me, p_input_stream,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}




inline void
Lexer_construct_wistream(::boeck::Lexer* me,
                              std::wistream* p_input_stream,
                              const char* CharacterEncodingName ,
                              bool ByteOrderReversionF )
{
    if( p_input_stream == __null )
        do { throw std::runtime_error("Error: received NULL as pointer to input stream.\n"); } while(0);
    Lexer_constructor_core(me, p_input_stream,
                                CharacterEncodingName, ByteOrderReversionF,
                                0x0, 65536, 0x0);
}


inline void
Lexer_destruct(::boeck::Lexer* me)
{
    Lexer_destruct_basic(me);
}

template <class InputHandleT> inline void
Lexer_reset(::boeck::Lexer* me,
                 InputHandleT* input_handle,
                 const char* CharacterEncodingName )
{
    Lexer_reset_basic(me, input_handle, CharacterEncodingName,
                           ((size_t)0));
    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));
}

inline uint8_t*
Lexer_reset_buffer(::boeck::Lexer* me,
                        uint8_t* BufferMemoryBegin,
                        size_t BufferMemorySize,
                        uint8_t* BufferEndOfContentP,
                        const char* CharacterEncodingName )
{
    uint8_t* old_memory = 0x0;


    if( BufferEndOfContentP < BufferMemoryBegin
        || BufferEndOfContentP > (BufferMemoryBegin + BufferMemorySize - 1)) {
        do { throw std::runtime_error("\nreset_buffer: Argument 'BufferEndOfContentP' must be inside the provided memory\n" "reset_buffer: buffer (speficied by 'BufferMemoryBegin' and 'BufferMemorySize').\n" "reset_buffer: Note, that the last element of the buffer is to be filled with\n" "reset_buffer: the buffer limit code character.\n"); } while(0)


                                                                           ;
    }




    old_memory = Lexer_BufferMemory_reset(&me->buffer._memory,
                                               BufferMemoryBegin, BufferMemorySize,
                                               BufferEndOfContentP);

    if( BufferMemoryBegin == 0x0 ) return old_memory;

    Lexer_reset_basic(me, (FILE*)0x0, CharacterEncodingName,
                           ((size_t)0));

    me->__current_mode_p = 0x0;
    Lexer_set_mode_brutally_by_id(me, (Lexer_ModeID_NORMAL));

    return old_memory;
}

inline void
Lexer_reset_plain(::boeck::Lexer* me,
                       const char* CharacterEncodingName )
{ Lexer_reset(me, (FILE*)0x0, CharacterEncodingName); }


inline
Lexer::Lexer(uint8_t* BufferMemoryBegin,
                                 size_t BufferMemorySize,
                                 uint8_t* BufferEndOfFileP,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_memory(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfFileP,
                              CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(const std::string& Filename,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_file_name(this, Filename.c_str(), CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(std::FILE* fh,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_FILE(this, fh, CharacterEncodingName, ByteOrderReversionF); }

inline
Lexer::Lexer(std::istream* p_input_stream,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_istream(this, p_input_stream, CharacterEncodingName, ByteOrderReversionF); }


inline
Lexer::Lexer(std::wistream* p_input_stream,
                                 const char* CharacterEncodingName ,
                                 bool ByteOrderReversionF )
{ Lexer_construct_wistream(this, p_input_stream, CharacterEncodingName, ByteOrderReversionF); }
inline
Lexer::~Lexer()
{ Lexer_destruct(this); }

template<class InputHandleT> void
Lexer::reset(InputHandleT* input_handle, const char* CharacterEncodingName )
{ Lexer_reset(this, input_handle, CharacterEncodingName); }

inline uint8_t*
Lexer::reset_buffer(uint8_t* BufferMemoryBegin,
                          size_t BufferMemorySize,
                          uint8_t* BufferEndOfContentP,
                          const char* CharacterEncodingName )
{ return Lexer_reset_buffer(this, BufferMemoryBegin, BufferMemorySize, BufferEndOfContentP, CharacterEncodingName); }


}



namespace boeck {
    struct Lexer_Mode_tag;

    template <class InputHandleT> inline void
    Lexer_construct_basic(::boeck::Lexer* me,
                               InputHandleT* input_handle,
                               uint8_t* BufferMemory,
                               const size_t BufferMemorySize,
                               uint8_t* EndOfFileP,
                               const char* CharacterEncodingName,
                               const size_t TranslationBufferMemorySize,
                               bool ByteOrderReversionF)
    {





        if( ((uint8_t)0x0) == ((uint8_t)0x1) ) {
            do { throw std::runtime_error("Path termination code (PTC) and buffer limit code (BLC) must be different.\n"); } while(0);
        }
            me->token = &me->__memory_token;






        Lexer_Counter_construct(&me->counter);


        Lexer_Accumulator_construct(&me->accumulator, (::boeck::Lexer*)me);



        me->_parent_memento = 0x0;






        me->_mode_stack.end = me->_mode_stack.begin;
        me->_mode_stack.memory_end = me->_mode_stack.begin + (size_t)8;




        std::memset((uint8_t*)&me->buffer, 0xFF, sizeof(me->buffer));


        Lexer_Buffer_construct(&me->buffer, input_handle,
                                    BufferMemory, BufferMemorySize, EndOfFileP,
                                    CharacterEncodingName, TranslationBufferMemorySize,
                                    ByteOrderReversionF);

        if( input_handle == 0x0 ) {



            if( BufferMemory == 0x0 ) {

                Lexer_Buffer_end_of_file_set(&me->buffer, me->buffer._memory._front + 1);
            }


            ((me->buffer._memory._end_of_file_p > me->buffer._memory._front) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p > me->buffer._memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 108, __PRETTY_FUNCTION__));
            ((me->buffer._memory._end_of_file_p <= me->buffer._memory._back) ? static_cast<void> (0) : __assert_fail ("me->buffer._memory._end_of_file_p <= me->buffer._memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 109, __PRETTY_FUNCTION__));
        }

        me->__file_handle_allocated_by_constructor = 0x0;
    }

    template <class InputHandleT> inline void
    Lexer_reset_basic(::boeck::Lexer* me,
                           InputHandleT* input_handle,
                           const char* CharacterEncodingName,
                           const size_t TranslationBufferMemorySize)

    {
        Lexer_Counter_reset(&me->counter);






        Lexer_include_stack_delete((::boeck::Lexer*)me);





        Lexer_Accumulator_clear(&me->accumulator);






        me->_mode_stack.end = me->_mode_stack.begin;
        me->_mode_stack.memory_end = me->_mode_stack.begin + (size_t)8;

        Lexer_Buffer_reset(&me->buffer, input_handle, CharacterEncodingName, TranslationBufferMemorySize);
    }


    inline void
    Lexer_destruct_basic(::boeck::Lexer* me)
    {





        Lexer_include_stack_delete((::boeck::Lexer*)me);





        Lexer_Accumulator_destruct(&me->accumulator);






        Lexer_Buffer_destruct(&me->buffer);

        if( me->__file_handle_allocated_by_constructor != 0x0 ) {
            std::fclose(me->__file_handle_allocated_by_constructor);
        }
    }





    inline void
    Lexer_buffer_reload_backward(Lexer_Buffer* buffer)
    {
        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 184, __PRETTY_FUNCTION__));
        ((buffer->filler != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->filler != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 185, __PRETTY_FUNCTION__));

        if( buffer->on_buffer_content_change != 0x0 ) {


            buffer->on_buffer_content_change(buffer->_memory._front,
                                             Lexer_Buffer_text_end(buffer));
        }

        (void)Lexer_BufferFiller_load_backward(buffer);
    }

    inline size_t
    Lexer___buffer_reload_forward_core(Lexer_Buffer* buffer)
    {
        size_t loaded_character_n = (size_t)-1;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 212, __PRETTY_FUNCTION__));
        ((buffer->filler != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->filler != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 213, __PRETTY_FUNCTION__));
        ((buffer->_memory._end_of_file_p == 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/member/basic.i", 214, __PRETTY_FUNCTION__));

        if( buffer->_memory._end_of_file_p != 0x0 ) {
            return 0;
        }

        if( buffer->on_buffer_content_change != 0x0 ) {



            buffer->on_buffer_content_change(buffer->_memory._front,
                                             buffer->_memory._back);
        }

        loaded_character_n = Lexer_BufferFiller_load_forward(buffer);
        return loaded_character_n;
    }

    inline void
    Lexer_buffer_reload_forward(Lexer_Buffer* buffer,
                                     Lexer_MemoryPositionMimiker* position_register,
                                     const size_t PositionRegisterN)
    {
        Lexer_MemoryPositionMimiker* iterator = 0x0;
        Lexer_MemoryPositionMimiker* End = position_register + (ptrdiff_t)PositionRegisterN;
        size_t loaded_character_n = (size_t)-1;

        loaded_character_n = Lexer___buffer_reload_forward_core(buffer);

        for(iterator = position_register; iterator != End; ++iterator) {


            *iterator -= (ptrdiff_t)loaded_character_n;
        }
    }


}


namespace boeck {

    inline uint32_t
    Lexer_Mode_uncallable_analyzer_function(::boeck::Lexer* me)
    {
        ((0) ? static_cast<void> (0) : __assert_fail ("0", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Mode.i", 15, __PRETTY_FUNCTION__));
        (void)me;



        return (uint32_t)0;

    }


    inline void
    Lexer_Mode_on_indentation_null_function(::boeck::Lexer* me,
                                                 uint8_t* LexemeBegin,
                                                 uint8_t* LexemeEnd)
    { (void)me; (void)LexemeBegin; (void)LexemeEnd; }


    inline void
    Lexer_Mode_on_entry_exit_null_function(::boeck::Lexer* me,
                                                const Lexer_Mode* TheMode)
    { (void)me; (void)TheMode; }

}



namespace boeck {

    inline ptrdiff_t Lexer___BufferFiller_forward_compute_fallback_region(Lexer_Buffer* buffer,
                                                                                     const ptrdiff_t Distance_LexemeStart_to_InputP);
    inline ptrdiff_t Lexer___BufferFiller_backward_compute_backward_distance(Lexer_Buffer* buffer);

    inline void Lexer___BufferFiller_forward_copy_fallback_region(Lexer_Buffer*,
                                                                                  const ptrdiff_t FallBackN);
    inline void Lexer___BufferFiller_forward_adapt_pointers(Lexer_Buffer*,
                                                                            const ptrdiff_t DesiredLoadN,
                                                                            const size_t LoadedN,
                                                                            const ptrdiff_t FallBackN,
                                                                            const ptrdiff_t Distance_LexemeStart_to_InputP);
    inline void Lexer___BufferFiller_backward_copy_backup_region(Lexer_Buffer*,
                                                                                 const ptrdiff_t BackwardDistance);
    inline void Lexer___BufferFiller_backward_adapt_pointers(Lexer_Buffer*,
                                                                             const ptrdiff_t BackwardDistance);
    inline void Lexer___BufferFiller_on_overflow(Lexer_Buffer*, bool ForwardF);

    inline size_t Lexer___BufferFiller_read_characters(Lexer_Buffer*, uint8_t*,
                                                                     const ptrdiff_t);
    template <class InputHandleT> inline Lexer_BufferFiller*
    Lexer_BufferFiller_new(InputHandleT* input_handle,
                                const char* CharacterEncodingName,
                                const size_t TranslationBufferMemorySize)


    {
        (void)TranslationBufferMemorySize;
        if( CharacterEncodingName != 0x0 ) {
            do { throw std::runtime_error("Use of buffer filler type 'CharacterEncodingName' while " "'QUEX_SETTING_BUFFER_FILLERS_CONVERTER_NEW' has not\n" "been defined (use --iconv, --icu, --converter-new to specify converter).\n"); } while(0)

                                                                                                         ;
            return (Lexer_BufferFiller*)0x0;
        }



        else if( input_handle == 0x0 ) {
            return (Lexer_BufferFiller*)0x0;
        }

        return (Lexer_BufferFiller*)Lexer_BufferFiller_Plain_new(input_handle);
    }


    inline void
    Lexer_BufferFiller_delete_self(Lexer_BufferFiller* me)
    {
        if( me->delete_self == 0x0 ) do { throw std::runtime_error("BufferFiller object did not specify 'delete_self()'\n"); } while(0);
        else me->delete_self(me);
    }

    inline void
    Lexer_BufferFiller_setup_functions(Lexer_BufferFiller* me,
                                            ptrdiff_t (*tell_character_index)(Lexer_BufferFiller*),
                                            void (*seek_character_index)(Lexer_BufferFiller*,
                                                                                 const ptrdiff_t),
                                            size_t (*read_characters)(Lexer_BufferFiller*,
                                                                            uint8_t*, const size_t),
                                            void (*delete_self)(Lexer_BufferFiller*))
    {
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 121, __PRETTY_FUNCTION__));
        ((tell_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("tell_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 122, __PRETTY_FUNCTION__));
        ((seek_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("seek_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 123, __PRETTY_FUNCTION__));
        ((read_characters != 0x0) ? static_cast<void> (0) : __assert_fail ("read_characters != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 124, __PRETTY_FUNCTION__));
        ((delete_self != 0x0) ? static_cast<void> (0) : __assert_fail ("delete_self != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 125, __PRETTY_FUNCTION__));


        me->tell_character_index = tell_character_index;
        me->seek_character_index = seek_character_index;
        me->read_characters = read_characters;
        me->_on_overflow = 0x0;
        me->delete_self = delete_self;
    }

    inline void
    Lexer_BufferFiller_initial_load(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);
        Lexer_BufferFiller* me = buffer->filler;
        size_t LoadedN = 0;


        ((buffer->_input_p == ContentFront) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == ContentFront", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 144, __PRETTY_FUNCTION__));
        ((buffer->_lexeme_start_p == ContentFront) ? static_cast<void> (0) : __assert_fail ("buffer->_lexeme_start_p == ContentFront", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 145, __PRETTY_FUNCTION__));







        me->seek_character_index(me, 0);

        LoadedN = Lexer___BufferFiller_read_characters(buffer, ContentFront, ContentSize);

        buffer->_content_character_index_begin = 0;
        buffer->_content_character_index_end = me->tell_character_index(buffer->filler);

        if( me->tell_character_index(me) != (ptrdiff_t)LoadedN )
            do { throw std::runtime_error("\nThe provided input stream behaves strangely. Number of read\n" "characters is not proportional to the stream position increase.\n" "The buffer filler type which you are using might be able to\n" "deal with those cases. Try compile option:\n" "\n" "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" "\n" "However, those mechanisms imply a trade-off in terms of speed.\n" "Please, consider using a 'binary' for your input stream, or use\n" "a different implementation of the standard I/O library (e.g.\n" "not Microsoft(tm)).\n"); } while(0);


        if( LoadedN != (size_t)ContentSize ) Lexer_Buffer_end_of_file_set(buffer, ContentFront + LoadedN);
        else Lexer_Buffer_end_of_file_unset(buffer);

        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);
    }

    inline size_t
    Lexer_BufferFiller_load_forward(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);
        ptrdiff_t Distance_LexemeStart_to_InputP = (ptrdiff_t)-1;
        ptrdiff_t FallBackN = (ptrdiff_t)-1;
        ptrdiff_t DesiredLoadN = (ptrdiff_t)-1;
        uint8_t* new_content_begin = 0x0;
        size_t LoadedN = (size_t)-1;
        Lexer_BufferFiller* me = buffer->filler;
        if( me == 0x0 ) return 0;

        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 211, __PRETTY_FUNCTION__));
        ((me->tell_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 212, __PRETTY_FUNCTION__));
        ((me->seek_character_index != 0x0) ? static_cast<void> (0) : __assert_fail ("me->seek_character_index != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 213, __PRETTY_FUNCTION__));
        ((me->read_characters != 0x0) ? static_cast<void> (0) : __assert_fail ("me->read_characters != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 214, __PRETTY_FUNCTION__));



        Distance_LexemeStart_to_InputP = buffer->_input_p - buffer->_lexeme_start_p;
        if( Distance_LexemeStart_to_InputP >= ContentSize ) {
            Lexer___BufferFiller_on_overflow(buffer, true);
            return 0;
        }
        ;


        if ( buffer->_input_p == buffer->_memory._front ) { return 0; }
        else if( buffer->_input_p == buffer->_memory._end_of_file_p ) { return 0; }
        else if( buffer->_input_p != buffer->_memory._back ) {
            do { throw std::runtime_error("Call to 'load_forward() but '_input_p' not on buffer border.\n" "(Check character encoding)"); } while(0)
                                                         ;
        }
        else if( buffer->_memory._end_of_file_p != 0x0 ) {

            return 0;
        }





        FallBackN = Lexer___BufferFiller_forward_compute_fallback_region(buffer,
                                                                                 Distance_LexemeStart_to_InputP);
        ((FallBackN < ContentSize) ? static_cast<void> (0) : __assert_fail ("FallBackN < ContentSize", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 243, __PRETTY_FUNCTION__));
        DesiredLoadN = ContentSize - FallBackN;

        Lexer___BufferFiller_forward_copy_fallback_region(buffer, FallBackN);





        me->seek_character_index(me, buffer->_content_character_index_end);
        buffer->_content_character_index_begin = buffer->_content_character_index_end - FallBackN;

        new_content_begin = ContentFront + FallBackN;
        LoadedN = Lexer___BufferFiller_read_characters(buffer,
                                                                       new_content_begin,
                                                                       DesiredLoadN);



        Lexer___BufferFiller_forward_adapt_pointers(buffer,
                                                         DesiredLoadN, LoadedN, FallBackN,
                                                         Distance_LexemeStart_to_InputP);

        buffer->_content_character_index_end = buffer->_content_character_index_begin
                                                 + (Lexer_Buffer_text_end(buffer) - ContentFront);




        if( (me->tell_character_index(me) - buffer->_content_character_index_begin - FallBackN) != (ptrdiff_t)LoadedN )
            do { throw std::runtime_error("\nThe provided input stream behaves strangely. Number of read\n" "characters is not proportional to the stream position increase.\n" "The buffer filler type which you are using might be able to\n" "deal with those cases. Try compile option:\n" "\n" "-DQUEX_OPTION_STRANGE_ISTREAM_IMPLEMENTATION\n" "\n" "However, those mechanisms imply a trade-off in terms of speed.\n" "Please, consider using a 'binary' for your input stream, or use\n" "a different implementation of the standard I/O library (e.g.\n" "not Microsoft(tm)).\n"); } while(0);

        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);


        return (size_t)DesiredLoadN;
    }

    inline ptrdiff_t
    Lexer___BufferFiller_forward_compute_fallback_region(Lexer_Buffer* buffer,
                                                              const ptrdiff_t Distance_LexemeStart_to_InputP)
    {
        ptrdiff_t FallBackN = (ptrdiff_t)-1;

        (void)buffer;
        ((buffer->_memory._end_of_file_p == 0x0) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 307, __PRETTY_FUNCTION__));
        ((buffer->_input_p == buffer->_memory._back) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == buffer->_memory._back", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 308, __PRETTY_FUNCTION__));
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        ((Distance_LexemeStart_to_InputP == buffer->_input_p - buffer->_lexeme_start_p) ? static_cast<void> (0) : __assert_fail ("Distance_LexemeStart_to_InputP == buffer->_input_p - buffer->_lexeme_start_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 310, __PRETTY_FUNCTION__));
        ((Distance_LexemeStart_to_InputP < (ptrdiff_t)Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("Distance_LexemeStart_to_InputP < (ptrdiff_t)Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 311, __PRETTY_FUNCTION__));


        FallBackN = (ptrdiff_t)(256) > Distance_LexemeStart_to_InputP
                    ? (ptrdiff_t)(256)
                    : Distance_LexemeStart_to_InputP;
        return FallBackN;
    }

    inline void
    Lexer___BufferFiller_forward_copy_fallback_region(Lexer_Buffer* buffer, const ptrdiff_t FallBackN)
    {



        uint8_t* source = Lexer_Buffer_content_back(buffer) - FallBackN + 1;
        uint8_t* drain = Lexer_Buffer_content_front(buffer);


        if( drain + FallBackN >= source ) {
            std::memmove((uint8_t*)drain, (uint8_t*)source, (size_t)FallBackN * sizeof(uint8_t));
        } else {
            std::memcpy((uint8_t*)drain, (uint8_t*)source, (size_t)FallBackN * sizeof(uint8_t));
        }



        std::memset((uint8_t*)(drain + FallBackN), (uint8_t)(0xFF),
                          (Lexer_Buffer_content_size(buffer) - (size_t)FallBackN)*sizeof(uint8_t));


        (((size_t)FallBackN < Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("(size_t)FallBackN < Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 342, __PRETTY_FUNCTION__));
    }

    inline void
    Lexer___BufferFiller_forward_adapt_pointers(Lexer_Buffer* buffer,
                                                     const ptrdiff_t DesiredLoadN,
                                                     const size_t LoadedN,
                                                     const ptrdiff_t FallBackN,
                                                     const ptrdiff_t Distance_LexemeStart_to_InputP)
    {
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);

        ((buffer->_memory._end_of_file_p == 0x0 || (LoadedN + (size_t)FallBackN) == Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0 || (LoadedN + (size_t)FallBackN) == Lexer_Buffer_content_size(buffer)",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i"
        ,
 355
        , __PRETTY_FUNCTION__))
                                                                                                   ;
        ((DesiredLoadN != 0) ? static_cast<void> (0) : __assert_fail ("DesiredLoadN != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 356, __PRETTY_FUNCTION__));


        if( LoadedN != (size_t)DesiredLoadN )
            Lexer_Buffer_end_of_file_set(buffer, ContentFront + FallBackN + (ptrdiff_t)LoadedN);
        else
            Lexer_Buffer_end_of_file_unset(buffer);




        buffer->_input_p = ContentFront + FallBackN - 1;


        buffer->_lexeme_start_p = (buffer->_input_p + 1) - Distance_LexemeStart_to_InputP;


        ((buffer->_memory._end_of_file_p == 0x0 || ((ptrdiff_t)LoadedN + FallBackN) == buffer->_memory._end_of_file_p - buffer->_memory._front - 1) ? static_cast<void> (0) : __assert_fail ("buffer->_memory._end_of_file_p == 0x0 || ((ptrdiff_t)LoadedN + FallBackN) == buffer->_memory._end_of_file_p - buffer->_memory._front - 1",
 "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i"
        ,
 374
        , __PRETTY_FUNCTION__))
                                                                                                                         ;

    }


    inline size_t
    Lexer_BufferFiller_load_backward(Lexer_Buffer* buffer)
    {
        Lexer_BufferFiller* me = buffer->filler;
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);
        uint8_t* ContentBack = Lexer_Buffer_content_back(buffer);
        ptrdiff_t BackwardDistance = (ptrdiff_t)-1;
        ptrdiff_t NewContentCharacterIndexBegin = (ptrdiff_t)-1;

        size_t LoadedN = (size_t)-1;





        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);

        if( me == 0x0 ) return 0;
        ((buffer != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 433, __PRETTY_FUNCTION__));
        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);


        if ( buffer->_input_p == buffer->_memory._back ) { return 0; }
        else if( buffer->_input_p == buffer->_memory._end_of_file_p ) { return 0; }
        else if( buffer->_input_p != buffer->_memory._front ) {
            do { throw std::runtime_error("Call to 'load_backward() but '_input_p' not on buffer border.\n" "(Check character encoding)"); } while(0)
                                                         ;
        }
        else if( buffer->_content_character_index_begin == 0 ) { return 0; }





        if( buffer->_lexeme_start_p == ContentBack ) {
            Lexer___BufferFiller_on_overflow(buffer, false);
            return 0;
        }



        BackwardDistance = Lexer___BufferFiller_backward_compute_backward_distance(buffer);






        NewContentCharacterIndexBegin = buffer->_content_character_index_begin - BackwardDistance;
        ((BackwardDistance != 0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 465, __PRETTY_FUNCTION__));
        me->seek_character_index(me, NewContentCharacterIndexBegin);



        buffer->_content_character_index_begin = NewContentCharacterIndexBegin;
        Lexer___BufferFiller_backward_copy_backup_region(buffer, BackwardDistance);






        LoadedN =



        Lexer___BufferFiller_read_characters(buffer, ContentFront, BackwardDistance);
        ((LoadedN == (size_t)BackwardDistance) ? static_cast<void> (0) : __assert_fail ("LoadedN == (size_t)BackwardDistance", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 483, __PRETTY_FUNCTION__));



        Lexer___BufferFiller_backward_adapt_pointers(buffer, BackwardDistance);

        buffer->_content_character_index_end = buffer->_content_character_index_begin
                                               + (Lexer_Buffer_text_end(buffer) - ContentFront);



        (((size_t)(me->tell_character_index(me) - buffer->_content_character_index_begin) == LoadedN) ? static_cast<void> (0) : __assert_fail ("(size_t)(me->tell_character_index(me) - buffer->_content_character_index_begin) == LoadedN", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 494, __PRETTY_FUNCTION__));

        ;
        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);
        QUEX_BUFFER_ASSERT_CONTENT_CONSISTENCY(buffer);

        return (size_t)BackwardDistance;
    }


    inline ptrdiff_t
    Lexer___BufferFiller_backward_compute_backward_distance(Lexer_Buffer* buffer)
    {
        const ptrdiff_t ContentSize = (ptrdiff_t)Lexer_Buffer_content_size(buffer);
        ptrdiff_t IntendedBackwardDistance = (ptrdiff_t)-1;
        ptrdiff_t Distance_InputP_to_LexemeStart = (ptrdiff_t)-1;
        ptrdiff_t LimitBackwardDist_1 = -1;
        ptrdiff_t LimitBackwardDist_2 = -1;
        ptrdiff_t Limit_1_and_2 = -1;
        ptrdiff_t BackwardDistance = -1;

        QUEX_BUFFER_ASSERT_CONSISTENCY(buffer);


        ((buffer->_input_p == buffer->_memory._front) ? static_cast<void> (0) : __assert_fail ("buffer->_input_p == buffer->_memory._front", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 518, __PRETTY_FUNCTION__));


        ((buffer->_content_character_index_begin != 0) ? static_cast<void> (0) : __assert_fail ("buffer->_content_character_index_begin != 0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 521, __PRETTY_FUNCTION__));




        ((buffer->_lexeme_start_p > buffer->_input_p) ? static_cast<void> (0) : __assert_fail ("buffer->_lexeme_start_p > buffer->_input_p", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 526, __PRETTY_FUNCTION__));
        (((size_t)(buffer->_lexeme_start_p - buffer->_input_p) < Lexer_Buffer_content_size(buffer)) ? static_cast<void> (0) : __assert_fail ("(size_t)(buffer->_lexeme_start_p - buffer->_input_p) < Lexer_Buffer_content_size(buffer)", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 527, __PRETTY_FUNCTION__));

        IntendedBackwardDistance = ContentSize > (ptrdiff_t)3 ? (ptrdiff_t)(ContentSize / 3)
                                   : (ptrdiff_t)1;
        Distance_InputP_to_LexemeStart = buffer->_lexeme_start_p - buffer->_input_p;
        LimitBackwardDist_1 = ContentSize - Distance_InputP_to_LexemeStart;




        LimitBackwardDist_2 = buffer->_content_character_index_begin;




        Limit_1_and_2 = LimitBackwardDist_1 < LimitBackwardDist_2 ? LimitBackwardDist_1
                        : LimitBackwardDist_2;

        BackwardDistance = IntendedBackwardDistance < Limit_1_and_2 ? IntendedBackwardDistance
                           : Limit_1_and_2;

        ((BackwardDistance > (ptrdiff_t)0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance > (ptrdiff_t)0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 564, __PRETTY_FUNCTION__));
        return (ptrdiff_t)BackwardDistance;
    }

    inline void
    Lexer___BufferFiller_backward_copy_backup_region(Lexer_Buffer* buffer,
                                                          const ptrdiff_t BackwardDistance)
    {
        const size_t ContentSize = Lexer_Buffer_content_size(buffer);
        uint8_t* ContentFront = Lexer_Buffer_content_front(buffer);

        ((BackwardDistance >= (ptrdiff_t)0) ? static_cast<void> (0) : __assert_fail ("BackwardDistance >= (ptrdiff_t)0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 575, __PRETTY_FUNCTION__));
        (((size_t)BackwardDistance < ContentSize) ? static_cast<void> (0) : __assert_fail ("(size_t)BackwardDistance < ContentSize", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 576, __PRETTY_FUNCTION__));



        std::memmove(ContentFront + BackwardDistance, ContentFront,
                           (size_t)(ContentSize - (size_t)BackwardDistance)*sizeof(uint8_t));



        std::memset((uint8_t*)ContentFront, (uint8_t)(0xFF),
                          (size_t)BackwardDistance * sizeof(uint8_t));

    }

    inline void
    Lexer___BufferFiller_backward_adapt_pointers(Lexer_Buffer* buffer,
                                                      const ptrdiff_t BackwardDistance)
    {

        if( buffer->_memory._end_of_file_p ) {
            uint8_t* NewEndOfFileP = buffer->_memory._end_of_file_p + BackwardDistance;
            if( NewEndOfFileP <= buffer->_memory._back )
                Lexer_Buffer_end_of_file_set(buffer, NewEndOfFileP);
            else
                Lexer_Buffer_end_of_file_unset(buffer);
        }

        buffer->_input_p += BackwardDistance + 1;
        buffer->_lexeme_start_p += BackwardDistance;
    }

    inline void
    Lexer___BufferFiller_on_overflow(Lexer_Buffer* buffer, bool ForwardF)
    {
        Lexer_BufferFiller* me = buffer->filler;
        if( me->_on_overflow == 0x0
            || me->_on_overflow(buffer, ForwardF) == false ) {
            do { throw std::runtime_error("Distance between lexeme start and current pointer exceeds buffer size.\n" "(tried to load buffer forward). Please, compile with option\n\n" "    QUEX_OPTION_INFORMATIVE_BUFFER_OVERFLOW_MESSAGE\n\n" "in order to get a more informative output. Most likely, one of your patterns\n" "eats longer as you inteded it. Alternatively you might want to set the buffer\n" "size to a greate value or use skippers (<skip: [ \\n\\t]> for example).\n"); } while(0)




                                                                                                        ;

        }
    }

    inline void
    Lexer_BufferFiller_step_forward_n_characters(Lexer_BufferFiller* me,
                                                      const ptrdiff_t ForwardN)
    {
        const ptrdiff_t TargetIndex = me->tell_character_index(me) + ForwardN;





        size_t remaining_character_n = (size_t)ForwardN;
        const size_t ChunkSize = (512);
        uint8_t chunk[(512)];

        (((512) >= 1) ? static_cast<void> (0) : __assert_fail ("(512) >= 1", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 679, __PRETTY_FUNCTION__));






        for(; remaining_character_n > ChunkSize; remaining_character_n -= ChunkSize )
            if( me->read_characters(me, (uint8_t*)chunk, ChunkSize) < ChunkSize ) {
                ((me->tell_character_index(me) <= TargetIndex) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index(me) <= TargetIndex", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 688, __PRETTY_FUNCTION__));
                return;
            }
        if( remaining_character_n )
            me->read_characters(me, (uint8_t*)chunk, remaining_character_n);

        ((me->tell_character_index(me) <= TargetIndex) ? static_cast<void> (0) : __assert_fail ("me->tell_character_index(me) <= TargetIndex", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/BufferFiller.i", 694, __PRETTY_FUNCTION__));
    }

    inline size_t
    Lexer___BufferFiller_read_characters(Lexer_Buffer* buffer,
                                              uint8_t* memory,
                                              const ptrdiff_t CharacterNToRead)
    {
        const size_t LoadedN = buffer->filler->read_characters(buffer->filler, memory, (size_t)CharacterNToRead);

        if( buffer->_byte_order_reversion_active_f ) {
            Lexer_Buffer_reverse_byte_order(memory, memory + LoadedN);
        }
        return LoadedN;
    }

}





       


namespace boeck {

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Plain_construct(Lexer_BufferFiller_Plain<InputHandleT>*, InputHandleT* input_handle);

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Plain_init(Lexer_BufferFiller_Plain<InputHandleT>* me, InputHandleT* input_handle);

    template <class InputHandleT> inline ptrdiff_t Lexer___BufferFiller_Plain_tell_character_index(Lexer_BufferFiller* alter_ego);
    template <class InputHandleT> inline void Lexer___BufferFiller_Plain_seek_character_index(
                                           Lexer_BufferFiller* alter_ego,
                                           const ptrdiff_t CharacterIndex);
    template <class InputHandleT> inline size_t Lexer___BufferFiller_Plain_read_characters(Lexer_BufferFiller* alter_ego,
                                                                          uint8_t* start_of_buffer,
                                                                          const size_t N);
    template <class InputHandleT> inline void Lexer___BufferFiller_Plain_delete_self(Lexer_BufferFiller* alter_ego);


    template <class InputHandleT> inline Lexer_BufferFiller_Plain<InputHandleT>*
    Lexer_BufferFiller_Plain_new(InputHandleT* input_handle)
    {
        Lexer_BufferFiller_Plain<InputHandleT>* me =
             (Lexer_BufferFiller_Plain<InputHandleT>*)
 Lexer_MemoryManager_BufferFiller_allocate(sizeof(Lexer_BufferFiller_Plain<InputHandleT>));
        ((me != 0x0) ? static_cast<void> (0) : __assert_fail ("me != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 44, __PRETTY_FUNCTION__));
        ((input_handle != 0x0) ? static_cast<void> (0) : __assert_fail ("input_handle != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 45, __PRETTY_FUNCTION__));

        Lexer_BufferFiller_Plain_construct(me, input_handle);

        return me;
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Plain_construct(Lexer_BufferFiller_Plain<InputHandleT>* me, InputHandleT* input_handle)
    {
        Lexer_BufferFiller_setup_functions(&me->base,
                                   Lexer___BufferFiller_Plain_tell_character_index<InputHandleT>,
                                   Lexer___BufferFiller_Plain_seek_character_index<InputHandleT>,
                                   Lexer___BufferFiller_Plain_read_characters<InputHandleT>,
                                   Lexer___BufferFiller_Plain_delete_self<InputHandleT>);

        Lexer_BufferFiller_Plain_init(me, input_handle);
    }

    template <class InputHandleT> inline void
    Lexer_BufferFiller_Plain_init(Lexer_BufferFiller_Plain<InputHandleT>* me, InputHandleT* input_handle)
    {
        me->ih = input_handle;
        me->start_position = InputPolicy<InputHandleT*>::tell((me->ih));



        me->_last_stream_position = InputPolicy<InputHandleT*>::tell((me->ih));
    }

    template <class InputHandleT> inline void
    Lexer___BufferFiller_Plain_delete_self(Lexer_BufferFiller* alter_ego)
    {
        Lexer_BufferFiller_Plain<InputHandleT>* me = (Lexer_BufferFiller_Plain<InputHandleT>*)alter_ego;
        Lexer_MemoryManager_BufferFiller_free((void*)me);

    }

    template <class InputHandleT> inline ptrdiff_t
    Lexer___BufferFiller_Plain_tell_character_index(Lexer_BufferFiller* alter_ego)
    {


       Lexer_BufferFiller_Plain<InputHandleT>* me = (Lexer_BufferFiller_Plain<InputHandleT>*)alter_ego;

       ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 90, __PRETTY_FUNCTION__));
       ((me->ih != 0x0) ? static_cast<void> (0) : __assert_fail ("me->ih != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 91, __PRETTY_FUNCTION__));



       ((me->_last_stream_position == InputPolicy<InputHandleT*>::tell((me->ih))) ? static_cast<void> (0) : __assert_fail ("me->_last_stream_position == InputPolicy<InputHandleT*>::tell((me->ih))", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 95, __PRETTY_FUNCTION__));





       return (ptrdiff_t)( (me->_last_stream_position - me->start_position)
                          / (typename InputPolicy<InputHandleT*>::stream_position)sizeof(uint8_t));

    }





    template <class InputHandleT> inline void
    Lexer___BufferFiller_Plain_seek_character_index(Lexer_BufferFiller* alter_ego,
                                                         const ptrdiff_t CharacterIndex)
    {
        Lexer_BufferFiller_Plain<InputHandleT>* me = (Lexer_BufferFiller_Plain<InputHandleT>*)alter_ego;
        long avoid_tmp_arg = -1;

        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 117, __PRETTY_FUNCTION__));


        ((me->ih != 0x0) ? static_cast<void> (0) : __assert_fail ("me->ih != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 120, __PRETTY_FUNCTION__));

        avoid_tmp_arg = (long)( ((size_t)CharacterIndex) * sizeof(uint8_t))
                        + (long)(me->start_position);

        InputPolicy<InputHandleT*>::seek((me->ih), (avoid_tmp_arg));
        me->_last_stream_position = InputPolicy<InputHandleT*>::tell((me->ih));
    }
    template <class InputHandleT> inline size_t
    Lexer___BufferFiller_Plain_read_characters(Lexer_BufferFiller* alter_ego,
                                                    uint8_t* buffer_memory,
                                                    const size_t N)
    {
        Lexer_BufferFiller_Plain<InputHandleT>* me = (Lexer_BufferFiller_Plain<InputHandleT>*)alter_ego;
        size_t ByteN = (size_t)-1;
        size_t CharacterN = (size_t)-1;

        ((alter_ego != 0x0) ? static_cast<void> (0) : __assert_fail ("alter_ego != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 166, __PRETTY_FUNCTION__));
        ((buffer_memory != 0x0) ? static_cast<void> (0) : __assert_fail ("buffer_memory != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 167, __PRETTY_FUNCTION__));



        std::memset((uint8_t*)buffer_memory, 0xFF, N * sizeof(uint8_t));


        ((me->ih != 0x0) ? static_cast<void> (0) : __assert_fail ("me->ih != 0x0", "/home/fschaef/prj/quex/trunk/quex/code_base/buffer/plain/BufferFiller_Plain.i", 174, __PRETTY_FUNCTION__));
        ByteN = InputPolicy<InputHandleT*>::load_bytes((me->ih), (uint8_t*)(buffer_memory), (N * sizeof(uint8_t)))
                                                                                            ;

        if( ByteN % sizeof(uint8_t) != 0 )
            do { throw std::runtime_error("Error: End of file cuts in the middle a multi-byte character."); } while(0);

        CharacterN = ByteN / sizeof(uint8_t);





        me->_last_stream_position = InputPolicy<InputHandleT*>::tell((me->ih));
        return CharacterN;
    }



}














namespace boeck {

    inline void
    Lexer_Counter_init(Lexer_Counter* me)
    {
        me->_line_number_at_begin = (size_t)0;
        me->_line_number_at_end = (size_t)1;
        me->_column_number_at_begin = (size_t)0;
        me->_column_number_at_end = (size_t)1;
        ;
    }

    inline void
    Lexer_Counter_construct(Lexer_Counter* me)
    {

        memset((void*)me, 0xFF, sizeof(Lexer_Counter));

        Lexer_Counter_init((Lexer_Counter*)me);
    }

    inline void
    Lexer_Counter_reset(Lexer_Counter* me)
    {
        Lexer_Counter_init((Lexer_Counter*)me);
    }

    inline void
    Lexer_Counter_count(Lexer_Counter* me,
                             uint8_t* Begin, uint8_t* End)






    {


        uint8_t* it = Lexer_Counter_count_chars_to_newline_backwards(me, Begin, End);
        if( *it == '\n' ) ++(me->_line_number_at_end);






        ((it >= Begin) ? static_cast<void> (0) : __assert_fail ("it >= Begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 55, __PRETTY_FUNCTION__));


        while( it != Begin ) {
            --it;
            if( *it == '\n' ) ++(me->_line_number_at_end);
        }



    }

    inline void
    Lexer_Counter_count_FixNewlineN(Lexer_Counter* me,
                                                   uint8_t* Lexeme,
                                                   uint8_t* LexemeEnd,
                                                   const int LineNIncrement)
    {
        ((LexemeEnd > Lexeme) ? static_cast<void> (0) : __assert_fail ("LexemeEnd > Lexeme", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 73, __PRETTY_FUNCTION__));


        Lexer_Counter_count_chars_to_newline_backwards(me, (uint8_t*)Lexeme,
                                                            (uint8_t*)(LexemeEnd));

        me->_line_number_at_end += (size_t)LineNIncrement;
    }


    inline uint8_t*
    Lexer_Counter_count_chars_to_newline_backwards(Lexer_Counter* me,
                                                        uint8_t* Begin,
                                                        uint8_t* End)
    {
        uint8_t* it = 0x0;

        ((Begin < End) ? static_cast<void> (0) : __assert_fail ("Begin < End", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 103, __PRETTY_FUNCTION__));
        for(it = End - 1; *it != '\n' ; --it) {
            if( it == Begin ) {




                me->_column_number_at_end += (size_t)(End - Begin);
                return it;
            }
        }

        ((End >= it) ? static_cast<void> (0) : __assert_fail ("End >= it", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Counter.i", 123, __PRETTY_FUNCTION__));


        me->_column_number_at_end = (size_t)(End - it);

        return it;
    }

    inline void
    Lexer_Counter_print_this(Lexer_Counter* me)
    {
        ;

        std::printf("   Counter:\n");

        std::printf("   _line_number_at_begin = %i;\n", (int)me->_line_number_at_begin);
        std::printf("   _line_number_at_end   = %i;\n", (int)me->_line_number_at_end);


        std::printf("   _column_number_at_begin = %i;\n", (int)me->_column_number_at_begin);
        std::printf("   _column_number_at_end   = %i;\n", (int)me->_column_number_at_end);
    }
}



namespace boeck {

    template <class InputHandleT> inline void
    Lexer_include_push(::boeck::Lexer* me,
                            InputHandleT* Optional_InputHandle,
                            uint8_t* Optional_InputName,
                            const Lexer_Mode* Mode,
                            const char* CharacterCodecName )
    {



        InputHandleT* input_handle = Optional_InputHandle;

        Lexer_Memento* m = Lexer_memento_pack<InputHandleT>(me, Optional_InputName, &input_handle);




        if( input_handle == 0x0 ) {
            do { throw std::runtime_error("Segment 'memento_pack' segment did not set the input_handle."); } while(0);
        }




        Lexer_Buffer_construct(&me->buffer, input_handle,
                                    0x0, 65536, 0x0,
                                    CharacterCodecName, ((size_t)0),
                                    me->buffer._byte_order_reversion_active_f);


        if( Mode != 0x0 ) Lexer_set_mode_brutally(me, (Lexer_Mode*)Mode);
        Lexer_Counter_construct(&me->counter);



        Lexer_Accumulator_construct(&me->accumulator, me);




        me->__file_handle_allocated_by_constructor = 0x0;


        me->_parent_memento = m;
    }

    template <class InputHandleT> inline void
    Lexer_include_push_input_name(::boeck::Lexer* me,
                                       uint8_t* InputName,
                                       const Lexer_Mode* mode,
                                       const char* CharacterCodecName )
    {



        Lexer_include_push<InputHandleT>(me, 0x0, InputName, mode, CharacterCodecName);



    }

    template <class InputHandleT> inline void
    Lexer_include_push_input_handle(::boeck::Lexer* me,
                                         InputHandleT* sh,
                                         const Lexer_Mode* mode,
                                         const char* CharacterCodecName )
    {


        Lexer_include_push<InputHandleT>(me, sh, 0x0, mode, CharacterCodecName);



    }

    inline bool
    Lexer_include_pop(::boeck::Lexer* me)
    {

        if( me->_parent_memento == 0x0 ) return false;



        Lexer_Buffer_destruct(&me->buffer);
        Lexer_Accumulator_destruct(&me->accumulator);







        Lexer_memento_unpack(me, me->_parent_memento);


        return true;
    }

    inline void
    Lexer_include_stack_delete(::boeck::Lexer* me)
    {
        while( me->_parent_memento != 0x0 ) {
            if( Lexer_include_pop(me) == false ) {
                do { throw std::runtime_error("Error during deletion of include stack."); } while(0);
            }
        }
    }


    template <class InputHandleT> inline void
    Lexer::include_push(InputHandleT* sh,
                              const Lexer_Mode* Mode,
                              const char* CharacterCodecName )
    { Lexer_include_push_input_handle<InputHandleT>(this, sh, Mode, CharacterCodecName); }

    template <class InputHandleT> inline void
    Lexer::include_push(uint8_t* InputName,
                              const Lexer_Mode* Mode,
                              const char* CharacterCodecName )
    { Lexer_include_push_input_name<InputHandleT>(this, InputName, Mode, CharacterCodecName); }

    inline bool
    Lexer::include_pop()
    { return Lexer_include_pop(this); }

    inline void
    Lexer::include_stack_delete()
    { Lexer_include_stack_delete(this); }


}




namespace boeck {

inline void
Lexer_Accumulator_construct(Lexer_Accumulator* me,
                                 ::boeck::Lexer* lexer)
{
    me->the_lexer = lexer;
    Lexer_Accumulator_init_memory(me);
    me->_begin_line = 0;
    me->_begin_column = 0;
}


inline void
Lexer_Accumulator_destruct(Lexer_Accumulator* me)
{
    if( me->text.begin != 0x0 ) {
        Lexer_MemoryManager_Text_free(me->text.begin);
    }
    me->the_lexer = 0x0;
    me->text.begin = 0x0;
    me->text.end = 0x0;
    me->text.memory_end = 0x0;
}

inline void
Lexer_Accumulator_init_memory(Lexer_Accumulator* me)
{
    if( (256) == 0 ) {
        me->text.begin = 0x0;
    } else {
        me->text.begin =
 Lexer_MemoryManager_Text_allocate(
                      (256) * sizeof(uint8_t));
        if( me->text.begin == 0x0 ) {
            do { throw std::runtime_error("Quex engine: out of memory--cannot allocate Accumulator."); } while(0);
        }
    }
    me->text.end = me->text.begin;
    me->text.memory_end = me->text.begin + (256);
}

inline bool
Lexer_Accumulator_extend(Lexer_Accumulator* me, size_t MinAddSize)
{
    const size_t OldContentSize = (size_t)(me->text.end - me->text.begin);
    const size_t Size = (size_t)(me->text.memory_end - me->text.begin);
    const size_t AddSize = (size_t)((float)Size * (float)(0.8));
    const size_t NewSize = Size + (AddSize < MinAddSize ? MinAddSize : AddSize);

    uint8_t* chunk =
 Lexer_MemoryManager_Text_allocate(NewSize*sizeof(uint8_t));

    if( chunk == 0x0 ) return false;

    ((me->text.end >= me->text.begin) ? static_cast<void> (0) : __assert_fail ("me->text.end >= me->text.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 71, __PRETTY_FUNCTION__));
    ((me->text.memory_end >= me->text.begin) ? static_cast<void> (0) : __assert_fail ("me->text.memory_end >= me->text.begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 72, __PRETTY_FUNCTION__));

    std::memcpy(chunk, me->text.begin, sizeof(uint8_t) * Size);

    Lexer_MemoryManager_Text_free(me->text.begin);

    me->text.begin = chunk;
    me->text.end = chunk + OldContentSize;
    me->text.memory_end = chunk + NewSize;
    return true;
}

inline void
Lexer_Accumulator_clear(Lexer_Accumulator* me)
{

    if( me->text.begin == me->text.end ) return;
    me->text.end = me->text.begin;
}

inline void
Lexer_Accumulator_add(Lexer_Accumulator* me,
                           const uint8_t* Begin, const uint8_t* End)
{
    const size_t L = (size_t)(End - Begin);
    ((End > Begin) ? static_cast<void> (0) : __assert_fail ("End > Begin", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 97, __PRETTY_FUNCTION__));



    if( me->text.begin == me->text.end ) {
        me->_begin_column = me->the_lexer->counter._column_number_at_begin;
        me->_begin_line = me->the_lexer->counter._line_number_at_begin;
    }




    if( me->text.memory_end <= me->text.end + L ) {

        if( Lexer_Accumulator_extend(me, L + 1) == false ) {
            do { throw std::runtime_error("Quex Engine: Out of Memory. Accumulator could not be further extended.\n"); } while(0);
        }
    }

    std::memcpy(me->text.end, Begin, L * sizeof(uint8_t));
    me->text.end += L;
}


inline void
Lexer_Accumulator_add_character(Lexer_Accumulator* me,
                                     const uint8_t Character)
{


    if( me->text.begin == me->text.end ) {
        me->_begin_column = me->the_lexer->counter._column_number_at_begin;
        me->_begin_line = me->the_lexer->counter._line_number_at_begin;
    }




    if( me->text.memory_end <= me->text.end + 1 ) {

        if( Lexer_Accumulator_extend(me, 2) == false ) {
            do { throw std::runtime_error("Quex Engine: Out of Memory. Accumulator could not be further extended.\n"); } while(0);
        }
    }

    *(me->text.end) = Character;
    ++(me->text.end);
}
inline void
Lexer_Accumulator_print_this(Lexer_Accumulator* me)
{

    ((me->text.end < me->text.memory_end) ? static_cast<void> (0) : __assert_fail ("me->text.end < me->text.memory_end", "/home/fschaef/prj/quex/trunk/quex/code_base/analyzer/Accumulator.i", 181, __PRETTY_FUNCTION__));

    *(me->text.end) = (uint8_t)0;

    std::printf("   Accumulator = '%s'\n", (const char*)me->text.begin);
}

}



typedef enum {
    QUEX_BOM_NONE = 0x200,
    QUEX_BOM_UTF_8 = 0x001,
    QUEX_BOM_UTF_1 = 0x002,
    QUEX_BOM_UTF_EBCDIC = 0x004,
    QUEX_BOM_BOCU_1 = 0x008,
    QUEX_BOM_GB_18030 = 0x010,
    QUEX_BOM_UTF_7 = 0x220,

    QUEX_BOM_UTF_16 = 0x040,
    QUEX_BOM_UTF_16_LE = 0x041,
    QUEX_BOM_UTF_16_BE = 0x042,
    QUEX_BOM_UTF_32 = 0x080,
    QUEX_BOM_UTF_32_LE = 0x081,
    QUEX_BOM_UTF_32_BE = 0x082,
    QUEX_BOM_SCSU = 0x100,
    QUEX_BOM_SCSU_TO_UCS = 0x101,
    QUEX_BOM_SCSU_W0_TO_FE80 = 0x102,
    QUEX_BOM_SCSU_W1_TO_FE80 = 0x103,
    QUEX_BOM_SCSU_W2_TO_FE80 = 0x104,
    QUEX_BOM_SCSU_W3_TO_FE80 = 0x105,
    QUEX_BOM_SCSU_W4_TO_FE80 = 0x106,
    QUEX_BOM_SCSU_W5_TO_FE80 = 0x107,
    QUEX_BOM_SCSU_W6_TO_FE80 = 0x108,
    QUEX_BOM_SCSU_W7_TO_FE80 = 0x109
} QUEX_TYPE_BOM;

namespace quex {

template <class InputHandleT> inline QUEX_TYPE_BOM
bom_snap(InputHandleT* InputHandle);

inline QUEX_TYPE_BOM
bom_identify(const uint8_t* const Buffer, size_t* n);

inline const char*
bom_name(QUEX_TYPE_BOM BOM);

}


namespace quex {

template <class InputHandleT> inline QUEX_TYPE_BOM
bom_snap(InputHandleT* InputHandle)
{
    uint8_t buffer[4] = { 0, 0, 0, 0};
    QUEX_TYPE_BOM result = QUEX_BOM_NONE;
    size_t byte_n = 0;
    size_t read_n = 0;

    typename InputPolicy<InputHandleT*>::stream_position p0 = (typename InputPolicy<InputHandleT*>::stream_position)-1;

    p0 = (typename InputPolicy<InputHandleT*>::stream_position)InputPolicy<InputHandleT*>::tell((InputHandle));
    read_n = (size_t)InputPolicy<InputHandleT*>::load_bytes((InputHandle), (uint8_t*)(buffer), (4));
    if( read_n == 0 ) {
        return QUEX_BOM_NONE;
    }
    (void)(typename InputPolicy<InputHandleT*>::stream_position)InputPolicy<InputHandleT*>::tell((InputHandle));



    switch(read_n) {
        case 0: return QUEX_BOM_NONE;
        case 1: buffer[1] = 0x77; buffer[2] = 0x77; buffer[3] = 0x77; break;
        case 2: buffer[2] = 0x77; buffer[3] = 0x77; break;
        case 3: buffer[3] = 0x77; break;
    }

    result = bom_identify(buffer, &byte_n);


    p0 += (typename InputPolicy<InputHandleT*>::stream_position)byte_n;
    InputPolicy<InputHandleT*>::seek((InputHandle), (p0));

    return result;
}

inline QUEX_TYPE_BOM
bom_identify(const uint8_t* const Buffer, size_t* n)

{

    const uint8_t B0 = Buffer[0];
    const uint8_t B1 = Buffer[1];
    const uint8_t B2 = Buffer[2];
    const uint8_t B3 = Buffer[3];
    QUEX_TYPE_BOM x = QUEX_BOM_NONE;

    switch( B0 ) {
    case 0x00: if( B1 == 0x00 && B2 == 0xFE && B3 == 0xFF ) { *n = 4; x = QUEX_BOM_UTF_32_BE; } break;
    case 0x0E: if( B1 == 0xFE && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU; } break;
    case 0x0F: if( B1 == 0xFE && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_TO_UCS; } break;
    case 0x18: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W0_TO_FE80; } break;
    case 0x19: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W1_TO_FE80; } break;
    case 0x1A: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W2_TO_FE80; } break;
    case 0x1B: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W3_TO_FE80; } break;
    case 0x1C: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W4_TO_FE80; } break;
    case 0x1D: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W5_TO_FE80; } break;
    case 0x1E: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W6_TO_FE80; } break;
    case 0x1F: if( B1 == 0xA5 && B2 == 0xFF ) { *n = 3; x = QUEX_BOM_SCSU_W7_TO_FE80; } break;
    case 0x2B:



           *n = 0;
           if( B1 == 0x2F && B2 == 0x76 ) {
               switch( B3 )
               { case 0x2B: case 0x2F: case 0x38: case 0x39: x = QUEX_BOM_UTF_7; }
           }
           break;
    case 0x84: if( B1 == 0x31 && B2 == 0x95 && B3 == 0x33 ) { *n = 4; x = QUEX_BOM_GB_18030; } break;
    case 0xDD: if( B1 == 0x73 && B2 == 0x66 && B3 == 0x73 ) { *n = 4; x = QUEX_BOM_UTF_EBCDIC; } break;
    case 0xEF: if( B1 == 0xBB && B2 == 0xBF ) { *n = 3; x = QUEX_BOM_UTF_8; } break;
    case 0xF7: if( B1 == 0x64 && B2 == 0x4C ) { *n = 3; x = QUEX_BOM_UTF_1; } break;
    case 0xFB:
           if( B1 == 0xEE && B2 == 0x28 ) {
               if( B3 == 0xFF ) { *n = 4; x = QUEX_BOM_BOCU_1; }
               else { *n = 3; x = QUEX_BOM_BOCU_1; }
           }
           break;
    case 0xFE:
           if( B1 == 0xFF ) { *n = 2; x = QUEX_BOM_UTF_16_BE; } break;
    case 0xFF:
           if( B1 == 0xFE ) {
               if( B2 == 0x00 && B3 == 0x00 ) { *n = 4; x = QUEX_BOM_UTF_32_LE; }
               else { *n = 2; x = QUEX_BOM_UTF_16_LE; }
           }
           break;
    default:
           *n = 0;
    }

    return x;
}

inline const char*
bom_name(QUEX_TYPE_BOM BOM)
{
    switch( BOM ) {
    case QUEX_BOM_UTF_8: return "UTF_8";
    case QUEX_BOM_UTF_1: return "UTF_1";
    case QUEX_BOM_UTF_EBCDIC: return "UTF_EBCDIC";
    case QUEX_BOM_BOCU_1: return "BOCU_1";
    case QUEX_BOM_GB_18030: return "GB_18030";
    case QUEX_BOM_UTF_7: return "UTF_7";
    case QUEX_BOM_UTF_16: return "UTF_16";
    case QUEX_BOM_UTF_16_LE: return "UTF_16_LE";
    case QUEX_BOM_UTF_16_BE: return "UTF_16_BE";
    case QUEX_BOM_UTF_32: return "UTF_32";
    case QUEX_BOM_UTF_32_LE: return "UTF_32_LE";
    case QUEX_BOM_UTF_32_BE: return "UTF_32_BE";
    case QUEX_BOM_SCSU: return "SCSU";
    case QUEX_BOM_SCSU_TO_UCS: return "SCSU_TO_UCS";
    case QUEX_BOM_SCSU_W0_TO_FE80: return "SCSU_W0_TO_FE80";
    case QUEX_BOM_SCSU_W1_TO_FE80: return "SCSU_W1_TO_FE80";
    case QUEX_BOM_SCSU_W2_TO_FE80: return "SCSU_W2_TO_FE80";
    case QUEX_BOM_SCSU_W3_TO_FE80: return "SCSU_W3_TO_FE80";
    case QUEX_BOM_SCSU_W4_TO_FE80: return "SCSU_W4_TO_FE80";
    case QUEX_BOM_SCSU_W5_TO_FE80: return "SCSU_W5_TO_FE80";
    case QUEX_BOM_SCSU_W6_TO_FE80: return "SCSU_W6_TO_FE80";
    case QUEX_BOM_SCSU_W7_TO_FE80: return "SCSU_W7_TO_FE80";
    default:
    case QUEX_BOM_NONE: return "NONE";
    }
}

}


using namespace std;


int
main(int argc, char** argv)
{

    max::Lexer max_lex("example-utf16.txt", "UTF16");
    moritz::Lexer moritz_lex("example-ucs2.txt", "UCS-2");
    boeck::Lexer boeck_lex("example-utf8.txt");
    max::Token* max_token = 0x0;
    moritz::Token* moritz_token = 0x0;
    boeck::Token* boeck_token = 0x0;




    printf("                Max:        Moritz:      Boeck:\n");

    max_token = max_lex.token_p();
    moritz_token = moritz_lex.token_p();
    boeck_token = boeck_lex.token_p();
    do {
        (void)max_lex.receive();
        (void)moritz_lex.receive();
        (void)boeck_lex.receive();


        char* lexeme = (char*)max_token->pretty_char_text().c_str();
        int L = (int)max_token->text.length();

        printf("%s", lexeme);

        for(int i=0; i < 10 - L ; ++i) printf(" ");
        printf("\t");
        printf("%s   %s   %s\n",
               max_token->type_id_name().c_str(),
               moritz_token->type_id_name().c_str(),
               boeck_token->type_id_name().c_str());

    } while( boeck_token->type_id() != TKN_TERMINATION );

    return 0;
}
